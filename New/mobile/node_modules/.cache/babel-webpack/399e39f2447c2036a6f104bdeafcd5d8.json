{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { from, ReplaySubject, Subscription } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { endpoints } from './constants/endpoints';\nimport { VideoModalComponent } from '@shared-lib/modules/journeys/journey/steps/step/video/video-modal/video-modal.component';\nimport * as journeyContent from './constants/journey-content.json';\nimport { VoyaIABController } from '@mobile/app/modules/shared/service/in-app-browser/controllers/voya-iab-controller';\nimport { Status } from '../../constants/status.enum';\nimport { ContentLinkModalComponent } from '@shared-lib/modules/journeys/journey/steps/step/contentLink/contentLinkModal/contentLinkModal.component';\nimport { injectionTokenMap } from './constants/injectionTokens';\nimport { ValidationType } from './constants/validationType.enum';\nimport { eventKeys } from '@shared-lib/constants/event-keys';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../base/base-factory-provider\";\nimport * as i2 from \"../utility/utility.service\";\nimport * as i3 from \"@ionic/angular\";\nimport * as i4 from \"@mobile/app/modules/shared/service/in-app-browser/in-app-browser.service\";\nimport * as i5 from \"@ionic-native/preview-any-file/ngx\";\nimport * as i6 from \"@shared-lib/modules/event-manager/event-manager/event-manager.service\";\nexport let JourneyService = /*#__PURE__*/(() => {\n  class JourneyService {\n    constructor(baseService, utilityService, modalController, inAppBrowser, injector, previewAnyFile, eventManagerService) {\n      this.baseService = baseService;\n      this.utilityService = utilityService;\n      this.modalController = modalController;\n      this.inAppBrowser = inAppBrowser;\n      this.injector = injector;\n      this.previewAnyFile = previewAnyFile;\n      this.eventManagerService = eventManagerService;\n      this.subscription = new Subscription();\n      this.stepContentSubject = null;\n      this.currentStepSubject = new ReplaySubject(1);\n      this.content = journeyContent.default;\n      this.selectedTab$ = new ReplaySubject(1);\n      this.journeyServiceMap = {};\n      this.statusOrder = [Status.inProgress, Status.notStarted, Status.completed];\n      this.endpoints = this.utilityService.appendBaseUrlToEndpoints(endpoints);\n      this.refreshJourneys();\n      this.leaveJourneyPublisher = this.eventManagerService.createPublisher(eventKeys.leaveJourney);\n    }\n\n    fetchJourneys(refresh = false) {\n      if (this.journeyResponseSubject == null || refresh) {\n        if (this.journeyResponseSubject == null) {\n          this.journeyResponseSubject = new ReplaySubject(1);\n        }\n\n        const journeyResponse = from(this.baseService.get(this.endpoints.getJourneys)).pipe(map(journeyRes => {\n          this.parseContent(journeyRes);\n          journeyRes.recommended = this.getRecommendedJourneys(journeyRes.recommended);\n          this.journeyResponse = journeyRes;\n          return journeyRes;\n        }));\n        this.subscription.add(journeyResponse.subscribe(journeyRes => {\n          this.journeyResponseSubject.next(journeyRes);\n        }));\n      }\n\n      return this.journeyResponseSubject;\n    }\n\n    refreshJourneys() {\n      this.subscription.add(this.utilityService.getPlatformResume().subscribe(() => {\n        this.fetchJourneys(true);\n      }));\n    }\n\n    updateJourneySteps(steps, journeyId) {\n      var _a;\n\n      if (this.journeyResponse) {\n        this.updateJourneyListWithSteps(steps, journeyId, this.journeyResponse.all);\n        this.updateJourneyListWithSteps(steps, journeyId, this.journeyResponse.recommended);\n        this.journeyResponse.recommended = this.getRecommendedJourneys(this.journeyResponse.recommended);\n      }\n\n      if (this.journeyServiceMap[journeyId] && this.journeyServiceMap[journeyId].stepChange) {\n        this.journeyServiceMap[journeyId].stepChange(this.getCurrentJourney());\n      }\n\n      if (this.utilityService.getIsWeb()) {\n        setTimeout(function () {\n          var _a;\n\n          (_a = this.journeyResponseSubject) === null || _a === void 0 ? void 0 : _a.next(this.journeyResponse);\n        });\n      } else {\n        (_a = this.journeyResponseSubject) === null || _a === void 0 ? void 0 : _a.next(this.journeyResponse);\n      }\n    }\n\n    updateJourneyListWithSteps(steps, journeyId, list) {\n      if (list) {\n        const currentJourney = list.find(journey => journey.journeyID === journeyId);\n\n        if (currentJourney) {\n          currentJourney.steps = steps;\n          this.setCurrentJourney(currentJourney);\n        }\n      }\n    }\n\n    parseContent(journeyResponse) {\n      if (journeyResponse) {\n        this.parseJourneyListContent(journeyResponse.all);\n        this.parseJourneyListContent(journeyResponse.recommended);\n        this.sortJourneys(journeyResponse.all);\n        this.sortJourneys(journeyResponse.recommended);\n      }\n    }\n\n    sortJourneys(journeys) {\n      journeys.sort((a, b) => {\n        const comingSoonA = this.isComingSoon(a);\n        const comingSoonB = this.isComingSoon(b);\n        let returnVal;\n\n        if (comingSoonA && comingSoonB) {\n          returnVal = 0;\n        } else if (comingSoonA) {\n          returnVal = 1;\n        } else if (comingSoonB) {\n          returnVal = -1;\n        } else {\n          const statusOrderA = this.statusOrder.indexOf(this.getJourneyStatus(a.steps));\n          const statusOrderB = this.statusOrder.indexOf(this.getJourneyStatus(b.steps));\n\n          if (statusOrderA === statusOrderB) {\n            returnVal = 0;\n          } else if (statusOrderA < statusOrderB) {\n            returnVal = -1;\n          } else {\n            returnVal = 1;\n          }\n        }\n\n        return returnVal;\n      });\n    }\n\n    parseJourneyListContent(journeys) {\n      if (journeys) {\n        journeys.forEach(journey => {\n          journey.parsedLandingAndOverviewContent = journey.landingAndOverviewContent ? JSON.parse(journey.landingAndOverviewContent) : null;\n          journey.parsedResourcesContent = journey.resourcesContent ? JSON.parse(journey.resourcesContent) : null;\n          journey.parsedComingSoonContent = journey.comingSoonContent ? JSON.parse(journey.comingSoonContent) : null;\n          return journey;\n        });\n      }\n    }\n\n    getRecommendedJourneys(journeys) {\n      const recommendedJourneys = [];\n      journeys === null || journeys === void 0 ? void 0 : journeys.forEach(journey => {\n        if (this.getJourneyStatus(journey.steps) !== Status.completed) {\n          recommendedJourneys.push(journey);\n        }\n      });\n      return recommendedJourneys;\n    }\n\n    setCurrentJourney(journey, updateResponse = false) {\n      var _a;\n\n      const previousJourney = this.getCurrentJourney();\n\n      if (journey !== previousJourney) {\n        this.resetStepContent();\n        localStorage.setItem('currentJourney', JSON.stringify(journey));\n        this.currentJourney = journey;\n\n        if (updateResponse) {\n          const allIndex = this.journeyResponse.all.findIndex(j => j.journeyID === journey.journeyID);\n          this.journeyResponse.all[allIndex] = journey;\n          const recommendedIndex = (_a = this.journeyResponse) === null || _a === void 0 ? void 0 : _a.recommended.findIndex(j => j.journeyID === journey.journeyID);\n\n          if (recommendedIndex || recommendedIndex === 0) {\n            this.journeyResponse.recommended[recommendedIndex] = journey;\n          }\n\n          this.journeyResponseSubject.next(this.journeyResponse);\n        }\n      }\n    }\n\n    getCurrentJourney() {\n      const currentJourney = localStorage.getItem('currentJourney');\n      return currentJourney !== 'undefined' && currentJourney ? JSON.parse(currentJourney) : this.currentJourney;\n    }\n\n    saveProgress(stepStatuses) {\n      return this.baseService.post(this.endpoints.saveStepProgress, stepStatuses);\n    }\n\n    fetchStepContent(journeyStepTagId, msgType) {\n      if (this.stepContentSubject == null) {\n        this.stepContentSubject = new ReplaySubject(1);\n        const subscription = from(this.baseService.get(this.endpoints.getStepContent + msgType)).subscribe(this.stepContentSubject);\n        this.subscription.add(subscription);\n      }\n\n      return this.stepContentSubject.pipe(map(content => {\n        let stepContentResponse;\n\n        if (content[journeyStepTagId]) {\n          stepContentResponse = JSON.parse(content[journeyStepTagId]);\n        }\n\n        return stepContentResponse;\n      }));\n    }\n\n    resetStepContent() {\n      this.stepContentSubject = null;\n    }\n\n    publishCurrentStep(step) {\n      this.currentStepSubject.next(step);\n    }\n\n    getCurrentStep$() {\n      return this.currentStepSubject;\n    }\n\n    openVideoModal(videoUrl, playerId) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const modal = yield this.modalController.create({\n          component: VideoModalComponent,\n          componentProps: {\n            videoUrl: videoUrl,\n            playerId: playerId\n          },\n          cssClass: 'modal-fullscreen',\n          swipeToClose: false\n        });\n        return modal.present();\n      });\n    }\n\n    openContentLinkModal(element) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const modal = yield this.modalController.create({\n          component: ContentLinkModalComponent,\n          componentProps: {\n            element: element\n          },\n          cssClass: 'modal-fullscreen',\n          swipeToClose: false\n        });\n        return modal.present();\n      });\n    }\n\n    openWebView(link, header, toolbar) {\n      if (this.utilityService.getIsWeb()) {\n        window.open(link, '_blank');\n      } else {\n        if (link.includes('.pdf')) {\n          this.previewAnyFile.preview(link);\n        } else {\n          const voyaController = new VoyaIABController();\n          voyaController.headerText = header;\n\n          if (toolbar) {\n            voyaController.browserOptions.toolbar = 'yes';\n          }\n\n          this.inAppBrowser.openInAppBrowser(link, voyaController);\n        }\n      }\n    }\n\n    safeParse(str) {\n      let parsedResult;\n\n      try {\n        parsedResult = JSON.parse(str);\n      } catch (error) {\n        if (str) {\n          console.error(error);\n        }\n      }\n\n      return parsedResult;\n    }\n\n    findElementByProp(content, prop, value) {\n      let stepContentElement;\n\n      for (const pageElement of content.pageElements) {\n        if (stepContentElement) {\n          break;\n        }\n\n        const elements = pageElement.elements;\n\n        for (const element of elements) {\n          if (element[prop] === value) {\n            stepContentElement = element;\n            break;\n          }\n        }\n      }\n\n      return stepContentElement;\n    }\n\n    isSummaryStepCompleted() {\n      const journey = this.getCurrentJourney();\n      let summaryStepCompleted = false;\n\n      if (journey.parsedLandingAndOverviewContent.overview.requiredSteps) {\n        summaryStepCompleted = this.checkRequiredStepStatus(journey);\n      } else {\n        journey.parsedLandingAndOverviewContent.overview.summarySteps.forEach(summaryStep => {\n          if (journey.steps.find(step => summaryStep.journeyStepName === step.journeyStepName && step.status === Status.completed)) {\n            summaryStepCompleted = true;\n          }\n        });\n      }\n\n      return summaryStepCompleted;\n    }\n\n    checkRequiredStepStatus(journey) {\n      let requiredCompleted = true;\n      journey.parsedLandingAndOverviewContent.overview.requiredSteps.forEach(summaryStepName => {\n        const step = journey.steps.find(journeyStep => journeyStep.journeyStepName === summaryStepName);\n\n        if ((step === null || step === void 0 ? void 0 : step.status) !== Status.completed) {\n          requiredCompleted = false;\n        }\n      });\n      return requiredCompleted;\n    }\n\n    setStepContent(journey) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(r => {\n          journey.steps.forEach((step, i) => __awaiter(this, void 0, void 0, function* () {\n            if (step.journeyStepCMSTagId) {\n              this.subscription.add(this.fetchStepContent(step.journeyStepCMSTagId, step.msgType).subscribe(content => __awaiter(this, void 0, void 0, function* () {\n                step.content = content;\n                this.setIdSufixes(step.content, i);\n\n                if (i === journey.steps.length - 1) {\n                  yield this.initializeServices(journey);\n                  r();\n                }\n              })));\n            }\n          }));\n        });\n      });\n    }\n\n    setIdSufixes(content, index) {\n      var _a;\n\n      if (content) {\n        content.pageElements.forEach((elements, pageElementIndex) => {\n          elements.elements.forEach((el, elementIndex) => {\n            if ('id' in el) {\n              el.idSuffix = '' + pageElementIndex + elementIndex + index;\n            } else if ('pageElements' in el) {\n              el.pageElements.forEach((pageEle, pageEleIndex) => {\n                pageEle.elements.forEach((ele, eleIndex) => {\n                  ele.idSuffix = '' + pageElementIndex + elementIndex + pageEleIndex + eleIndex + index;\n                });\n              });\n            }\n          });\n        });\n        (_a = content.helpCards) === null || _a === void 0 ? void 0 : _a.forEach((helpCard, helpIndex) => {\n          helpCard.idSuffix = '' + helpIndex + index;\n        });\n      }\n    }\n\n    initializeServices(journey) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (journey.parsedLandingAndOverviewContent.service) {\n          const service = this.injector.get(injectionTokenMap[journey.parsedLandingAndOverviewContent.service]);\n          yield service.initialize(journey);\n          this.journeyServiceMap[journey.journeyID] = service;\n        }\n      });\n    }\n\n    getJourneyStatus(steps) {\n      let status = Status.notStarted;\n      const isInProgress = steps === null || steps === void 0 ? void 0 : steps.some(step => !!step.status);\n      const isCompleted = steps === null || steps === void 0 ? void 0 : steps.every(step => step.status === Status.completed);\n\n      if (isCompleted) {\n        status = Status.completed;\n      } else if (isInProgress) {\n        status = Status.inProgress;\n      }\n\n      return status;\n    }\n\n    getSelectedTab$() {\n      return this.selectedTab$;\n    }\n\n    publishSelectedTab(selectedTab) {\n      this.selectedTab$.next(selectedTab);\n    }\n\n    isValueEmpty(value) {\n      if (typeof value === 'string') {\n        return !value || value === '$';\n      } else {\n        return !value && value !== 0;\n      }\n    }\n\n    fetchTabs(tabsLink, queryParam) {\n      const tabs = [];\n\n      for (const link of tabsLink) {\n        tabs.push({\n          label: this.content.tabHeader[link + 'Label'],\n          link: queryParam ? link + queryParam : link\n        });\n      }\n\n      return tabs;\n    }\n\n    addDollar(value, element) {\n      return element.validationRules.type === ValidationType.dollar ? '$' + value : value;\n    }\n\n    removeDollar(value, element) {\n      return element.validationRules.type === ValidationType.dollar && (value === null || value === void 0 ? void 0 : value.includes('$')) ? value.slice(1) : value;\n    }\n\n    isComingSoon(journey) {\n      let comingSoon = false;\n      const isWeb = this.utilityService.getIsWeb();\n\n      if (journey.parsedLandingAndOverviewContent && journey.comingSoonContent) {\n        if (isWeb) {\n          comingSoon = true;\n        }\n      } else if (journey.comingSoonContent) {\n        comingSoon = true;\n      }\n\n      return comingSoon;\n    }\n\n    setJourneyBackButton(link) {\n      this.journeyBackButton = link;\n      localStorage.setItem('journeyBackButton', link);\n    }\n\n    getJourneyBackButton() {\n      const localStorageLink = localStorage.getItem('journeyBackButton');\n      return localStorageLink && localStorageLink !== 'undefined' ? localStorageLink : this.journeyBackButton;\n    }\n\n    getJourneyCompletionStatus() {\n      return this.baseService.get(this.endpoints.completionStatus);\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n\n    setAddAccount(flag) {\n      this.journeyAddAccount = flag;\n      localStorage.setItem('addAccount', flag);\n    }\n\n    getAddAccount() {\n      const localStorageFlag = localStorage.getItem('addAccount');\n      return localStorageFlag && localStorageFlag !== 'undefined' ? localStorageFlag : this.journeyAddAccount;\n    }\n\n    setRefreshMxAccount(flag) {\n      this.journeyRefreshMxAccount = flag;\n      localStorage.setItem('refreshFlag', flag);\n    }\n\n    getRefreshMxAccount() {\n      const localStorageFlag = localStorage.getItem('refreshFlag');\n      return localStorageFlag && localStorageFlag !== 'undefined' ? localStorageFlag : this.journeyRefreshMxAccount;\n    }\n\n    removeContent(step) {\n      const deletedContentStep = JSON.parse(JSON.stringify(step));\n      delete deletedContentStep.content;\n      return deletedContentStep;\n    }\n\n    publishLeaveJourney() {\n      this.leaveJourneyPublisher.publish(undefined);\n    }\n\n    getAnswerList(journey) {\n      const answerList = [];\n      journey.steps.forEach(step => {\n        answerList.push(step.answer);\n      });\n      return answerList;\n    }\n\n  }\n\n  JourneyService.ɵfac = function JourneyService_Factory(t) {\n    return new (t || JourneyService)(i0.ɵɵinject(i1.BaseService), i0.ɵɵinject(i2.SharedUtilityService), i0.ɵɵinject(i3.ModalController), i0.ɵɵinject(i4.InAppBroserService), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i5.PreviewAnyFile), i0.ɵɵinject(i6.EventManagerService));\n  };\n\n  JourneyService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: JourneyService,\n    factory: JourneyService.ɵfac,\n    providedIn: 'root'\n  });\n  return JourneyService;\n})();","map":null,"metadata":{},"sourceType":"module"}