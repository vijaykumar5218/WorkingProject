{"ast":null,"code":"/*\n Highcharts JS v10.2.1 (2022-08-29)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (e) {\n  \"object\" === typeof module && module.exports ? (e[\"default\"] = e, module.exports = e) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (A) {\n    e(A);\n    e.Highcharts = A;\n    return e;\n  }) : e(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (e) {\n  function A(a, b, f, c) {\n    a.hasOwnProperty(b) || (a[b] = c.apply(null, f), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: b,\n        module: a[b]\n      }\n    })));\n  }\n\n  e = e ? e._modules : {};\n  A(e, \"Extensions/Pane.js\", [e[\"Core/Chart/Chart.js\"], e[\"Series/CenteredUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Pointer.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c, p) {\n    function e(g, d, k) {\n      return Math.sqrt(Math.pow(g - k[0], 2) + Math.pow(d - k[1], 2)) <= k[2] / 2;\n    }\n\n    var m = p.addEvent,\n        t = p.extend,\n        q = p.merge,\n        D = p.pick,\n        v = p.splat;\n    a.prototype.collectionsWithUpdate.push(\"pane\");\n\n    p = function () {\n      function g(d, k) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(d, k);\n      }\n\n      g.prototype.init = function (d, k) {\n        this.chart = k;\n        this.background = [];\n        k.pane.push(this);\n        this.setOptions(d);\n      };\n\n      g.prototype.setOptions = function (d) {\n        this.options = q(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, d);\n      };\n\n      g.prototype.render = function () {\n        var d = this.options,\n            k = this.options.background,\n            n = this.chart.renderer;\n        this.group || (this.group = n.g(\"pane-group\").attr({\n          zIndex: d.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (k) for (k = v(k), d = Math.max(k.length, this.background.length || 0), n = 0; n < d; n++) k[n] && this.axis ? this.renderBackground(q(this.defaultBackgroundOptions, k[n]), n) : this.background[n] && (this.background[n] = this.background[n].destroy(), this.background.splice(n, 1));\n      };\n\n      g.prototype.renderBackground = function (d, k) {\n        var n = \"animate\",\n            h = {\n          \"class\": \"highcharts-pane \" + (d.className || \"\")\n        };\n        this.chart.styledMode || t(h, {\n          fill: d.backgroundColor,\n          stroke: d.borderColor,\n          \"stroke-width\": d.borderWidth\n        });\n        this.background[k] || (this.background[k] = this.chart.renderer.path().add(this.group), n = \"attr\");\n        this.background[k][n]({\n          d: this.axis.getPlotBandPath(d.from, d.to, d)\n        }).attr(h);\n      };\n\n      g.prototype.updateCenter = function (d) {\n        this.center = (d || this.axis || {}).center = b.getCenter.call(this);\n      };\n\n      g.prototype.update = function (d, k) {\n        q(!0, this.options, d);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (d) {\n          d.pane === this && (d.pane = null, d.update({}, k));\n        }, this);\n      };\n\n      return g;\n    }();\n\n    a.prototype.getHoverPane = function (g) {\n      var d = this,\n          k;\n      g && d.pane.forEach(function (n) {\n        var h = g.chartX - d.plotLeft,\n            c = g.chartY - d.plotTop;\n        e(d.inverted ? c : h, d.inverted ? h : c, n.center) && (k = n);\n      });\n      return k;\n    };\n\n    m(a, \"afterIsInsidePlot\", function (g) {\n      this.polar && (g.isInsidePlot = this.pane.some(function (d) {\n        return e(g.x, g.y, d.center);\n      }));\n    });\n    m(c, \"beforeGetHoverData\", function (g) {\n      var d = this.chart;\n      d.polar ? (d.hoverPane = d.getHoverPane(g), g.filter = function (k) {\n        return k.visible && !(!g.shared && k.directTouch) && D(k.options.enableMouseTracking, !0) && (!d.hoverPane || k.xAxis.pane === d.hoverPane);\n      }) : d.hoverPane = void 0;\n    });\n    m(c, \"afterGetHoverData\", function (g) {\n      var d = this.chart;\n      g.hoverPoint && g.hoverPoint.plotX && g.hoverPoint.plotY && d.hoverPane && !e(g.hoverPoint.plotX, g.hoverPoint.plotY, d.hoverPane.center) && (g.hoverPoint = void 0);\n    });\n    f.Pane = p;\n    return f.Pane;\n  });\n  A(e, \"Series/AreaRange/AreaRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b) {\n    var f = this && this.__extends || function () {\n      var c = function (b, a) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, b) {\n          c.__proto__ = b;\n        } || function (c, b) {\n          for (var g in b) b.hasOwnProperty(g) && (c[g] = b[g]);\n        };\n\n        return c(b, a);\n      };\n\n      return function (b, a) {\n        function f() {\n          this.constructor = b;\n        }\n\n        c(b, a);\n        b.prototype = null === a ? Object.create(a) : (f.prototype = a.prototype, new f());\n      };\n    }();\n\n    a = a.seriesTypes.area.prototype;\n    var c = a.pointClass.prototype,\n        p = b.defined,\n        e = b.isNumber;\n    return function (b) {\n      function a() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.high = void 0;\n        c.low = void 0;\n        c.options = void 0;\n        c.plotHigh = void 0;\n        c.plotLow = void 0;\n        c.plotHighX = void 0;\n        c.plotLowX = void 0;\n        c.plotX = void 0;\n        c.series = void 0;\n        return c;\n      }\n\n      f(a, b);\n\n      a.prototype.setState = function () {\n        var b = this.state,\n            a = this.series,\n            f = a.chart.polar;\n        p(this.plotHigh) || (this.plotHigh = a.yAxis.toPixels(this.high, !0));\n        p(this.plotLow) || (this.plotLow = this.plotY = a.yAxis.toPixels(this.low, !0));\n        a.stateMarkerGraphic && (a.lowerStateMarkerGraphic = a.stateMarkerGraphic, a.stateMarkerGraphic = a.upperStateMarkerGraphic);\n        this.graphic = this.upperGraphic;\n        this.plotY = this.plotHigh;\n        f && (this.plotX = this.plotHighX);\n        c.setState.apply(this, arguments);\n        this.state = b;\n        this.plotY = this.plotLow;\n        this.graphic = this.lowerGraphic;\n        f && (this.plotX = this.plotLowX);\n        a.stateMarkerGraphic && (a.upperStateMarkerGraphic = a.stateMarkerGraphic, a.stateMarkerGraphic = a.lowerStateMarkerGraphic, a.lowerStateMarkerGraphic = void 0);\n        c.setState.apply(this, arguments);\n      };\n\n      a.prototype.haloPath = function () {\n        var a = this.series.chart.polar,\n            b = [];\n        this.plotY = this.plotLow;\n        a && (this.plotX = this.plotLowX);\n        this.isInside && (b = c.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        a && (this.plotX = this.plotHighX);\n        this.isTopInside && (b = b.concat(c.haloPath.apply(this, arguments)));\n        return b;\n      };\n\n      a.prototype.isValid = function () {\n        return e(this.low) && e(this.high);\n      };\n\n      return a;\n    }(a.pointClass);\n  });\n  A(e, \"Series/AreaRange/AreaRangeSeries.js\", [e[\"Series/AreaRange/AreaRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var p = this && this.__extends || function () {\n      var d = function (k, n) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, k) {\n          d.__proto__ = k;\n        } || function (d, k) {\n          for (var n in k) k.hasOwnProperty(n) && (d[n] = k[n]);\n        };\n\n        return d(k, n);\n      };\n\n      return function (k, n) {\n        function h() {\n          this.constructor = k;\n        }\n\n        d(k, n);\n        k.prototype = null === n ? Object.create(n) : (h.prototype = n.prototype, new h());\n      };\n    }();\n\n    b = b.noop;\n    var e = f.seriesTypes,\n        m = e.area,\n        t = e.area.prototype,\n        q = e.column.prototype,\n        D = c.defined,\n        v = c.extend,\n        g = c.isArray,\n        d = c.pick,\n        k = c.merge,\n        n = {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    };\n\n    c = function (h) {\n      function c() {\n        var d = null !== h && h.apply(this, arguments) || this;\n        d.data = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        d.lowerStateMarkerGraphic = void 0;\n        d.xAxis = void 0;\n        return d;\n      }\n\n      p(c, h);\n\n      c.prototype.toYData = function (d) {\n        return [d.low, d.high];\n      };\n\n      c.prototype.highToXY = function (d) {\n        var k = this.chart,\n            n = this.xAxis.postTranslate(d.rectPlotX || 0, this.yAxis.len - d.plotHigh);\n        d.plotHighX = n.x - k.plotLeft;\n        d.plotHigh = n.y - k.plotTop;\n        d.plotLowX = d.plotX;\n      };\n\n      c.prototype.translate = function () {\n        var d = this;\n        t.translate.apply(d);\n        d.points.forEach(function (k, n) {\n          var h = k.high,\n              c = k.plotY;\n          k.isNull ? k.plotY = null : (n = d.chart.hasParallelCoordinates ? d.chart.yAxis[n] : d.yAxis, k.plotLow = c, k.plotHigh = n.translate(d.dataModify ? d.dataModify.modifyValue(h) : h, 0, 1, 0, 1), d.dataModify && (k.yBottom = k.plotHigh));\n        });\n        this.chart.polar && this.points.forEach(function (k) {\n          d.highToXY(k);\n          k.tooltipPos = [(k.plotHighX + k.plotLowX) / 2, (k.plotHigh + k.plotLow) / 2];\n        });\n      };\n\n      c.prototype.getGraphPath = function (k) {\n        var n = [],\n            h = [],\n            c = t.getGraphPath,\n            a = this.options,\n            b = this.chart.polar,\n            g = b && !1 !== a.connectEnds,\n            w = a.connectNulls,\n            B,\n            C = a.step;\n        k = k || this.points;\n\n        for (B = k.length; B--;) {\n          var x = k[B];\n          var f = b ? {\n            plotX: x.rectPlotX,\n            plotY: x.yBottom,\n            doCurve: !1\n          } : {\n            plotX: x.plotX,\n            plotY: x.plotY,\n            doCurve: !1\n          };\n          x.isNull || g || w || k[B + 1] && !k[B + 1].isNull || h.push(f);\n          var r = {\n            polarPlotY: x.polarPlotY,\n            rectPlotX: x.rectPlotX,\n            yBottom: x.yBottom,\n            plotX: d(x.plotHighX, x.plotX),\n            plotY: x.plotHigh,\n            isNull: x.isNull\n          };\n          h.push(r);\n          n.push(r);\n          x.isNull || g || w || k[B - 1] && !k[B - 1].isNull || h.push(f);\n        }\n\n        k = c.call(this, k);\n        C && (!0 === C && (C = \"left\"), a.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[C]);\n        n = c.call(this, n);\n        h = c.call(this, h);\n        a.step = C;\n        a = [].concat(k, n);\n        !this.chart.polar && h[0] && \"M\" === h[0][0] && (h[0] = [\"L\", h[0][1], h[0][2]]);\n        this.graphPath = a;\n        this.areaPath = k.concat(h);\n        a.isArea = !0;\n        a.xMap = k.xMap;\n        this.areaPath.xMap = k.xMap;\n        return a;\n      };\n\n      c.prototype.drawDataLabels = function () {\n        var d = this.points,\n            k = d.length,\n            n = [],\n            h = this.options.dataLabels,\n            c = this.chart.inverted,\n            a,\n            b;\n\n        if (h) {\n          if (g(h)) {\n            var w = h[0] || {\n              enabled: !1\n            };\n            var B = h[1] || {\n              enabled: !1\n            };\n          } else w = v({}, h), w.x = h.xHigh, w.y = h.yHigh, B = v({}, h), B.x = h.xLow, B.y = h.yLow;\n\n          if (w.enabled || this._hasPointLabels) {\n            for (a = k; a--;) if (b = d[a]) {\n              var f = w.inside ? b.plotHigh < b.plotLow : b.plotHigh > b.plotLow;\n              b.y = b.high;\n              b._plotY = b.plotY;\n              b.plotY = b.plotHigh;\n              n[a] = b.dataLabel;\n              b.dataLabel = b.dataLabelUpper;\n              b.below = f;\n              c ? w.align || (w.align = f ? \"right\" : \"left\") : w.verticalAlign || (w.verticalAlign = f ? \"top\" : \"bottom\");\n            }\n\n            this.options.dataLabels = w;\n            t.drawDataLabels && t.drawDataLabels.apply(this, arguments);\n\n            for (a = k; a--;) if (b = d[a]) b.dataLabelUpper = b.dataLabel, b.dataLabel = n[a], delete b.dataLabels, b.y = b.low, b.plotY = b._plotY;\n          }\n\n          if (B.enabled || this._hasPointLabels) {\n            for (a = k; a--;) if (b = d[a]) f = B.inside ? b.plotHigh < b.plotLow : b.plotHigh > b.plotLow, b.below = !f, c ? B.align || (B.align = f ? \"left\" : \"right\") : B.verticalAlign || (B.verticalAlign = f ? \"bottom\" : \"top\");\n\n            this.options.dataLabels = B;\n            t.drawDataLabels && t.drawDataLabels.apply(this, arguments);\n          }\n\n          if (w.enabled) for (a = k; a--;) if (b = d[a]) b.dataLabels = [b.dataLabelUpper, b.dataLabel].filter(function (d) {\n            return !!d;\n          });\n          this.options.dataLabels = h;\n        }\n      };\n\n      c.prototype.alignDataLabel = function () {\n        q.alignDataLabel.apply(this, arguments);\n      };\n\n      c.prototype.drawPoints = function () {\n        var k = this.points.length,\n            n;\n        t.drawPoints.apply(this, arguments);\n\n        for (n = 0; n < k;) {\n          var h = this.points[n];\n          h.origProps = {\n            plotY: h.plotY,\n            plotX: h.plotX,\n            isInside: h.isInside,\n            negative: h.negative,\n            zone: h.zone,\n            y: h.y\n          };\n          h.lowerGraphic = h.graphic;\n          h.graphic = h.upperGraphic;\n          h.plotY = h.plotHigh;\n          D(h.plotHighX) && (h.plotX = h.plotHighX);\n          h.y = d(h.high, h.origProps.y);\n          h.negative = h.y < (this.options.threshold || 0);\n          this.zones.length && (h.zone = h.getZone());\n          this.chart.polar || (h.isInside = h.isTopInside = \"undefined\" !== typeof h.plotY && 0 <= h.plotY && h.plotY <= this.yAxis.len && 0 <= h.plotX && h.plotX <= this.xAxis.len);\n          n++;\n        }\n\n        t.drawPoints.apply(this, arguments);\n\n        for (n = 0; n < k;) h = this.points[n], h.upperGraphic = h.graphic, h.graphic = h.lowerGraphic, h.origProps && (v(h, h.origProps), delete h.origProps), n++;\n      };\n\n      c.defaultOptions = k(m.defaultOptions, n);\n      return c;\n    }(m);\n\n    v(c.prototype, {\n      deferTranslatePolar: !0,\n      pointArrayMap: [\"low\", \"high\"],\n      pointClass: a,\n      pointValKey: \"low\",\n      setStackedPoints: b\n    });\n    f.registerSeriesType(\"arearange\", c);\n    \"\";\n    return c;\n  });\n  A(e, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [e[\"Series/AreaRange/AreaRangeSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f) {\n    var c = this && this.__extends || function () {\n      var b = function (a, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) a.hasOwnProperty(d) && (b[d] = a[d]);\n        };\n\n        return b(a, c);\n      };\n\n      return function (a, c) {\n        function f() {\n          this.constructor = a;\n        }\n\n        b(a, c);\n        a.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        p = b.seriesTypes.spline.prototype,\n        e = f.merge;\n\n    f = f.extend;\n\n    var m = function (b) {\n      function f() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.data = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      c(f, b);\n      f.defaultOptions = e(a.defaultOptions);\n      return f;\n    }(a);\n\n    f(m.prototype, {\n      getPointSpline: p.getPointSpline\n    });\n    b.registerSeriesType(\"areasplinerange\", m);\n    \"\";\n    return m;\n  });\n  A(e, \"Series/BoxPlot/BoxPlotSeries.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var p = this && this.__extends || function () {\n      var b = function (a, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var k in d) d.hasOwnProperty(k) && (b[k] = d[k]);\n        };\n\n        return b(a, c);\n      };\n\n      return function (a, c) {\n        function f() {\n          this.constructor = a;\n        }\n\n        b(a, c);\n        a.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    b = b.noop;\n    var e = c.extend,\n        m = c.merge,\n        t = c.pick;\n\n    c = function (b) {\n      function c() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      p(c, b);\n\n      c.prototype.pointAttribs = function () {\n        return {};\n      };\n\n      c.prototype.translate = function () {\n        var a = this.yAxis,\n            c = this.pointArrayMap;\n        b.prototype.translate.apply(this);\n        this.points.forEach(function (d) {\n          c.forEach(function (k) {\n            null !== d[k] && (d[k + \"Plot\"] = a.translate(d[k], 0, 1, 0, 1));\n          });\n          d.plotHigh = d.highPlot;\n        });\n      };\n\n      c.prototype.drawPoints = function () {\n        var b = this,\n            a = b.options,\n            d = b.chart,\n            k = d.renderer,\n            n,\n            h,\n            c,\n            f,\n            p,\n            e,\n            E = 0,\n            m,\n            F,\n            K,\n            w,\n            B = !1 !== b.doQuartiles,\n            C,\n            x = b.options.whiskerLength;\n        b.points.forEach(function (g) {\n          var r = g.graphic,\n              u = r ? \"animate\" : \"attr\",\n              z = g.shapeArgs,\n              J = {},\n              G = {},\n              L = {},\n              H = {},\n              I = g.color || b.color;\n          \"undefined\" !== typeof g.plotY && (m = Math.round(z.width), F = Math.floor(z.x), K = F + m, w = Math.round(m / 2), n = Math.floor(B ? g.q1Plot : g.lowPlot), h = Math.floor(B ? g.q3Plot : g.lowPlot), c = Math.floor(g.highPlot), f = Math.floor(g.lowPlot), r || (g.graphic = r = k.g(\"point\").add(b.group), g.stem = k.path().addClass(\"highcharts-boxplot-stem\").add(r), x && (g.whiskers = k.path().addClass(\"highcharts-boxplot-whisker\").add(r)), B && (g.box = k.path(void 0).addClass(\"highcharts-boxplot-box\").add(r)), g.medianShape = k.path(void 0).addClass(\"highcharts-boxplot-median\").add(r)), d.styledMode || (G.stroke = g.stemColor || a.stemColor || I, G[\"stroke-width\"] = t(g.stemWidth, a.stemWidth, a.lineWidth), G.dashstyle = g.stemDashStyle || a.stemDashStyle || a.dashStyle, g.stem.attr(G), x && (L.stroke = g.whiskerColor || a.whiskerColor || I, L[\"stroke-width\"] = t(g.whiskerWidth, a.whiskerWidth, a.lineWidth), L.dashstyle = g.whiskerDashStyle || a.whiskerDashStyle || a.dashStyle, g.whiskers.attr(L)), B && (J.fill = g.fillColor || a.fillColor || I, J.stroke = a.lineColor || I, J[\"stroke-width\"] = a.lineWidth || 0, J.dashstyle = g.boxDashStyle || a.boxDashStyle || a.dashStyle, g.box.attr(J)), H.stroke = g.medianColor || a.medianColor || I, H[\"stroke-width\"] = t(g.medianWidth, a.medianWidth, a.lineWidth), H.dashstyle = g.medianDashStyle || a.medianDashStyle || a.dashStyle, g.medianShape.attr(H)), e = g.stem.strokeWidth() % 2 / 2, E = F + w + e, r = [[\"M\", E, h], [\"L\", E, c], [\"M\", E, n], [\"L\", E, f]], g.stem[u]({\n            d: r\n          }), B && (e = g.box.strokeWidth() % 2 / 2, n = Math.floor(n) + e, h = Math.floor(h) + e, F += e, K += e, r = [[\"M\", F, h], [\"L\", F, n], [\"L\", K, n], [\"L\", K, h], [\"L\", F, h], [\"Z\"]], g.box[u]({\n            d: r\n          })), x && (e = g.whiskers.strokeWidth() % 2 / 2, c += e, f += e, C = /%$/.test(x) ? w * parseFloat(x) / 100 : x / 2, r = [[\"M\", E - C, c], [\"L\", E + C, c], [\"M\", E - C, f], [\"L\", E + C, f]], g.whiskers[u]({\n            d: r\n          })), p = Math.round(g.medianPlot), e = g.medianShape.strokeWidth() % 2 / 2, p += e, r = [[\"M\", F, p], [\"L\", K, p]], g.medianShape[u]({\n            d: r\n          }));\n        });\n      };\n\n      c.prototype.toYData = function (a) {\n        return [a.low, a.q1, a.median, a.q3, a.high];\n      };\n\n      c.defaultOptions = m(a.defaultOptions, {\n        threshold: null,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n        },\n        whiskerLength: \"50%\",\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        medianWidth: 2,\n        whiskerWidth: 2\n      });\n      return c;\n    }(a);\n\n    e(c.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: b,\n      setStackedPoints: b\n    });\n    f.registerSeriesType(\"boxplot\", c);\n    \"\";\n    return c;\n  });\n  A(e, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"10px\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  });\n  A(e, \"Series/Bubble/BubbleLegendItem.js\", [e[\"Core/Color/Color.js\"], e[\"Core/FormatUtilities.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var e = a.parse,\n        l = f.noop,\n        m = c.arrayMax,\n        t = c.arrayMin,\n        q = c.isNumber,\n        D = c.merge,\n        v = c.pick,\n        g = c.stableSort;\n\n    a = function () {\n      function d(d, a) {\n        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = l;\n        this.init(d, a);\n      }\n\n      d.prototype.init = function (d, a) {\n        this.options = d;\n        this.visible = !0;\n        this.chart = a.chart;\n        this.legend = a;\n      };\n\n      d.prototype.addToLegend = function (d) {\n        d.splice(this.options.legendIndex, 0, this);\n      };\n\n      d.prototype.drawLegendSymbol = function (d) {\n        var a = this.chart,\n            h = this.options,\n            k = v(d.options.itemDistance, 20),\n            b = h.ranges,\n            c = h.connectorDistance;\n        this.fontMetrics = a.renderer.fontMetrics(h.labels.style.fontSize);\n        b && b.length && q(b[0].value) ? (g(b, function (d, a) {\n          return a.value - d.value;\n        }), this.ranges = b, this.setOptions(), this.render(), d = this.getMaxLabelSize(), b = this.ranges[0].radius, a = 2 * b, c = c - b + d.width, c = 0 < c ? c : 0, this.maxLabel = d, this.movementX = \"left\" === h.labels.align ? c : 0, this.legendItemWidth = a + c + k, this.legendItemHeight = a + this.fontMetrics.h / 2) : d.options.bubbleLegend.autoRanges = !0;\n      };\n\n      d.prototype.setOptions = function () {\n        var d = this.ranges,\n            a = this.options,\n            h = this.chart.series[a.seriesIndex],\n            b = this.legend.baseline,\n            c = {\n          zIndex: a.zIndex,\n          \"stroke-width\": a.borderWidth\n        },\n            g = {\n          zIndex: a.zIndex,\n          \"stroke-width\": a.connectorWidth\n        },\n            f = {\n          align: this.legend.options.rtl || \"left\" === a.labels.align ? \"right\" : \"left\",\n          zIndex: a.zIndex\n        },\n            p = h.options.marker.fillOpacity,\n            m = this.chart.styledMode;\n        d.forEach(function (k, n) {\n          m || (c.stroke = v(k.borderColor, a.borderColor, h.color), c.fill = v(k.color, a.color, 1 !== p ? e(h.color).setOpacity(p).get(\"rgba\") : h.color), g.stroke = v(k.connectorColor, a.connectorColor, h.color));\n          d[n].radius = this.getRangeRadius(k.value);\n          d[n] = D(d[n], {\n            center: d[0].radius - d[n].radius + b\n          });\n          m || D(!0, d[n], {\n            bubbleAttribs: D(c),\n            connectorAttribs: D(g),\n            labelAttribs: f\n          });\n        }, this);\n      };\n\n      d.prototype.getRangeRadius = function (d) {\n        var a = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, a.ranges[a.ranges.length - 1].value, a.ranges[0].value, a.minSize, a.maxSize, d);\n      };\n\n      d.prototype.render = function () {\n        var d = this.chart.renderer,\n            a = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = d.g(\"bubble-legend\");\n        this.legendItem = d.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (d) {\n          d.value >= a && this.renderRange(d);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      };\n\n      d.prototype.renderRange = function (d) {\n        var a = this.options,\n            h = a.labels,\n            b = this.chart,\n            k = b.series[a.seriesIndex],\n            c = b.renderer,\n            g = this.symbols;\n        b = g.labels;\n        var f = d.center,\n            e = Math.abs(d.radius),\n            p = a.connectorDistance || 0,\n            m = h.align,\n            w = a.connectorWidth,\n            B = this.ranges[0].radius || 0,\n            C = f - e - a.borderWidth / 2 + w / 2,\n            x = this.fontMetrics;\n        x = x.f / 2 - (x.h - x.f) / 2;\n        var l = c.styledMode;\n        p = this.legend.options.rtl || \"left\" === m ? -p : p;\n        \"center\" === m && (p = 0, a.connectorDistance = 0, d.labelAttribs.align = \"center\");\n        m = C + a.labels.y;\n        var r = B + p + a.labels.x;\n        g.bubbleItems.push(c.circle(B, f + ((C % 1 ? 1 : .5) - (w % 2 ? 0 : .5)), e).attr(l ? {} : d.bubbleAttribs).addClass((l ? \"highcharts-color-\" + k.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (a.className || \"\")).add(this.legendSymbol));\n        g.connectors.push(c.path(c.crispLine([[\"M\", B, C], [\"L\", B + p, C]], a.connectorWidth)).attr(l ? {} : d.connectorAttribs).addClass((l ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (a.connectorClassName || \"\")).add(this.legendSymbol));\n        d = c.text(this.formatLabel(d), r, m + x).attr(l ? {} : d.labelAttribs).css(l ? {} : h.style).addClass(\"highcharts-bubble-legend-labels \" + (a.labels.className || \"\")).add(this.legendSymbol);\n        b.push(d);\n        d.placed = !0;\n        d.alignAttr = {\n          x: r,\n          y: m + x\n        };\n      };\n\n      d.prototype.getMaxLabelSize = function () {\n        var d, a;\n        this.symbols.labels.forEach(function (h) {\n          a = h.getBBox(!0);\n          d = d ? a.width > d.width ? a : d : a;\n        });\n        return d || {};\n      };\n\n      d.prototype.formatLabel = function (d) {\n        var a = this.options,\n            h = a.labels.formatter;\n        a = a.labels.format;\n        var c = this.chart.numberFormatter;\n        return a ? b.format(a, d) : h ? h.call(d) : c(d.value, 1);\n      };\n\n      d.prototype.hideOverlappingLabels = function () {\n        var d = this.chart,\n            a = this.symbols;\n        !this.options.labels.allowOverlap && a && (d.hideOverlappingLabels(a.labels), a.labels.forEach(function (d, b) {\n          d.newOpacity ? d.newOpacity !== d.oldOpacity && a.connectors[b].show() : a.connectors[b].hide();\n        }));\n      };\n\n      d.prototype.getRanges = function () {\n        var d = this.legend.bubbleLegend,\n            a = d.options.ranges,\n            b,\n            c = Number.MAX_VALUE,\n            g = -Number.MAX_VALUE;\n        d.chart.series.forEach(function (d) {\n          d.isBubble && !d.ignoreSeries && (b = d.zData.filter(q), b.length && (c = v(d.options.zMin, Math.min(c, Math.max(t(b), !1 === d.options.displayNegative ? d.options.zThreshold : -Number.MAX_VALUE))), g = v(d.options.zMax, Math.max(g, m(b)))));\n        });\n        var f = c === g ? [{\n          value: g\n        }] : [{\n          value: c\n        }, {\n          value: (c + g) / 2\n        }, {\n          value: g,\n          autoRanges: !0\n        }];\n        a.length && a[0].radius && f.reverse();\n        f.forEach(function (d, b) {\n          a && a[b] && (f[b] = D(a[b], d));\n        });\n        return f;\n      };\n\n      d.prototype.predictBubbleSizes = function () {\n        var d = this.chart,\n            a = this.fontMetrics,\n            b = d.legend.options,\n            c = b.floating,\n            g = (b = \"horizontal\" === b.layout) ? d.legend.lastLineHeight : 0,\n            f = d.plotSizeX,\n            p = d.plotSizeY,\n            e = d.series[this.options.seriesIndex],\n            m = e.getPxExtremes();\n        d = Math.ceil(m.minPxSize);\n        m = Math.ceil(m.maxPxSize);\n        var F = Math.min(p, f);\n        e = e.options.maxSize;\n        if (c || !/%$/.test(e)) a = m;else if (e = parseFloat(e), a = (F + g - a.h / 2) * e / 100 / (e / 100 + 1), b && p - a >= f || !b && f - a >= p) a = m;\n        return [d, Math.ceil(a)];\n      };\n\n      d.prototype.updateRanges = function (d, a) {\n        var b = this.legend.options.bubbleLegend;\n        b.minSize = d;\n        b.maxSize = a;\n        b.ranges = this.getRanges();\n      };\n\n      d.prototype.correctSizes = function () {\n        var d = this.legend,\n            a = this.chart.series[this.options.seriesIndex].getPxExtremes();\n        1 < Math.abs(Math.ceil(a.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, a.maxPxSize), d.render());\n      };\n\n      return d;\n    }();\n\n    \"\";\n    return a;\n  });\n  A(e, \"Series/Bubble/BubbleLegendComposition.js\", [e[\"Series/Bubble/BubbleLegendDefaults.js\"], e[\"Series/Bubble/BubbleLegendItem.js\"], e[\"Core/DefaultOptions.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    function e(a, b, c) {\n      var h = this.legend,\n          k = 0 <= l(this);\n\n      if (h && h.options.enabled && h.bubbleLegend && h.options.bubbleLegend.autoRanges && k) {\n        var g = h.bubbleLegend.options;\n        k = h.bubbleLegend.predictBubbleSizes();\n        h.bubbleLegend.updateRanges(k[0], k[1]);\n        g.placed || (h.group.placed = !1, h.allItems.forEach(function (d) {\n          d.legendGroup.translateY = null;\n        }));\n        h.render();\n        this.getMargins();\n        this.axes.forEach(function (a) {\n          a.visible && a.render();\n          g.placed || (a.setScale(), a.updateNames(), d(a.ticks, function (d) {\n            d.isNew = !0;\n            d.isNewLabel = !0;\n          }));\n        });\n        g.placed = !0;\n        this.getMargins();\n        a.call(this, b, c);\n        h.bubbleLegend.correctSizes();\n        D(h, m(h));\n      } else a.call(this, b, c), h && h.options.enabled && h.bubbleLegend && (h.render(), D(h, m(h)));\n    }\n\n    function l(d) {\n      d = d.series;\n\n      for (var a = 0; a < d.length;) {\n        if (d[a] && d[a].isBubble && d[a].visible && d[a].zData.length) return a;\n        a++;\n      }\n\n      return -1;\n    }\n\n    function m(d) {\n      d = d.allItems;\n      var a = [],\n          b = d.length,\n          c,\n          h = 0;\n\n      for (c = 0; c < b; c++) if (d[c].legendItemHeight && (d[c].itemHeight = d[c].legendItemHeight), d[c] === d[b - 1] || d[c + 1] && d[c]._legendItemPos[1] !== d[c + 1]._legendItemPos[1]) {\n        a.push({\n          height: 0\n        });\n        var k = a[a.length - 1];\n\n        for (h; h <= c; h++) d[h].itemHeight > k.height && (k.height = d[h].itemHeight);\n\n        k.step = c;\n      }\n\n      return a;\n    }\n\n    function t(d) {\n      var a = this.bubbleLegend,\n          c = this.options,\n          h = c.bubbleLegend,\n          k = l(this.chart);\n      a && a.ranges && a.ranges.length && (h.ranges.length && (h.autoRanges = !!h.ranges[0].autoRanges), this.destroyItem(a));\n      0 <= k && c.enabled && h.enabled && (h.seriesIndex = k, this.bubbleLegend = new b(h, this), this.bubbleLegend.addToLegend(d.allItems));\n    }\n\n    function q() {\n      var d = this.chart,\n          a = this.visible,\n          b = this.chart.legend;\n      b && b.bubbleLegend && (this.visible = !a, this.ignoreSeries = a, d = 0 <= l(d), b.bubbleLegend.visible !== d && (b.update({\n        bubbleLegend: {\n          enabled: d\n        }\n      }), b.bubbleLegend.visible = d), this.visible = a);\n    }\n\n    function D(d, a) {\n      var b = d.options.rtl,\n          c,\n          h,\n          k,\n          g = 0;\n      d.allItems.forEach(function (d, f) {\n        c = d.legendGroup.translateX;\n        h = d._legendItemPos[1];\n        if ((k = d.movementX) || b && d.ranges) k = b ? c - d.options.maxSize / 2 : c + k, d.legendGroup.attr({\n          translateX: k\n        });\n        f > a[g].step && g++;\n        d.legendGroup.attr({\n          translateY: Math.round(h + a[g].height / 2)\n        });\n        d._legendItemPos[1] = h + a[g].height / 2;\n      });\n    }\n\n    var v = f.setOptions,\n        g = c.addEvent,\n        d = c.objectEach,\n        k = c.wrap,\n        n = [];\n    return {\n      compose: function (d, b, c) {\n        -1 === n.indexOf(d) && (n.push(d), v({\n          legend: {\n            bubbleLegend: a\n          }\n        }), k(d.prototype, \"drawChartBox\", e));\n        -1 === n.indexOf(b) && (n.push(b), g(b, \"afterGetAllItems\", t));\n        -1 === n.indexOf(c) && (n.push(c), g(c, \"legendItemClick\", q));\n      }\n    };\n  });\n  A(e, \"Series/Bubble/BubblePoint.js\", [e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f) {\n    var c = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    f = f.extend;\n\n    b = function (b) {\n      function f() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      c(f, b);\n\n      f.prototype.haloPath = function (b) {\n        return a.prototype.haloPath.call(this, 0 === b ? 0 : (this.marker ? this.marker.radius || 0 : 0) + b);\n      };\n\n      return f;\n    }(b.seriesTypes.scatter.prototype.pointClass);\n\n    f(b.prototype, {\n      ttBelow: !1\n    });\n    return b;\n  });\n  A(e, \"Series/Bubble/BubbleSeries.js\", [e[\"Series/Bubble/BubbleLegendComposition.js\"], e[\"Series/Bubble/BubblePoint.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c, e, l) {\n    function p() {\n      var d = this,\n          a = this.len,\n          b = this.chart,\n          c = this.isXAxis,\n          h = c ? \"xData\" : \"yData\",\n          k = this.min,\n          g = this.max - k,\n          f = 0,\n          n = a,\n          r = a / g,\n          u;\n      this.series.forEach(function (a) {\n        if (a.bubblePadding && (a.visible || !b.options.chart.ignoreHiddenSeries)) {\n          u = d.allowZoomOutside = !0;\n          var w = a[h];\n          c && ((a.onPoint || a).getRadii(0, 0, a), a.onPoint && (a.radii = a.onPoint.radii));\n          if (0 < g) for (var B = w.length; B--;) if (G(w[B]) && d.dataMin <= w[B] && w[B] <= d.max) {\n            var e = a.radii && a.radii[B] || 0;\n            f = Math.min((w[B] - k) * r - e, f);\n            n = Math.max((w[B] - k) * r + e, n);\n          }\n        }\n      });\n      u && 0 < g && !this.logarithmic && (n -= a, r *= (a + Math.max(0, f) - Math.min(n, a)) / a, [[\"min\", \"userMin\", f], [\"max\", \"userMax\", n]].forEach(function (a) {\n        \"undefined\" === typeof I(d.options[a[0]], d[a[1]]) && (d[a[0]] += a[2] / r);\n      }));\n    }\n\n    var t = this && this.__extends || function () {\n      var d = function (a, b) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, a) {\n          d.__proto__ = a;\n        } || function (d, a) {\n          for (var b in a) a.hasOwnProperty(b) && (d[b] = a[b]);\n        };\n\n        return d(a, b);\n      };\n\n      return function (a, b) {\n        function c() {\n          this.constructor = a;\n        }\n\n        d(a, b);\n        a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }(),\n        q = f.parse;\n\n    f = c.noop;\n    var D = e.series,\n        v = e.seriesTypes;\n    c = v.column.prototype;\n    var g = v.scatter;\n    v = l.addEvent;\n    var d = l.arrayMax,\n        k = l.arrayMin,\n        n = l.clamp,\n        h = l.extend,\n        G = l.isNumber,\n        L = l.merge,\n        I = l.pick,\n        H = [];\n\n    l = function (b) {\n      function c() {\n        var d = null !== b && b.apply(this, arguments) || this;\n        d.data = void 0;\n        d.maxPxSize = void 0;\n        d.minPxSize = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        d.radii = void 0;\n        d.yData = void 0;\n        d.zData = void 0;\n        return d;\n      }\n\n      t(c, b);\n\n      c.compose = function (d, b, c, h) {\n        a.compose(b, c, h);\n        -1 === H.indexOf(d) && (H.push(d), d.prototype.beforePadding = p);\n      };\n\n      c.prototype.animate = function (d) {\n        !d && this.points.length < this.options.animationLimit && this.points.forEach(function (d) {\n          var a = d.graphic;\n          a && a.width && (this.hasRendered || a.attr({\n            x: d.plotX,\n            y: d.plotY,\n            width: 1,\n            height: 1\n          }), a.animate(this.markerAttribs(d), this.options.animation));\n        }, this);\n      };\n\n      c.prototype.getRadii = function () {\n        var d = this,\n            a = this.zData,\n            b = this.yData,\n            c = [],\n            h = this.chart.bubbleZExtremes;\n        var k = this.getPxExtremes();\n        var g = k.minPxSize,\n            f = k.maxPxSize;\n\n        if (!h) {\n          var n = Number.MAX_VALUE,\n              e = -Number.MAX_VALUE,\n              p;\n          this.chart.series.forEach(function (a) {\n            a.bubblePadding && (a.visible || !d.chart.options.chart.ignoreHiddenSeries) && (a = (a.onPoint || a).getZExtremes()) && (n = Math.min(n || a.zMin, a.zMin), e = Math.max(e || a.zMax, a.zMax), p = !0);\n          });\n          p ? (h = {\n            zMin: n,\n            zMax: e\n          }, this.chart.bubbleZExtremes = h) : h = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n\n        var m = 0;\n\n        for (k = a.length; m < k; m++) {\n          var l = a[m];\n          c.push(this.getRadius(h.zMin, h.zMax, g, f, l, b && b[m]));\n        }\n\n        this.radii = c;\n      };\n\n      c.prototype.getRadius = function (d, a, b, c, h, k) {\n        var w = this.options,\n            g = \"width\" !== w.sizeBy,\n            f = w.zThreshold,\n            n = a - d,\n            e = .5;\n        if (null === k || null === h) return null;\n\n        if (G(h)) {\n          w.sizeByAbsoluteValue && (h = Math.abs(h - f), n = Math.max(a - f, Math.abs(d - f)), d = 0);\n          if (h < d) return b / 2 - 1;\n          0 < n && (e = (h - d) / n);\n        }\n\n        g && 0 <= e && (e = Math.sqrt(e));\n        return Math.ceil(b + e * (c - b)) / 2;\n      };\n\n      c.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      c.prototype.pointAttribs = function (d, a) {\n        var b = this.options.marker.fillOpacity;\n        d = D.prototype.pointAttribs.call(this, d, a);\n        1 !== b && (d.fill = q(d.fill).setOpacity(b).get(\"rgba\"));\n        return d;\n      };\n\n      c.prototype.translate = function () {\n        b.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n\n      c.prototype.translateBubble = function () {\n        for (var d = this.data, a = this.radii, b = this.getPxExtremes().minPxSize, c = d.length; c--;) {\n          var k = d[c],\n              g = a ? a[c] : 0;\n          G(g) && g >= b / 2 ? (k.marker = h(k.marker, {\n            radius: g,\n            width: 2 * g,\n            height: 2 * g\n          }), k.dlBox = {\n            x: k.plotX - g,\n            y: k.plotY - g,\n            width: 2 * g,\n            height: 2 * g\n          }) : (k.shapeArgs = k.dlBox = void 0, k.plotY = 0, k.marker = {\n            width: 0,\n            height: 0\n          });\n        }\n      };\n\n      c.prototype.getPxExtremes = function () {\n        var d = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n            a = function (a) {\n          if (\"string\" === typeof a) {\n            var b = /%$/.test(a);\n            a = parseInt(a, 10);\n          }\n\n          return b ? d * a / 100 : a;\n        },\n            b = a(I(this.options.minSize, 8));\n\n        a = Math.max(a(I(this.options.maxSize, \"20%\")), b);\n        return {\n          minPxSize: b,\n          maxPxSize: a\n        };\n      };\n\n      c.prototype.getZExtremes = function () {\n        var a = this.options,\n            b = (this.zData || []).filter(G);\n\n        if (b.length) {\n          var c = I(a.zMin, n(k(b), !1 === a.displayNegative ? a.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));\n          a = I(a.zMax, d(b));\n          if (G(c) && G(a)) return {\n            zMin: c,\n            zMax: a\n          };\n        }\n      };\n\n      c.defaultOptions = L(g.defaultOptions, {\n        dataLabels: {\n          formatter: function () {\n            var d = this.series.chart.numberFormatter,\n                a = this.point.z;\n            return G(a) ? d(a, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        animationLimit: 250,\n        marker: {\n          lineColor: null,\n          lineWidth: 1,\n          fillOpacity: .5,\n          radius: null,\n          states: {\n            hover: {\n              radiusPlus: 0\n            }\n          },\n          symbol: \"circle\"\n        },\n        minSize: 8,\n        maxSize: \"20%\",\n        softThreshold: !1,\n        states: {\n          hover: {\n            halo: {\n              size: 5\n            }\n          }\n        },\n        tooltip: {\n          pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: \"z\"\n      });\n      return c;\n    }(g);\n\n    h(l.prototype, {\n      alignDataLabel: c.alignDataLabel,\n      applyZones: f,\n      bubblePadding: !0,\n      buildKDTree: f,\n      directTouch: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: b,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    });\n    v(l, \"updatedData\", function (d) {\n      delete d.target.chart.bubbleZExtremes;\n    });\n    v(l, \"remove\", function (d) {\n      delete d.target.chart.bubbleZExtremes;\n    });\n    e.registerSeriesType(\"bubble\", l);\n    \"\";\n    \"\";\n    return l;\n  });\n  A(e, \"Series/ColumnRange/ColumnRangePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        c = a.seriesTypes;\n\n    a = c.column.prototype.pointClass.prototype;\n    var e = b.extend,\n        l = b.isNumber;\n\n    b = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n\n      f(b, a);\n\n      b.prototype.isValid = function () {\n        return l(this.low);\n      };\n\n      return b;\n    }(c.arearange.prototype.pointClass);\n\n    e(b.prototype, {\n      setState: a.setState\n    });\n    return b;\n  });\n  A(e, \"Series/ColumnRange/ColumnRangeSeries.js\", [e[\"Series/ColumnRange/ColumnRangePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var e = this && this.__extends || function () {\n      var d = function (a, b) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, a) {\n          d.__proto__ = a;\n        } || function (d, a) {\n          for (var b in a) a.hasOwnProperty(b) && (d[b] = a[b]);\n        };\n\n        return d(a, b);\n      };\n\n      return function (a, b) {\n        function c() {\n          this.constructor = a;\n        }\n\n        d(a, b);\n        a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    b = b.noop;\n    var l = f.seriesTypes,\n        m = l.arearange,\n        t = l.column,\n        q = l.column.prototype,\n        D = c.clamp;\n    l = c.extend;\n    var v = c.merge,\n        g = c.pick,\n        d = {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    };\n\n    c = function (a) {\n      function b() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      e(b, a);\n\n      b.prototype.setOptions = function () {\n        v(!0, arguments[0], {\n          stacking: void 0\n        });\n        return m.prototype.setOptions.apply(this, arguments);\n      };\n\n      b.prototype.translate = function () {\n        var d = this,\n            a = this.yAxis,\n            b = this.xAxis,\n            c = b.startAngleRad,\n            k = this.chart,\n            f = this.xAxis.isRadial,\n            n = Math.max(k.chartWidth, k.chartHeight) + 999,\n            e,\n            p,\n            w,\n            B,\n            C;\n        q.translate.apply(this);\n        this.points.forEach(function (h) {\n          var x = h.shapeArgs || {},\n              r = d.options.minPointLength;\n          h.plotHigh = B = D(a.translate(h.high, 0, 1, 0, 1), -n, n);\n          h.plotLow = D(h.plotY, -n, n);\n          C = B;\n          e = g(h.rectPlotY, h.plotY) - B;\n          Math.abs(e) < r ? (p = r - e, e += p, C -= p / 2) : 0 > e && (e *= -1, C -= e);\n          f && d.polar ? (w = h.barX + c, h.shapeType = \"arc\", h.shapeArgs = d.polar.arc(C + e, C, w, w + h.pointWidth)) : (x.height = e, x.y = C, r = x.x, r = void 0 === r ? 0 : r, x = x.width, x = void 0 === x ? 0 : x, h.tooltipPos = k.inverted ? [a.len + a.pos - k.plotLeft - C - e / 2, b.len + b.pos - k.plotTop - r - x / 2, e] : [b.left - k.plotLeft + r + x / 2, a.pos - k.plotTop + C + e / 2, e]);\n        });\n      };\n\n      b.prototype.pointAttribs = function () {\n        return q.pointAttribs.apply(this, arguments);\n      };\n\n      b.prototype.translate3dPoints = function () {\n        return q.translate3dPoints.apply(this, arguments);\n      };\n\n      b.prototype.translate3dShapes = function () {\n        return q.translate3dShapes.apply(this, arguments);\n      };\n\n      b.defaultOptions = v(t.defaultOptions, m.defaultOptions, d);\n      return b;\n    }(m);\n\n    l(c.prototype, {\n      directTouch: !0,\n      pointClass: a,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      adjustForMissingColumns: q.adjustForMissingColumns,\n      animate: q.animate,\n      crispCol: q.crispCol,\n      drawGraph: b,\n      drawPoints: q.drawPoints,\n      getSymbol: b,\n      drawTracker: q.drawTracker,\n      getColumnMetrics: q.getColumnMetrics\n    });\n    f.registerSeriesType(\"columnrange\", c);\n    \"\";\n    return c;\n  });\n  A(e, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f) {\n    var c = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, d) {\n          a.__proto__ = d;\n        } || function (a, d) {\n          for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function g() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (g.prototype = c.prototype, new g());\n      };\n    }(),\n        e = a.prototype,\n        l = f.clamp,\n        m = f.merge,\n        t = f.pick;\n\n    f = function (b) {\n      function f() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      c(f, b);\n\n      f.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            d = a.options,\n            c = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        c = a.borderWidth = t(d.borderWidth, c ? 0 : 1);\n        var f = a.yAxis,\n            h = d.threshold,\n            p = a.translatedThreshold = f.getThreshold(h),\n            m = t(d.minPointLength, 5),\n            q = a.getColumnMetrics(),\n            H = q.width,\n            E = a.barW = Math.max(H, 1 + 2 * c),\n            D = a.pointXOffset = q.offset;\n        b.inverted && (p -= .5);\n        d.pointPadding && (E = Math.ceil(E));\n        e.translate.apply(a);\n        a.points.forEach(function (c) {\n          var k = t(c.yBottom, p),\n              w = 999 + Math.abs(k),\n              g = l(c.plotY, -w, f.len + w);\n          w = c.plotX + D;\n          var e = E / 2,\n              n = Math.min(g, k);\n          k = Math.max(g, k) - n;\n          var q;\n          c.barX = w;\n          c.pointWidth = H;\n          c.tooltipPos = b.inverted ? [f.len + f.pos - b.plotLeft - g, a.xAxis.len - w - e, k] : [w + e, g + f.pos - b.plotTop, k];\n          g = h + (c.total || c.y);\n          \"percent\" === d.stacking && (g = h + (0 > c.y) ? -100 : 100);\n          g = f.toPixels(g, !0);\n          var r = (q = b.plotHeight - g - (b.plotHeight - p)) ? e * (n - g) / q : 0;\n          var u = q ? e * (n + k - g) / q : 0;\n          q = w - r + e;\n          r = w + r + e;\n          var z = w + u + e;\n          u = w - u + e;\n          var J = n - m;\n          var y = n + k;\n          0 > c.y && (J = n, y = n + k + m);\n          b.inverted && (z = f.width - n, q = g - (f.width - p), r = e * (g - z) / q, u = e * (g - (z - k)) / q, q = w + e + r, r = q - 2 * r, z = w - u + e, u = w + u + e, J = n, y = n + k - m, 0 > c.y && (y = n + k + m));\n          c.shapeType = \"path\";\n          c.shapeArgs = {\n            x: q,\n            y: J,\n            width: r - q,\n            height: k,\n            d: [[\"M\", q, J], [\"L\", r, J], [\"L\", z, y], [\"L\", u, y], [\"Z\"]]\n          };\n        });\n      };\n\n      f.defaultOptions = m(a.defaultOptions, {});\n      return f;\n    }(a);\n\n    b.registerSeriesType(\"columnpyramid\", f);\n    \"\";\n    return f;\n  });\n  A(e, \"Series/ErrorBar/ErrorBarSeries.js\", [e[\"Series/BoxPlot/BoxPlotSeries.js\"], e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var e = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, d) {\n          a.__proto__ = d;\n        } || function (a, d) {\n          for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        l = f.seriesTypes.arearange,\n        m = c.merge;\n\n    c = c.extend;\n\n    var t = function (c) {\n      function f() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      e(f, c);\n\n      f.prototype.getColumnMetrics = function () {\n        return this.linkedParent && this.linkedParent.columnMetrics || b.prototype.getColumnMetrics.call(this);\n      };\n\n      f.prototype.drawDataLabels = function () {\n        var a = this.pointValKey;\n        l && (l.prototype.drawDataLabels.call(this), this.data.forEach(function (b) {\n          b.y = b[a];\n        }));\n      };\n\n      f.prototype.toYData = function (a) {\n        return [a.low, a.high];\n      };\n\n      f.defaultOptions = m(a.defaultOptions, {\n        color: \"#000000\",\n        grouping: !1,\n        linkedTo: \":previous\",\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        whiskerWidth: null\n      });\n      return f;\n    }(a);\n\n    c(t.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    });\n    f.registerSeriesType(\"errorbar\", t);\n    \"\";\n    return t;\n  });\n  A(e, \"Series/Gauge/GaugePoint.js\", [e[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var b = this && this.__extends || function () {\n      var a = function (b, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, f);\n      };\n\n      return function (b, f) {\n        function c() {\n          this.constructor = b;\n        }\n\n        a(b, f);\n        b.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());\n      };\n    }();\n\n    return function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        b.shapeArgs = void 0;\n        return b;\n      }\n\n      b(c, a);\n\n      c.prototype.setState = function (a) {\n        this.state = a;\n      };\n\n      return c;\n    }(a.series.prototype.pointClass);\n  });\n  A(e, \"Series/Gauge/GaugeSeries.js\", [e[\"Series/Gauge/GaugePoint.js\"], e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, f, c) {\n    var e = this && this.__extends || function () {\n      var a = function (d, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, d) {\n          a.__proto__ = d;\n        } || function (a, d) {\n          for (var b in d) d.hasOwnProperty(b) && (a[b] = d[b]);\n        };\n\n        return a(d, b);\n      };\n\n      return function (d, b) {\n        function c() {\n          this.constructor = d;\n        }\n\n        a(d, b);\n        d.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    b = b.noop;\n    var l = f.series,\n        m = f.seriesTypes.column,\n        t = c.clamp,\n        q = c.isNumber,\n        D = c.extend,\n        v = c.merge,\n        g = c.pick,\n        d = c.pInt;\n\n    c = function (a) {\n      function b() {\n        var d = null !== a && a.apply(this, arguments) || this;\n        d.data = void 0;\n        d.points = void 0;\n        d.options = void 0;\n        d.yAxis = void 0;\n        return d;\n      }\n\n      e(b, a);\n\n      b.prototype.translate = function () {\n        var a = this.yAxis,\n            b = this.options,\n            c = a.center;\n        this.generatePoints();\n        this.points.forEach(function (k) {\n          var h = v(b.dial, k.dial),\n              f = d(h.radius) * c[2] / 200,\n              e = d(h.baseLength) * f / 100,\n              g = d(h.rearLength) * f / 100,\n              n = h.baseWidth,\n              w = h.topWidth,\n              B = b.overshoot,\n              p = a.startAngleRad + a.translate(k.y, void 0, void 0, void 0, !0);\n          if (q(B) || !1 === b.wrap) B = q(B) ? B / 180 * Math.PI : 0, p = t(p, a.startAngleRad - B, a.endAngleRad + B);\n          p = 180 * p / Math.PI;\n          k.shapeType = \"path\";\n          k.shapeArgs = {\n            d: h.path || [[\"M\", -g, -n / 2], [\"L\", e, -n / 2], [\"L\", f, -w / 2], [\"L\", f, w / 2], [\"L\", e, n / 2], [\"L\", -g, n / 2], [\"Z\"]],\n            translateX: c[0],\n            translateY: c[1],\n            rotation: p\n          };\n          k.plotX = c[0];\n          k.plotY = c[1];\n        });\n      };\n\n      b.prototype.drawPoints = function () {\n        var a = this,\n            d = a.chart,\n            b = a.yAxis.center,\n            c = a.pivot,\n            k = a.options,\n            f = k.pivot,\n            e = d.renderer;\n        a.points.forEach(function (b) {\n          var c = b.graphic,\n              f = b.shapeArgs,\n              h = f.d,\n              g = v(k.dial, b.dial);\n          c ? (c.animate(f), f.d = h) : b.graphic = e[b.shapeType](f).attr({\n            rotation: f.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!d.styledMode) b.graphic[c ? \"animate\" : \"attr\"]({\n            stroke: g.borderColor,\n            \"stroke-width\": g.borderWidth,\n            fill: g.backgroundColor\n          });\n        });\n        c ? c.animate({\n          translateX: b[0],\n          translateY: b[1]\n        }) : f && (a.pivot = e.circle(0, 0, f.radius).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(b[0], b[1]).add(a.group), d.styledMode || a.pivot.attr({\n          fill: f.backgroundColor,\n          stroke: f.borderColor,\n          \"stroke-width\": f.borderWidth\n        }));\n      };\n\n      b.prototype.animate = function (a) {\n        var d = this;\n        a || d.points.forEach(function (a) {\n          var b = a.graphic;\n          b && (b.attr({\n            rotation: 180 * d.yAxis.startAngleRad / Math.PI\n          }), b.animate({\n            rotation: a.shapeArgs.rotation\n          }, d.options.animation));\n        });\n      };\n\n      b.prototype.render = function () {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"inherit\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        l.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      };\n\n      b.prototype.setData = function (a, d) {\n        l.prototype.setData.call(this, a, !1);\n        this.processData();\n        this.generatePoints();\n        g(d, !0) && this.chart.redraw();\n      };\n\n      b.prototype.hasData = function () {\n        return !!this.points.length;\n      };\n\n      b.defaultOptions = v(l.defaultOptions, {\n        dataLabels: {\n          borderColor: \"#cccccc\",\n          borderRadius: 3,\n          borderWidth: 1,\n          crop: !1,\n          defer: !1,\n          enabled: !0,\n          verticalAlign: \"top\",\n          y: 15,\n          zIndex: 2\n        },\n        dial: {\n          backgroundColor: \"#000000\",\n          baseLength: \"70%\",\n          baseWidth: 3,\n          borderColor: \"#cccccc\",\n          borderWidth: 0,\n          radius: \"80%\",\n          rearLength: \"10%\",\n          topWidth: 1\n        },\n        pivot: {\n          radius: 5,\n          borderWidth: 0,\n          borderColor: \"#cccccc\",\n          backgroundColor: \"#000000\"\n        },\n        tooltip: {\n          headerFormat: \"\"\n        },\n        showInLegend: !1\n      });\n      return b;\n    }(l);\n\n    D(c.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: b,\n      drawTracker: m.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: a,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    f.registerSeriesType(\"gauge\", c);\n    \"\";\n    return c;\n  });\n  A(e, \"Series/DragNodesComposition.js\", [e[\"Core/Utilities.js\"]], function (a) {\n    function b() {\n      var a = this,\n          b,\n          c,\n          e;\n      a.container && (b = f(a.container, \"mousedown\", function (b) {\n        var p = a.hoverPoint;\n        p && p.series && p.series.hasDraggableNodes && p.series.options.draggable && (p.series.onMouseDown(p, b), c = f(a.container, \"mousemove\", function (a) {\n          return p && p.series && p.series.onMouseMove(p, a);\n        }), e = f(a.container.ownerDocument, \"mouseup\", function (a) {\n          c();\n          e();\n          return p && p.series && p.series.onMouseUp(p, a);\n        }));\n      }));\n      f(a, \"destroy\", function () {\n        b();\n      });\n    }\n\n    var f = a.addEvent,\n        c = [];\n    return {\n      compose: function (a) {\n        -1 === c.indexOf(a) && (c.push(a), f(a, \"load\", b));\n      },\n      onMouseDown: function (a, b) {\n        b = this.chart.pointer.normalize(b);\n        a.fixedPosition = {\n          chartX: b.chartX,\n          chartY: b.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function (a, b) {\n        if (a.fixedPosition && a.inDragMode) {\n          var c = this.chart,\n              f = c.pointer.normalize(b);\n          b = a.fixedPosition.chartX - f.chartX;\n          f = a.fixedPosition.chartY - f.chartY;\n          var e = c.graphLayoutsLookup,\n              p = void 0,\n              l = void 0;\n          if (5 < Math.abs(b) || 5 < Math.abs(f)) p = a.fixedPosition.plotX - b, l = a.fixedPosition.plotY - f, c.isInsidePlot(p, l) && (a.plotX = p, a.plotY = l, a.hasDragged = !0, this.redrawHalo(a), e.forEach(function (a) {\n            a.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function (a, b) {\n        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function (a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n  });\n  A(e, \"Series/GraphLayoutComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Utilities.js\"]], function (a, b) {\n    function f() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation();\n      }), this.redraw());\n    }\n\n    function c() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation(!1);\n      }), this.redraw());\n    }\n\n    function e() {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.stop();\n      });\n    }\n\n    function l() {\n      var a = !1,\n          b = function (d) {\n        d.maxIterations-- && isFinite(d.temperature) && !d.isStable() && !d.enableSimulation && (d.beforeStep && d.beforeStep(), d.step(), c = !1, a = !0);\n      };\n\n      if (this.graphLayoutsLookup) {\n        m(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (a) {\n          return a.start();\n        }); !c;) {\n          var c = !0;\n          this.graphLayoutsLookup.forEach(b);\n        }\n\n        a && this.series.forEach(function (a) {\n          a && a.layout && a.render();\n        });\n      }\n    }\n\n    var m = a.setAnimation,\n        t = b.addEvent,\n        q = [];\n    return {\n      compose: function (a) {\n        q.indexOf(a) && (q.push(a), t(a, \"afterPrint\", f), t(a, \"beforePrint\", c), t(a, \"predraw\", e), t(a, \"render\", l));\n      },\n      integrations: {},\n      layouts: {}\n    };\n  });\n  A(e, \"Series/PackedBubble/PackedBubblePoint.js\", [e[\"Core/Chart/Chart.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Series/SeriesRegistry.js\"]], function (a, b, f) {\n    var c = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    return function (f) {\n      function e() {\n        var a = null !== f && f.apply(this, arguments) || this;\n        a.degree = NaN;\n        a.mass = NaN;\n        a.radius = NaN;\n        a.options = void 0;\n        a.series = void 0;\n        a.value = null;\n        return a;\n      }\n\n      c(e, f);\n\n      e.prototype.destroy = function () {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return b.prototype.destroy.apply(this, arguments);\n      };\n\n      e.prototype.firePointEvent = function () {\n        var a = this.series.options;\n\n        if (this.isParentNode && a.parentNode) {\n          var c = a.allowPointSelect;\n          a.allowPointSelect = a.parentNode.allowPointSelect;\n          b.prototype.firePointEvent.apply(this, arguments);\n          a.allowPointSelect = c;\n        } else b.prototype.firePointEvent.apply(this, arguments);\n      };\n\n      e.prototype.select = function () {\n        var c = this.series.chart;\n        this.isParentNode ? (c.getSelectedPoints = c.getSelectedParentNodes, b.prototype.select.apply(this, arguments), c.getSelectedPoints = a.prototype.getSelectedPoints) : b.prototype.select.apply(this, arguments);\n      };\n\n      return e;\n    }(f.seriesTypes.bubble.prototype.pointClass);\n  });\n  A(e, \"Series/PackedBubble/PackedBubbleSeriesDefaults.js\", [e[\"Core/Utilities.js\"]], function (a) {\n    var b = a.isNumber;\n    \"\";\n    return {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function () {\n          var a = this.series.chart.numberFormatter,\n              c = this.point.value;\n          return b(c) ? a(c, -1) : \"\";\n        },\n        parentNodeFormatter: function () {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: null,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1E3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    };\n  });\n  A(e, \"Series/Networkgraph/VerletIntegration.js\", [], function () {\n    return {\n      attractive: function (a, b, f) {\n        var c = a.getMass(),\n            e = -f.x * b * this.diffTemperature;\n        b = -f.y * b * this.diffTemperature;\n        a.fromNode.fixedPosition || (a.fromNode.plotX -= e * c.fromNode / a.fromNode.degree, a.fromNode.plotY -= b * c.fromNode / a.fromNode.degree);\n        a.toNode.fixedPosition || (a.toNode.plotX += e * c.toNode / a.toNode.degree, a.toNode.plotY += b * c.toNode / a.toNode.degree);\n      },\n      attractiveForceFunction: function (a, b) {\n        return (b - a) / a;\n      },\n      barycenter: function () {\n        var a = this.options.gravitationalConstant,\n            b = this.barycenter.xFactor,\n            f = this.barycenter.yFactor;\n        b = (b - (this.box.left + this.box.width) / 2) * a;\n        f = (f - (this.box.top + this.box.height) / 2) * a;\n        this.nodes.forEach(function (a) {\n          a.fixedPosition || (a.plotX -= b / a.mass / a.degree, a.plotY -= f / a.mass / a.degree);\n        });\n      },\n      getK: function (a) {\n        return Math.pow(a.box.width * a.box.height / a.nodes.length, .5);\n      },\n      integrate: function (a, b) {\n        var f = -a.options.friction,\n            c = a.options.maxSpeed,\n            e = (b.plotX + b.dispX - b.prevX) * f;\n        f *= b.plotY + b.dispY - b.prevY;\n        var l = Math.abs,\n            m = l(e) / (e || 1);\n        l = l(f) / (f || 1);\n        e = m * Math.min(c, Math.abs(e));\n        f = l * Math.min(c, Math.abs(f));\n        b.prevX = b.plotX + b.dispX;\n        b.prevY = b.plotY + b.dispY;\n        b.plotX += e;\n        b.plotY += f;\n        b.temperature = a.vectorLength({\n          x: e,\n          y: f\n        });\n      },\n      repulsive: function (a, b, f) {\n        b = b * this.diffTemperature / a.mass / a.degree;\n        a.fixedPosition || (a.plotX += f.x * b, a.plotY += f.y * b);\n      },\n      repulsiveForceFunction: function (a, b) {\n        return (b - a) / a * (b > a ? 1 : 0);\n      }\n    };\n  });\n  A(e, \"Series/PackedBubble/PackedBubbleIntegration.js\", [e[\"Core/Globals.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (a, b) {\n    return {\n      barycenter: function () {\n        for (var a = this.options.gravitationalConstant, b = this.box, e = this.nodes, l, m, t = 0; t < e.length; t++) {\n          var q = e[t];\n          this.options.splitSeries && !q.isParentNode ? (l = q.series.parentNode.plotX, m = q.series.parentNode.plotY) : (l = b.width / 2, m = b.height / 2);\n          q.fixedPosition || (q.plotX -= (q.plotX - l) * a / (q.mass * Math.sqrt(e.length)), q.plotY -= (q.plotY - m) * a / (q.mass * Math.sqrt(e.length)));\n        }\n      },\n      getK: a.noop,\n      integrate: b.integrate,\n      repulsive: function (a, b, e, l) {\n        var c = b * this.diffTemperature / a.mass / a.degree;\n        b = e.x * c;\n        e = e.y * c;\n        a.fixedPosition || (a.plotX += b, a.plotY += e);\n        l.fixedPosition || (l.plotX -= b, l.plotY -= e);\n      },\n      repulsiveForceFunction: function (a, b, e, l) {\n        return Math.min(a, (e.marker.radius + l.marker.radius) / 2);\n      }\n    };\n  });\n  A(e, \"Series/Networkgraph/EulerIntegration.js\", [], function () {\n    return {\n      attractive: function (a, b, e, c) {\n        var f = a.getMass(),\n            l = e.x / c * b;\n        b *= e.y / c;\n        a.fromNode.fixedPosition || (a.fromNode.dispX -= l * f.fromNode / a.fromNode.degree, a.fromNode.dispY -= b * f.fromNode / a.fromNode.degree);\n        a.toNode.fixedPosition || (a.toNode.dispX += l * f.toNode / a.toNode.degree, a.toNode.dispY += b * f.toNode / a.toNode.degree);\n      },\n      attractiveForceFunction: function (a, b) {\n        return a * a / b;\n      },\n      barycenter: function () {\n        var a = this.options.gravitationalConstant,\n            b = this.barycenter.xFactor,\n            e = this.barycenter.yFactor;\n        this.nodes.forEach(function (c) {\n          if (!c.fixedPosition) {\n            var f = c.getDegree();\n            f *= 1 + f / 2;\n            c.dispX += (b - c.plotX) * a * f / c.degree;\n            c.dispY += (e - c.plotY) * a * f / c.degree;\n          }\n        });\n      },\n      getK: function (a) {\n        return Math.pow(a.box.width * a.box.height / a.nodes.length, .3);\n      },\n      integrate: function (a, b) {\n        b.dispX += b.dispX * a.options.friction;\n        b.dispY += b.dispY * a.options.friction;\n        var e = b.temperature = a.vectorLength({\n          x: b.dispX,\n          y: b.dispY\n        });\n        0 !== e && (b.plotX += b.dispX / e * Math.min(Math.abs(b.dispX), a.temperature), b.plotY += b.dispY / e * Math.min(Math.abs(b.dispY), a.temperature));\n      },\n      repulsive: function (a, b, e, c) {\n        a.dispX += e.x / c * b / a.degree;\n        a.dispY += e.y / c * b / a.degree;\n      },\n      repulsiveForceFunction: function (a, b) {\n        return b * b / a;\n      }\n    };\n  });\n  A(e, \"Series/Networkgraph/QuadTreeNode.js\", [], function () {\n    return function () {\n      function a(a) {\n        this.isInternal = this.isEmpty = this.body = !1;\n        this.nodes = [];\n        this.box = a;\n        this.boxSize = Math.min(a.width, a.height);\n      }\n\n      a.prototype.divideBox = function () {\n        var b = this.box.width / 2,\n            e = this.box.height / 2;\n        this.nodes[0] = new a({\n          left: this.box.left,\n          top: this.box.top,\n          width: b,\n          height: e\n        });\n        this.nodes[1] = new a({\n          left: this.box.left + b,\n          top: this.box.top,\n          width: b,\n          height: e\n        });\n        this.nodes[2] = new a({\n          left: this.box.left + b,\n          top: this.box.top + e,\n          width: b,\n          height: e\n        });\n        this.nodes[3] = new a({\n          left: this.box.left,\n          top: this.box.top + e,\n          width: b,\n          height: e\n        });\n      };\n\n      a.prototype.getBoxPosition = function (a) {\n        var b = a.plotY < this.box.top + this.box.height / 2;\n        return a.plotX < this.box.left + this.box.width / 2 ? b ? 0 : 3 : b ? 1 : 2;\n      };\n\n      a.prototype.insert = function (b, e) {\n        this.isInternal ? this.nodes[this.getBoxPosition(b)].insert(b, e - 1) : (this.isEmpty = !1, this.body ? e ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, e - 1), this.body = !0), this.nodes[this.getBoxPosition(b)].insert(b, e - 1)) : (e = new a({\n          top: b.plotX || NaN,\n          left: b.plotY || NaN,\n          width: .1,\n          height: .1\n        }), e.body = b, e.isInternal = !1, this.nodes.push(e)) : (this.isInternal = !1, this.body = b));\n      };\n\n      a.prototype.updateMassAndCenter = function () {\n        var a = 0,\n            e = 0,\n            c = 0;\n\n        if (this.isInternal) {\n          for (var p = 0, l = this.nodes; p < l.length; p++) {\n            var m = l[p];\n            m.isEmpty || (a += m.mass, e += m.plotX * m.mass, c += m.plotY * m.mass);\n          }\n\n          e /= a;\n          c /= a;\n        } else this.body && (a = this.body.mass, e = this.body.plotX, c = this.body.plotY);\n\n        this.mass = a;\n        this.plotX = e;\n        this.plotY = c;\n      };\n\n      return a;\n    }();\n  });\n  A(e, \"Series/Networkgraph/QuadTree.js\", [e[\"Series/Networkgraph/QuadTreeNode.js\"]], function (a) {\n    return function () {\n      function b(b, c, e, l) {\n        this.box = {\n          left: b,\n          top: c,\n          width: e,\n          height: l\n        };\n        this.maxDepth = 25;\n        this.root = new a(this.box);\n        this.root.isInternal = !0;\n        this.root.isRoot = !0;\n        this.root.divideBox();\n      }\n\n      b.prototype.calculateMassAndCenter = function () {\n        this.visitNodeRecursive(null, null, function (a) {\n          a.updateMassAndCenter();\n        });\n      };\n\n      b.prototype.insertNodes = function (a) {\n        for (var b = 0; b < a.length; b++) this.root.insert(a[b], this.maxDepth);\n      };\n\n      b.prototype.visitNodeRecursive = function (a, b, e) {\n        var c;\n        a || (a = this.root);\n        a === this.root && b && (c = b(a));\n\n        if (!1 !== c) {\n          for (var f = 0, p = a.nodes; f < p.length; f++) {\n            var q = p[f];\n\n            if (q.isInternal) {\n              b && (c = b(q));\n              if (!1 === c) continue;\n              this.visitNodeRecursive(q, b, e);\n            } else q.body && b && b(q.body);\n\n            e && e(q);\n          }\n\n          a === this.root && e && e(a);\n        }\n      };\n\n      return b;\n    }();\n  });\n  A(e, \"Series/Networkgraph/ReingoldFruchtermanLayout.js\", [e[\"Series/Networkgraph/EulerIntegration.js\"], e[\"Core/Globals.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Series/Networkgraph/QuadTree.js\"], e[\"Core/Utilities.js\"], e[\"Series/Networkgraph/VerletIntegration.js\"]], function (a, b, e, c, p, l) {\n    var f = b.win,\n        t = p.clamp,\n        q = p.defined,\n        D = p.isFunction,\n        v = p.pick;\n    return function () {\n      function b() {\n        this.attractiveForce = void 0;\n        this.box = {};\n        this.currentStep = 0;\n        this.initialRendering = !0;\n        this.integration = void 0;\n        this.links = [];\n        this.nodes = [];\n        this.repulsiveForce = this.quadTree = this.options = void 0;\n        this.series = [];\n        this.simulation = !1;\n      }\n\n      b.compose = function (d) {\n        e.compose(d);\n        e.integrations.euler = a;\n        e.integrations.verlet = l;\n        e.layouts[\"reingold-fruchterman\"] = b;\n      };\n\n      b.prototype.init = function (a) {\n        this.options = a;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = e.integrations[a.integration];\n        this.enableSimulation = a.enableSimulation;\n        this.attractiveForce = v(a.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = v(a.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = a.approximation;\n      };\n\n      b.prototype.updateSimulation = function (a) {\n        this.enableSimulation = v(a, this.options.enableSimulation);\n      };\n\n      b.prototype.start = function () {\n        var a = this.series,\n            b = this.options;\n        this.currentStep = 0;\n        this.forces = a[0] && a[0].forces || [];\n        this.chart = a[0] && a[0].chart;\n        this.initialRendering && (this.initPositions(), a.forEach(function (a) {\n          a.finishedAnimating = !0;\n          a.render();\n        }));\n        this.setK();\n        this.resetSimulation(b);\n        this.enableSimulation && this.step();\n      };\n\n      b.prototype.step = function () {\n        var a = this,\n            b = this.series;\n        this.currentStep++;\n        \"barnes-hut\" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter());\n\n        for (var c = 0, e = this.forces || []; c < e.length; c++) this[e[c] + \"Forces\"](this.temperature);\n\n        this.applyLimits();\n        this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n        this.prevSystemTemperature = this.systemTemperature;\n        this.systemTemperature = this.getSystemTemperature();\n\n        if (this.enableSimulation) {\n          for (c = 0; c < b.length; c++) e = b[c], e.chart && e.render();\n\n          this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && f.cancelAnimationFrame(this.simulation), this.simulation = f.requestAnimationFrame(function () {\n            return a.step();\n          })) : this.simulation = !1;\n        }\n      };\n\n      b.prototype.stop = function () {\n        this.simulation && f.cancelAnimationFrame(this.simulation);\n      };\n\n      b.prototype.setArea = function (a, b, c, e) {\n        this.box = {\n          left: a,\n          top: b,\n          width: c,\n          height: e\n        };\n      };\n\n      b.prototype.setK = function () {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      };\n\n      b.prototype.addElementsToCollection = function (a, b) {\n        for (var d = 0; d < a.length; d++) {\n          var c = a[d];\n          -1 === b.indexOf(c) && b.push(c);\n        }\n      };\n\n      b.prototype.removeElementFromCollection = function (a, b) {\n        a = b.indexOf(a);\n        -1 !== a && b.splice(a, 1);\n      };\n\n      b.prototype.clear = function () {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      };\n\n      b.prototype.resetSimulation = function () {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      };\n\n      b.prototype.restartSimulation = function () {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      };\n\n      b.prototype.setMaxIterations = function (a) {\n        this.maxIterations = v(a, this.options.maxIterations);\n      };\n\n      b.prototype.setTemperature = function () {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      };\n\n      b.prototype.setDiffTemperature = function () {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      };\n\n      b.prototype.setInitialRendering = function (a) {\n        this.initialRendering = a;\n      };\n\n      b.prototype.createQuadTree = function () {\n        this.quadTree = new c(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      };\n\n      b.prototype.initPositions = function () {\n        var a = this.options.initialPositions;\n\n        if (D(a)) {\n          a.call(this);\n          a = 0;\n\n          for (var b = this.nodes; a < b.length; a++) {\n            var c = b[a];\n            q(c.prevX) || (c.prevX = c.plotX);\n            q(c.prevY) || (c.prevY = c.plotY);\n            c.dispX = 0;\n            c.dispY = 0;\n          }\n        } else \"circle\" === a ? this.setCircularPositions() : this.setRandomPositions();\n      };\n\n      b.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), e = b.filter(function (a) {\n          return 0 === a.linksTo.length;\n        }), f = {}, g = this.options.initialPositionRadius, p = function (a) {\n          var b = 0;\n\n          for (a = a.linksFrom || []; b < a.length; b++) {\n            var d = a[b];\n            f[d.toNode.id] || (f[d.toNode.id] = !0, q.push(d.toNode), p(d.toNode));\n          }\n        }, q = [], l = 0; l < e.length; l++) {\n          var m = e[l];\n          q.push(m);\n          p(m);\n        }\n\n        if (q.length) for (e = 0; e < b.length; e++) l = b[e], -1 === q.indexOf(l) && q.push(l);else q = b;\n        e = 0;\n\n        for (l = q.length; e < l; ++e) b = q[e], b.plotX = b.prevX = v(b.plotX, a.width / 2 + g * Math.cos(e * c)), b.plotY = b.prevY = v(b.plotY, a.height / 2 + g * Math.sin(e * c)), b.dispX = 0, b.dispY = 0;\n      };\n\n      b.prototype.setRandomPositions = function () {\n        for (var a = this.box, b = this.nodes, c = b.length + 1, e = function (a) {\n          a = a * a / Math.PI;\n          return a -= Math.floor(a);\n        }, f, g = 0, q = b.length; g < q; ++g) f = b[g], f.plotX = f.prevX = v(f.plotX, a.width * e(g)), f.plotY = f.prevY = v(f.plotY, a.height * e(c + g)), f.dispX = 0, f.dispY = 0;\n      };\n\n      b.prototype.force = function (a) {\n        for (var b = [], d = 1; d < arguments.length; d++) b[d - 1] = arguments[d];\n\n        this.integration[a].apply(this, b);\n      };\n\n      b.prototype.barycenterForces = function () {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      };\n\n      b.prototype.getBarycenter = function () {\n        for (var a = 0, b = 0, c = 0, e = 0, f = this.nodes; e < f.length; e++) {\n          var g = f[e];\n          b += g.plotX * g.mass;\n          c += g.plotY * g.mass;\n          a += g.mass;\n        }\n\n        return this.barycenter = {\n          x: b,\n          y: c,\n          xFactor: b / a,\n          yFactor: c / a\n        };\n      };\n\n      b.prototype.barnesHutApproximation = function (a, b) {\n        var d = this.getDistXY(a, b),\n            c = this.vectorLength(d);\n        if (a !== b && 0 !== c) if (b.isInternal) {\n          if (b.boxSize / c < this.options.theta && 0 !== c) {\n            var e = this.repulsiveForce(c, this.k);\n            this.force(\"repulsive\", a, e * b.mass, d, c);\n            var f = !1;\n          } else f = !0;\n        } else e = this.repulsiveForce(c, this.k), this.force(\"repulsive\", a, e * b.mass, d, c);\n        return f;\n      };\n\n      b.prototype.repulsiveForces = function () {\n        var a = this;\n        if (\"barnes-hut\" === this.approximation) for (var b = function (b) {\n          c.quadTree.visitNodeRecursive(null, function (d) {\n            return a.barnesHutApproximation(b, d);\n          });\n        }, c = this, e = 0, f = this.nodes; e < f.length; e++) {\n          var g = f[e];\n          b(g);\n        } else {\n          f = e = b = void 0;\n\n          for (var q = 0, p = this.nodes; q < p.length; q++) {\n            g = p[q];\n\n            for (var l = 0, m = this.nodes; l < m.length; l++) {\n              var t = m[l];\n              g === t || g.fixedPosition || (f = this.getDistXY(g, t), e = this.vectorLength(f), 0 !== e && (b = this.repulsiveForce(e, this.k), this.force(\"repulsive\", g, b * t.mass, f, e)));\n            }\n          }\n        }\n      };\n\n      b.prototype.attractiveForces = function () {\n        for (var a, b, c, e = 0, f = this.links; e < f.length; e++) {\n          var g = f[e];\n          g.fromNode && g.toNode && (a = this.getDistXY(g.fromNode, g.toNode), b = this.vectorLength(a), 0 !== b && (c = this.attractiveForce(b, this.k), this.force(\"attractive\", g, c, a, b)));\n        }\n      };\n\n      b.prototype.applyLimits = function () {\n        for (var a = 0, b = this.nodes; a < b.length; a++) {\n          var c = b[a];\n          if (c.fixedPosition) break;\n          this.integration.integrate(this, c);\n          this.applyLimitBox(c, this.box);\n          c.dispX = 0;\n          c.dispY = 0;\n        }\n      };\n\n      b.prototype.applyLimitBox = function (a, b) {\n        var d = a.radius;\n        a.plotX = t(a.plotX, b.left + d, b.width - d);\n        a.plotY = t(a.plotY, b.top + d, b.height - d);\n      };\n\n      b.prototype.coolDown = function (a, b, c) {\n        return a - b * c;\n      };\n\n      b.prototype.isStable = function () {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      };\n\n      b.prototype.getSystemTemperature = function () {\n        for (var a = 0, b = 0, c = this.nodes; b < c.length; b++) a += c[b].temperature;\n\n        return a;\n      };\n\n      b.prototype.vectorLength = function (a) {\n        return Math.sqrt(a.x * a.x + a.y * a.y);\n      };\n\n      b.prototype.getDistR = function (a, b) {\n        a = this.getDistXY(a, b);\n        return this.vectorLength(a);\n      };\n\n      b.prototype.getDistXY = function (a, b) {\n        var d = a.plotX - b.plotX;\n        a = a.plotY - b.plotY;\n        return {\n          x: d,\n          y: a,\n          absX: Math.abs(d),\n          absY: Math.abs(a)\n        };\n      };\n\n      return b;\n    }();\n  });\n  A(e, \"Series/PackedBubble/PackedBubbleLayout.js\", [e[\"Series/GraphLayoutComposition.js\"], e[\"Series/PackedBubble/PackedBubbleIntegration.js\"], e[\"Series/Networkgraph/ReingoldFruchtermanLayout.js\"], e[\"Core/Utilities.js\"]], function (a, b, e, c) {\n    function f() {\n      var a = [];\n      this.series.forEach(function (b) {\n        b.parentNode && b.parentNode.selected && a.push(b.parentNode);\n      });\n      return a;\n    }\n\n    function l() {\n      this.allDataPoints && delete this.allDataPoints;\n    }\n\n    var m = this && this.__extends || function () {\n      var a = function (b, d) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);\n        };\n\n        return a(b, d);\n      };\n\n      return function (b, d) {\n        function c() {\n          this.constructor = b;\n        }\n\n        a(b, d);\n        b.prototype = null === d ? Object.create(d) : (c.prototype = d.prototype, new c());\n      };\n    }(),\n        t = c.addEvent,\n        q = c.pick,\n        D = [];\n\n    c = function (c) {\n      function g() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.index = NaN;\n        a.nodes = [];\n        a.options = void 0;\n        a.series = [];\n        return a;\n      }\n\n      m(g, c);\n\n      g.compose = function (d) {\n        e.compose(d);\n        a.integrations.packedbubble = b;\n        a.layouts.packedbubble = g;\n        -1 === D.indexOf(d) && (D.push(d), t(d, \"beforeRedraw\", l), d.prototype.getSelectedParentNodes = f);\n      };\n\n      g.prototype.beforeStep = function () {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      };\n\n      g.prototype.isStable = function () {\n        var a = Math.abs(this.prevSystemTemperature - this.systemTemperature);\n        return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && .00001 > a || 0 >= this.temperature;\n      };\n\n      g.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), e = this.options.initialPositionRadius, f, g, l = 0, p = 0; p < b.length; p++) {\n          var m = b[p];\n          this.options.splitSeries && !m.isParentNode ? (f = m.series.parentNode.plotX, g = m.series.parentNode.plotY) : (f = a.width / 2, g = a.height / 2);\n          m.plotX = m.prevX = q(m.plotX, f + e * Math.cos(m.index || l * c));\n          m.plotY = m.prevY = q(m.plotY, g + e * Math.sin(m.index || l * c));\n          m.dispX = 0;\n          m.dispY = 0;\n          l++;\n        }\n      };\n\n      g.prototype.repulsiveForces = function () {\n        var a = this,\n            b = a.options.bubblePadding,\n            c,\n            e,\n            f;\n        a.nodes.forEach(function (d) {\n          d.degree = d.mass;\n          d.neighbours = 0;\n          a.nodes.forEach(function (g) {\n            c = 0;\n            d === g || d.fixedPosition || !a.options.seriesInteraction && d.series !== g.series || (f = a.getDistXY(d, g), e = a.vectorLength(f) - (d.marker.radius + g.marker.radius + b), 0 > e && (d.degree += .01, d.neighbours++, c = a.repulsiveForce(-e / Math.sqrt(d.neighbours), a.k, d, g)), a.force(\"repulsive\", d, c * g.mass, f, g, e));\n          });\n        });\n      };\n\n      g.prototype.applyLimitBox = function (a, b) {\n        if (this.options.splitSeries && !a.isParentNode && this.options.parentNodeLimit) {\n          var d = this.getDistXY(a, a.series.parentNode);\n          var e = a.series.parentNodeRadius - a.marker.radius - this.vectorLength(d);\n          0 > e && e > -2 * a.marker.radius && (a.plotX -= .01 * d.x, a.plotY -= .01 * d.y);\n        }\n\n        c.prototype.applyLimitBox.call(this, a, b);\n      };\n\n      return g;\n    }(e);\n\n    return a.layouts.packedbubble = c;\n  });\n  A(e, \"Series/PackedBubble/PackedBubbleSeries.js\", [e[\"Core/Color/Color.js\"], e[\"Series/DragNodesComposition.js\"], e[\"Series/GraphLayoutComposition.js\"], e[\"Core/Globals.js\"], e[\"Series/PackedBubble/PackedBubblePoint.js\"], e[\"Series/PackedBubble/PackedBubbleSeriesDefaults.js\"], e[\"Series/PackedBubble/PackedBubbleLayout.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, e, c, p, l, m, t, q) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }(),\n        v = a.parse;\n\n    a = c.noop;\n    var g = t.series.prototype,\n        d = t.seriesTypes.bubble,\n        k = q.addEvent,\n        n = q.clamp,\n        h = q.defined,\n        A = q.extend,\n        L = q.fireEvent,\n        I = q.isArray,\n        H = q.isNumber,\n        E = q.merge,\n        N = q.pick;\n\n    q = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.layout = void 0;\n        b.options = void 0;\n        b.parentNodeMass = 0;\n        b.points = void 0;\n        b.xData = void 0;\n        return b;\n      }\n\n      f(c, a);\n\n      c.compose = function (a, b, c, e) {\n        d.compose(a, b, c, e);\n        m.compose(b);\n      };\n\n      c.prototype.accumulateAllPoints = function () {\n        for (var a = this.chart, b = [], c, d = 0, e = a.series; d < e.length; d++) {\n          var f = e[d];\n\n          if (f.is(\"packedbubble\") && f.visible || !a.options.chart.ignoreHiddenSeries) {\n            c = f.yData || [];\n\n            for (var g = 0; g < c.length; g++) b.push([null, null, c[g], f.index, g, {\n              id: g,\n              marker: {\n                radius: 0\n              }\n            }]);\n          }\n        }\n\n        return b;\n      };\n\n      c.prototype.addLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.options.chart,\n            d = this.chart.graphLayoutsStorage,\n            f = this.chart.graphLayoutsLookup;\n        d || (this.chart.graphLayoutsStorage = d = {}, this.chart.graphLayoutsLookup = f = []);\n        var g = d[b];\n        g || (a.enableSimulation = h(c.forExport) ? !c.forExport : a.enableSimulation, d[b] = g = new e.layouts[b](), g.init(a), f.splice(g.index, 0, g));\n        this.layout = g;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        g.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        g.addElementsToCollection([this], g.series);\n        g.addElementsToCollection(this.points, g.nodes);\n      };\n\n      c.prototype.addSeriesLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.graphLayoutsStorage,\n            d = this.chart.graphLayoutsLookup;\n        a = E(a, a.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var f = c[b + \"-series\"];\n        f || (c[b + \"-series\"] = f = new e.layouts[b](), f.init(a), d.splice(f.index, 0, f));\n        this.parentNodeLayout = f;\n        this.createParentNodes();\n      };\n\n      c.prototype.calculateParentRadius = function () {\n        var a = this.seriesBox();\n        this.parentNodeRadius = n(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      };\n\n      c.prototype.calculateZExtremes = function () {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            c = Infinity,\n            d = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            h(a) && (a > d && (d = a), a < c && (c = a));\n          });\n        });\n        a = N(a, c);\n        b = N(b, d);\n        return [a, b];\n      };\n\n      c.prototype.checkOverlap = function (a, b) {\n        var c = a[0] - b[0],\n            d = a[1] - b[1];\n        return -.001 > Math.sqrt(c * c + d * d) - Math.abs(a[2] + b[2]);\n      };\n\n      c.prototype.createParentNodes = function () {\n        var a = this,\n            b = this.pointClass,\n            c = this.chart,\n            d = this.parentNodeLayout,\n            e = this.layout.options,\n            f,\n            g = this.parentNode,\n            h = {\n          radius: this.parentNodeRadius,\n          lineColor: this.color,\n          fillColor: v(this.color).brighten(.4).get()\n        };\n        e.parentNodeOptions && (h = E(e.parentNodeOptions.marker || {}, h));\n        this.parentNodeMass = 0;\n        this.points.forEach(function (b) {\n          a.parentNodeMass += Math.PI * Math.pow(b.marker.radius, 2);\n        });\n        this.calculateParentRadius();\n        d.nodes.forEach(function (b) {\n          b.seriesIndex === a.index && (f = !0);\n        });\n        d.setArea(0, 0, c.plotWidth, c.plotHeight);\n        f || (g || (g = new b().init(this, {\n          mass: this.parentNodeRadius / 2,\n          marker: h,\n          dataLabels: {\n            inside: !1\n          },\n          states: {\n            normal: {\n              marker: h\n            },\n            hover: {\n              marker: h\n            }\n          },\n          dataLabelOnNull: !0,\n          degree: this.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: this.index\n        })), this.parentNode && (g.plotX = this.parentNode.plotX, g.plotY = this.parentNode.plotY), this.parentNode = g, d.addElementsToCollection([this], d.series), d.addElementsToCollection([g], d.nodes));\n      };\n\n      c.prototype.deferLayout = function () {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      };\n\n      c.prototype.destroy = function () {\n        var a = this;\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (b) {\n          b.removeElementFromCollection(a, b.series);\n        }, this);\n        this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        g.destroy.apply(this, arguments);\n      };\n\n      c.prototype.drawDataLabels = function () {\n        var a = this.options.dataLabels.textPath,\n            b = this.points;\n        g.drawDataLabels.apply(this, arguments);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, g.drawDataLabels.apply(this, arguments), this.points = b, this.options.dataLabels.textPath = a);\n      };\n\n      c.prototype.drawGraph = function () {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart,\n              b = this.layout.options.parentNodeOptions.marker;\n          b = {\n            fill: b.fillColor || v(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": N(b.lineWidth, this.options.lineWidth)\n          };\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          var c = E({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, b);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(b.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(c);\n        }\n      };\n\n      c.prototype.drawTracker = function () {\n        var b = this.parentNode;\n        a.prototype.drawTracker.call(this);\n\n        if (b) {\n          var c = I(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          c.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        }\n      };\n\n      c.prototype.getPointRadius = function () {\n        var a = this,\n            b = this.chart,\n            c = this.options,\n            d = c.useSimulation,\n            e = Math.min(b.plotWidth, b.plotHeight),\n            f = {},\n            g = [],\n            h = b.allDataPoints || [],\n            k = h.length,\n            y,\n            q,\n            m,\n            l;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              d = /%$/.test(c[a]);\n          f[a] = d ? e * b / 100 : b * Math.sqrt(k);\n        });\n        b.minRadius = y = f.minSize / Math.sqrt(k);\n        b.maxRadius = q = f.maxSize / Math.sqrt(k);\n        var p = d ? this.calculateZExtremes() : [y, q];\n        h.forEach(function (b, c) {\n          m = d ? n(b[2], p[0], p[1]) : b[2];\n          l = a.getRadius(p[0], p[1], y, q, m);\n          0 === l && (l = null);\n          h[c][2] = l;\n          g.push(l);\n        });\n        this.radii = g;\n      };\n\n      c.prototype.init = function () {\n        g.init.apply(this, arguments);\n        this.eventsToUnbind.push(k(this, \"updatedData\", function () {\n          var a = this;\n          this.chart.series.forEach(function (b) {\n            b.type === a.type && (b.isDirty = !0);\n          }, this);\n        }));\n        return this;\n      };\n\n      c.prototype.onMouseUp = function (a) {\n        var c = a;\n\n        if (c.fixedPosition && !c.removed) {\n          var d = this.layout,\n              e = this.parentNodeLayout,\n              f,\n              g;\n          e && d.options.dragBetweenSeries && e.nodes.forEach(function (a) {\n            c && c.marker && a !== c.series.parentNode && (f = d.getDistXY(c, a), g = d.vectorLength(f) - a.marker.radius - c.marker.radius, 0 > g && (a.series.addPoint(E(c.options, {\n              plotX: c.plotX,\n              plotY: c.plotY\n            }), !1), d.removeElementFromCollection(c, d.nodes), c.remove()));\n          });\n          b.onMouseUp.apply(this, arguments);\n        }\n      };\n\n      c.prototype.placeBubbles = function (a) {\n        var b = this.checkOverlap,\n            c = this.positionBubble,\n            d = [],\n            e = 1,\n            f = 0,\n            g = 0;\n        var h = [];\n        var k;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          d.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (d.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), k = 2; k < a.length; k++) a[k][2] = a[k][2] || 1, h = c(d[e][f], d[e - 1][g], a[k]), b(h, d[e][0]) ? (d.push([]), g = 0, d[e + 1].push(c(d[e][f], d[e][0], a[k])), e++, f = 0) : 1 < e && d[e - 1][g + 1] && b(h, d[e - 1][g + 1]) ? (g++, d[e].push(c(d[e][f], d[e - 1][g], a[k])), f++) : (f++, d[e].push(h));\n          this.chart.stages = d;\n          this.chart.rawPositions = [].concat.apply([], d);\n          this.resizeRadius();\n          h = this.chart.rawPositions;\n        }\n\n        return h;\n      };\n\n      c.prototype.pointAttribs = function (a, b) {\n        var c = this.options,\n            d = c.marker;\n        a && a.isParentNode && c.layoutAlgorithm && c.layoutAlgorithm.parentNodeOptions && (d = c.layoutAlgorithm.parentNodeOptions.marker);\n        c = d.fillOpacity;\n        a = g.pointAttribs.call(this, a, b);\n        1 !== c && (a[\"fill-opacity\"] = c);\n        return a;\n      };\n\n      c.prototype.positionBubble = function (a, b, c) {\n        var d = Math.sqrt,\n            e = Math.asin,\n            f = Math.acos,\n            g = Math.pow,\n            h = Math.abs;\n        d = d(g(a[0] - b[0], 2) + g(a[1] - b[1], 2));\n        f = f((g(d, 2) + g(c[2] + b[2], 2) - g(c[2] + a[2], 2)) / (2 * (c[2] + b[2]) * d));\n        e = e(h(a[0] - b[0]) / d);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + f + e * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + c[2]) * Math.sin(a), b[1] - (b[2] + c[2]) * Math.cos(a), c[2], c[3], c[4]];\n      };\n\n      c.prototype.render = function () {\n        var a = [];\n        g.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (b) {\n          I(b.dataLabels) && b.dataLabels.forEach(function (b) {\n            a.push(b);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      };\n\n      c.prototype.resizeRadius = function () {\n        var a = this.chart,\n            b = a.rawPositions,\n            c = Math.min,\n            d = Math.max,\n            e = a.plotLeft,\n            f = a.plotTop,\n            g = a.plotHeight,\n            h = a.plotWidth,\n            k,\n            n;\n        var q = k = Number.POSITIVE_INFINITY;\n        var l = n = Number.NEGATIVE_INFINITY;\n\n        for (var m = 0; m < b.length; m++) {\n          var p = b[m];\n          var t = p[2];\n          q = c(q, p[0] - t);\n          l = d(l, p[0] + t);\n          k = c(k, p[1] - t);\n          n = d(n, p[1] + t);\n        }\n\n        p = [l - q, n - k];\n        c = c.apply([], [(h - e) / p[0], (g - f) / p[1]]);\n\n        if (1e-10 < Math.abs(c - 1)) {\n          for (a = 0; a < b.length; a++) p = b[a], p[2] *= c;\n\n          this.placeBubbles(b);\n        } else a.diffY = g / 2 + f - k - (n - k) / 2, a.diffX = h / 2 + e - q - (l - q) / 2;\n      };\n\n      c.prototype.seriesBox = function () {\n        var a = this.chart,\n            b = Math.max,\n            c = Math.min,\n            d = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight],\n            e;\n        this.data.forEach(function (a) {\n          h(a.plotX) && h(a.plotY) && a.marker.radius && (e = a.marker.radius, d[0] = c(d[0], a.plotX - e), d[1] = b(d[1], a.plotX + e), d[2] = c(d[2], a.plotY - e), d[3] = b(d[3], a.plotY + e));\n        });\n        return H(d.width / d.height) ? d : null;\n      };\n\n      c.prototype.setVisible = function () {\n        var a = this;\n        g.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (b) {\n          a.layout.removeElementFromCollection(b, a.layout.nodes);\n        }));\n      };\n\n      c.prototype.translate = function () {\n        var a = this.chart,\n            b = this.data,\n            c = this.index,\n            d = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        h(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(), this.getPointRadius());\n        if (d) var e = a.allDataPoints;else e = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (var f = 0, g = e; f < g.length; f++) {\n          var k = g[f];\n\n          if (k[3] === c) {\n            e = b[k[4]];\n            var n = N(k[2], void 0);\n            d || (e.plotX = k[0] - a.plotLeft + a.diffX, e.plotY = k[1] - a.plotTop + a.diffY);\n            H(n) && (e.marker = A(e.marker, {\n              radius: n,\n              width: 2 * n,\n              height: 2 * n\n            }), e.radius = n);\n          }\n        }\n\n        d && this.deferLayout();\n        L(this, \"afterTranslate\");\n      };\n\n      c.defaultOptions = E(d.defaultOptions, l);\n      return c;\n    }(d);\n\n    A(q.prototype, {\n      pointClass: p,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointArrayMap: [\"value\"],\n      pointValKey: \"value\",\n      requireSorting: !1,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      alignDataLabel: g.alignDataLabel,\n      indexateNodes: a,\n      onMouseDown: b.onMouseDown,\n      onMouseMove: b.onMouseMove,\n      redrawHalo: b.redrawHalo,\n      searchPoint: a\n    });\n    t.registerSeriesType(\"packedbubble\", q);\n    \"\";\n    return q;\n  });\n  A(e, \"Series/Polygon/PolygonSeries.js\", [e[\"Core/Globals.js\"], e[\"Core/Legend/LegendSymbol.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (a, b, e, c) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }();\n\n    a = a.noop;\n    var l = e.series,\n        m = e.seriesTypes,\n        t = m.area,\n        q = m.line,\n        D = m.scatter;\n    m = c.extend;\n    var v = c.merge;\n\n    c = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      f(b, a);\n\n      b.prototype.getGraphPath = function () {\n        for (var a = q.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n\n        return this.areaPath = a;\n      };\n\n      b.prototype.drawGraph = function () {\n        this.options.fillColor = this.color;\n        t.prototype.drawGraph.call(this);\n      };\n\n      b.defaultOptions = v(D.defaultOptions, {\n        marker: {\n          enabled: !1,\n          states: {\n            hover: {\n              enabled: !1\n            }\n          }\n        },\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0,\n          pointFormat: \"\"\n        },\n        trackByArea: !0\n      });\n      return b;\n    }(D);\n\n    m(c.prototype, {\n      type: \"polygon\",\n      drawLegendSymbol: b.drawRectangle,\n      drawTracker: l.prototype.drawTracker,\n      setStackedPoints: a\n    });\n    e.registerSeriesType(\"polygon\", c);\n    \"\";\n    return c;\n  });\n  A(e, \"Core/Axis/WaterfallAxis.js\", [e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Utilities.js\"]], function (a, b) {\n    var e = b.addEvent,\n        c = b.objectEach,\n        p;\n\n    (function (b) {\n      function f() {\n        var a = this.waterfall.stacks;\n        a && (a.changed = !1, delete a.alreadyChanged);\n      }\n\n      function p() {\n        var a = this.options.stackLabels;\n        a && a.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function q() {\n        for (var a = this.axes, b = this.series, c = b.length; c--;) b[c].options.stacking && (a.forEach(function (a) {\n          a.isXAxis || (a.waterfall.stacks.changed = !0);\n        }), c = 0);\n      }\n\n      function l() {\n        this.waterfall || (this.waterfall = new v(this));\n      }\n\n      var v = function () {\n        function b(a) {\n          this.axis = a;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        b.prototype.renderStackTotals = function () {\n          var b = this.axis,\n              e = b.waterfall.stacks,\n              f = b.stacking && b.stacking.stackTotalGroup,\n              g = new a(b, b.options.stackLabels, !1, 0, void 0);\n          this.dummyStackItem = g;\n          c(e, function (b) {\n            c(b, function (b) {\n              g.total = b.stackTotal;\n              b.label && (g.label = b.label);\n              a.prototype.render.call(g, f);\n              b.label = g.label;\n              delete g.label;\n            });\n          });\n          g.total = null;\n        };\n\n        return b;\n      }();\n\n      b.Composition = v;\n\n      b.compose = function (a, b) {\n        e(a, \"init\", l);\n        e(a, \"afterBuildStacks\", f);\n        e(a, \"afterRender\", p);\n        e(b, \"beforeRedraw\", q);\n      };\n    })(p || (p = {}));\n\n    return p;\n  });\n  A(e, \"Series/Waterfall/WaterfallPoint.js\", [e[\"Series/Column/ColumnSeries.js\"], e[\"Core/Series/Point.js\"], e[\"Core/Utilities.js\"]], function (a, b, e) {\n    var c = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        f = e.isNumber;\n\n    return function (a) {\n      function e() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n\n      c(e, a);\n\n      e.prototype.getClassName = function () {\n        var a = b.prototype.getClassName.call(this);\n        this.isSum ? a += \" highcharts-sum\" : this.isIntermediateSum && (a += \" highcharts-intermediate-sum\");\n        return a;\n      };\n\n      e.prototype.isValid = function () {\n        return f(this.y) || this.isSum || !!this.isIntermediateSum;\n      };\n\n      return e;\n    }(a.prototype.pointClass);\n  });\n  A(e, \"Series/Waterfall/WaterfallSeries.js\", [e[\"Core/Axis/Axis.js\"], e[\"Core/Chart/Chart.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"], e[\"Core/Axis/WaterfallAxis.js\"], e[\"Series/Waterfall/WaterfallPoint.js\"]], function (a, b, e, c, p, l) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }(),\n        t = e.seriesTypes,\n        q = t.column,\n        A = t.line,\n        v = c.arrayMax,\n        g = c.arrayMin,\n        d = c.correctFloat;\n\n    t = c.extend;\n    var k = c.isNumber,\n        n = c.merge,\n        h = c.objectEach,\n        G = c.pick;\n\n    c = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.stackedYNeg = void 0;\n        b.stackedYPos = void 0;\n        b.stackKey = void 0;\n        b.xData = void 0;\n        b.yAxis = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      f(b, a);\n\n      b.prototype.generatePoints = function () {\n        var a;\n        q.prototype.generatePoints.apply(this);\n        var b = 0;\n\n        for (a = this.points.length; b < a; b++) {\n          var c = this.points[b];\n          var e = this.processedYData[b];\n          if (c.isIntermediateSum || c.isSum) c.y = d(e);\n        }\n      };\n\n      b.prototype.translate = function () {\n        var a = this.options,\n            b = this.yAxis,\n            c = G(a.minPointLength, 5),\n            d = c / 2,\n            e = a.threshold || 0,\n            f = e,\n            g = e;\n        a = a.stacking;\n        var h = b.waterfall.stacks[this.stackKey];\n        q.prototype.translate.apply(this);\n\n        for (var p = this.points, n = 0; n < p.length; n++) {\n          var r = p[n];\n          var u = this.processedYData[n];\n          var z = r.shapeArgs;\n\n          if (z && k(u)) {\n            var l = [0, u];\n            var y = r.y;\n\n            if (a) {\n              if (h) {\n                l = h[n];\n\n                if (\"overlap\" === a) {\n                  var m = l.stackState[l.stateIndex--];\n                  m = 0 <= y ? m : m - y;\n                  Object.hasOwnProperty.call(l, \"absolutePos\") && delete l.absolutePos;\n                  Object.hasOwnProperty.call(l, \"absoluteNeg\") && delete l.absoluteNeg;\n                } else 0 <= y ? (m = l.threshold + l.posTotal, l.posTotal -= y) : (m = l.threshold + l.negTotal, l.negTotal -= y, m -= y), !l.posTotal && Object.hasOwnProperty.call(l, \"absolutePos\") && (l.posTotal = l.absolutePos, delete l.absolutePos), !l.negTotal && Object.hasOwnProperty.call(l, \"absoluteNeg\") && (l.negTotal = l.absoluteNeg, delete l.absoluteNeg);\n\n                r.isSum || (l.connectorThreshold = l.threshold + l.stackTotal);\n                b.reversed ? (u = 0 <= y ? m - y : m + y, y = m) : (u = m, y = m - y);\n                r.below = u <= e;\n                z.y = b.translate(u, !1, !0, !1, !0);\n                z.height = Math.abs(z.y - b.translate(y, !1, !0, !1, !0));\n                if (y = b.waterfall.dummyStackItem) y.x = n, y.label = h[n].label, y.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[n], this.stackedYPos[n]);\n              }\n            } else m = Math.max(f, f + y) + l[0], z.y = b.translate(m, !1, !0, !1, !0), r.isSum ? (z.y = b.translate(l[1], !1, !0, !1, !0), z.height = Math.min(b.translate(l[0], !1, !0, !1, !0), b.len) - z.y, r.below = l[1] <= e) : r.isIntermediateSum ? (0 <= y ? (u = l[1] + g, y = g) : (u = g, y = l[1] + g), b.reversed && (u ^= y, y ^= u, u ^= y), z.y = b.translate(u, !1, !0, !1, !0), z.height = Math.abs(z.y - Math.min(b.translate(y, !1, !0, !1, !0), b.len)), g += l[1], r.below = u <= e) : (z.height = 0 < u ? b.translate(f, !1, !0, !1, !0) - z.y : b.translate(f, !1, !0, !1, !0) - b.translate(f - u, !1, !0, !1, !0), f += u, r.below = f < e), 0 > z.height && (z.y += z.height, z.height *= -1);\n\n            r.plotY = z.y = Math.round(z.y || 0) - this.borderWidth % 2 / 2;\n            z.height = Math.max(Math.round(z.height || 0), .001);\n            r.yBottom = z.y + z.height;\n            z.height <= c && !r.isNull ? (z.height = c, z.y -= d, r.plotY = z.y, r.minPointLengthOffset = 0 > r.y ? -d : d) : (r.isNull && (z.width = 0), r.minPointLengthOffset = 0);\n            y = r.plotY + (r.negative ? z.height : 0);\n            r.below && (r.plotY += z.height);\n            r.tooltipPos && (this.chart.inverted ? r.tooltipPos[0] = b.len - y : r.tooltipPos[1] = y);\n            r.isInside = this.isPointInside(r);\n          }\n        }\n      };\n\n      b.prototype.processData = function (b) {\n        var c = this.options,\n            e = this.yData,\n            f = c.data,\n            g = e.length,\n            h = c.threshold || 0,\n            k,\n            l,\n            n,\n            p,\n            r;\n\n        for (r = l = k = n = p = 0; r < g; r++) {\n          var u = e[r];\n          var m = f && f[r] ? f[r] : {};\n          \"sum\" === u || m.isSum ? e[r] = d(l) : \"intermediateSum\" === u || m.isIntermediateSum ? (e[r] = d(k), k = 0) : (l += u, k += u);\n          n = Math.min(l, n);\n          p = Math.max(l, p);\n        }\n\n        a.prototype.processData.call(this, b);\n        c.stacking || (this.dataMin = n + h, this.dataMax = p);\n      };\n\n      b.prototype.toYData = function (a) {\n        return a.isSum ? \"sum\" : a.isIntermediateSum ? \"intermediateSum\" : a.y;\n      };\n\n      b.prototype.updateParallelArrays = function (b, c) {\n        a.prototype.updateParallelArrays.call(this, b, c);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options.upColor;\n        c && !a.options.color && (a.color = 0 < a.y ? c : null);\n        a = q.prototype.pointAttribs.call(this, a, b);\n        delete a.dashstyle;\n        return a;\n      };\n\n      b.prototype.getGraphPath = function () {\n        return [[\"M\", 0, 0]];\n      };\n\n      b.prototype.getCrispPath = function () {\n        var a = this.data,\n            b = this.yAxis,\n            c = a.length,\n            d = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            e = Math.round(this.borderWidth) % 2 / 2,\n            f = this.xAxis.reversed,\n            g = this.yAxis.reversed,\n            h = this.options.stacking,\n            k = [],\n            l;\n\n        for (l = 1; l < c; l++) {\n          var r = a[l].shapeArgs;\n          var u = a[l - 1];\n          var n = a[l - 1].shapeArgs;\n          var p = b.waterfall.stacks[this.stackKey];\n          var m = 0 < u.y ? -n.height : 0;\n          p && n && r && (p = p[l - 1], h ? (p = p.connectorThreshold, m = Math.round(b.translate(p, 0, 1, 0, 1) + (g ? m : 0)) - d) : m = n.y + u.minPointLengthOffset + e - d, k.push([\"M\", (n.x || 0) + (f ? 0 : n.width || 0), m], [\"L\", (r.x || 0) + (f ? r.width || 0 : 0), m]));\n          n && k.length && (!h && 0 > u.y && !g || 0 < u.y && g) && ((u = k[k.length - 2]) && \"number\" === typeof u[2] && (u[2] += n.height || 0), (u = k[k.length - 1]) && \"number\" === typeof u[2] && (u[2] += n.height || 0));\n        }\n\n        return k;\n      };\n\n      b.prototype.drawGraph = function () {\n        A.prototype.drawGraph.call(this);\n        this.graph.attr({\n          d: this.getCrispPath()\n        });\n      };\n\n      b.prototype.setStackedPoints = function () {\n        function a(a, b, c, d) {\n          if (M) for (c; c < M; c++) t.stackState[c] += d;else t.stackState[0] = a, M = t.stackState.length;\n          t.stackState.push(t.stackState[M - 1] + b);\n        }\n\n        var b = this.options,\n            c = this.yAxis.waterfall.stacks,\n            d = b.threshold,\n            e = d || 0,\n            f = e,\n            g = this.stackKey,\n            h = this.xData,\n            k = h.length,\n            l,\n            r,\n            u;\n        this.yAxis.stacking.usePercentage = !1;\n        var n = r = u = e;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var p = c.changed;\n          (l = c.alreadyChanged) && 0 > l.indexOf(g) && (p = !0);\n          c[g] || (c[g] = {});\n          l = c[g];\n\n          for (var m = 0; m < k; m++) {\n            var q = h[m];\n            if (!l[q] || p) l[q] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: p && l[q] ? l[q].label : void 0\n            };\n            var t = l[q];\n            var v = this.yData[m];\n            0 <= v ? t.posTotal += v : t.negTotal += v;\n            var A = b.data[m];\n            q = t.absolutePos = t.posTotal;\n            var D = t.absoluteNeg = t.negTotal;\n            t.stackTotal = q + D;\n            var M = t.stackState.length;\n            A && A.isIntermediateSum ? (a(u, r, 0, u), u = r, r = d, e ^= f, f ^= e, e ^= f) : A && A.isSum ? (a(d, n, M), e = d) : (a(e, v, 0, n), A && (n += v, r += v));\n            t.stateIndex++;\n            t.threshold = e;\n            e += t.stackTotal;\n          }\n\n          c.changed = !1;\n          c.alreadyChanged || (c.alreadyChanged = []);\n          c.alreadyChanged.push(g);\n        }\n      };\n\n      b.prototype.getExtremes = function () {\n        var a = this.options.stacking;\n\n        if (a) {\n          var b = this.yAxis;\n          b = b.waterfall.stacks;\n          var c = this.stackedYNeg = [];\n          var d = this.stackedYPos = [];\n          \"overlap\" === a ? h(b[this.stackKey], function (a) {\n            c.push(g(a.stackState));\n            d.push(v(a.stackState));\n          }) : h(b[this.stackKey], function (a) {\n            c.push(a.negTotal + a.threshold);\n            d.push(a.posTotal + a.threshold);\n          });\n          return {\n            dataMin: g(c),\n            dataMax: v(d)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      };\n\n      b.defaultOptions = n(q.defaultOptions, {\n        dataLabels: {\n          inside: !0\n        },\n        lineWidth: 1,\n        lineColor: \"#333333\",\n        dashStyle: \"Dot\",\n        borderColor: \"#333333\",\n        states: {\n          hover: {\n            lineWidthPlus: 0\n          }\n        }\n      });\n      return b;\n    }(q);\n\n    t(c.prototype, {\n      getZonesGraphs: A.prototype.getZonesGraphs,\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: l\n    });\n    e.registerSeriesType(\"waterfall\", c);\n    p.compose(a, b);\n    \"\";\n    return c;\n  });\n  A(e, \"Core/Axis/RadialAxis.js\", [e[\"Core/Axis/AxisDefaults.js\"], e[\"Core/DefaultOptions.js\"], e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (a, b, e, c) {\n    var f = b.defaultOptions,\n        l = e.noop,\n        m = c.addEvent,\n        t = c.correctFloat,\n        q = c.defined,\n        A = c.extend,\n        v = c.fireEvent,\n        g = c.merge,\n        d = c.pick,\n        k = c.relativeLength,\n        n = c.wrap,\n        h;\n\n    (function (b) {\n      function c() {\n        this.autoConnect = this.isCircular && \"undefined\" === typeof d(this.userMax, this.options.max) && t(this.endAngleRad - this.startAngleRad) === t(2 * Math.PI);\n        !this.isCircular && this.chart.inverted && this.max++;\n        this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n\n      function e() {\n        var a = this;\n        return function () {\n          if (a.isRadial && a.tickPositions && a.options.labels && !0 !== a.options.labels.allowOverlap) return a.tickPositions.map(function (b) {\n            return a.ticks[b] && a.ticks[b].label;\n          }).filter(function (a) {\n            return !!a;\n          });\n        };\n      }\n\n      function h() {\n        return l;\n      }\n\n      function p(a, b, c) {\n        var d = this.pane.center,\n            e = a.value;\n\n        if (this.isCircular) {\n          if (q(e)) a.point && (f = a.point.shapeArgs || {}, f.start && (e = this.chart.inverted ? this.translate(a.point.rectPlotY, !0) : a.point.x));else {\n            var f = a.chartX || 0;\n            var g = a.chartY || 0;\n            e = this.translate(Math.atan2(g - c, f - b) - this.startAngleRad, !0);\n          }\n          a = this.getPosition(e);\n          f = a.x;\n          g = a.y;\n        } else q(e) || (f = a.chartX, g = a.chartY), q(f) && q(g) && (c = d[1] + this.chart.plotTop, e = this.translate(Math.min(Math.sqrt(Math.pow(f - b, 2) + Math.pow(g - c, 2)), d[2] / 2) - d[3] / 2, !0));\n\n        return [e, f || 0, g || 0];\n      }\n\n      function D(a, b, c) {\n        a = this.pane.center;\n        var e = this.chart,\n            f = this.left || 0,\n            g = this.top || 0,\n            h = d(b, a[2] / 2 - this.offset);\n        \"undefined\" === typeof c && (c = this.horiz ? 0 : this.center && -this.center[3] / 2);\n        c && (h += c);\n        this.isCircular || \"undefined\" !== typeof b ? (b = this.chart.renderer.symbols.arc(f + a[0], g + a[1], h, h, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        }), b.xBounds = [f + a[0]], b.yBounds = [g + a[1] - h]) : (b = this.postTranslate(this.angleRad, h), b = [[\"M\", this.center[0] + e.plotLeft, this.center[1] + e.plotTop], [\"L\", b.x, b.y]]);\n        return b;\n      }\n\n      function F() {\n        this.constructor.prototype.getOffset.call(this);\n        this.chart.axisOffset[this.side] = 0;\n      }\n\n      function G(a, b, c) {\n        var e = this.chart,\n            f = function (a) {\n          if (\"string\" === typeof a) {\n            var b = parseInt(a, 10);\n            n.test(a) && (b = b * k / 100);\n            return b;\n          }\n\n          return a;\n        },\n            g = this.center,\n            h = this.startAngleRad,\n            k = g[2] / 2,\n            l = Math.min(this.offset, 0),\n            u = this.left || 0,\n            r = this.top || 0,\n            n = /%$/,\n            p = this.isCircular,\n            m = d(f(c.outerRadius), k),\n            q = f(c.innerRadius);\n\n        f = d(f(c.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) l = this.getPlotLinePath({\n          value: a\n        }).concat(this.getPlotLinePath({\n          value: b,\n          reverse: !0\n        }));else {\n          a = Math.max(a, this.min);\n          b = Math.min(b, this.max);\n          a = this.translate(a);\n          b = this.translate(b);\n          p || (m = a || 0, q = b || 0);\n          if (\"circle\" !== c.shape && p) c = h + (a || 0), h += b || 0;else {\n            c = -Math.PI / 2;\n            h = 1.5 * Math.PI;\n            var y = !0;\n          }\n          m -= l;\n          l = e.renderer.symbols.arc(u + g[0], r + g[1], m, m, {\n            start: Math.min(c, h),\n            end: Math.max(c, h),\n            innerR: d(q, m - (f - l)),\n            open: y\n          });\n          p && (p = (h + c) / 2, u = u + g[0] + g[2] / 2 * Math.cos(p), l.xBounds = p > -Math.PI / 2 && p < Math.PI / 2 ? [u, e.plotWidth] : [0, u], l.yBounds = [r + g[1] + g[2] / 2 * Math.sin(p)], l.yBounds[0] += p > -Math.PI && 0 > p || p > Math.PI ? -10 : 10);\n        }\n        return l;\n      }\n\n      function w(a) {\n        var b = this,\n            c = this.pane.center,\n            d = this.chart,\n            e = d.inverted,\n            f = a.reverse,\n            g = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n            h = g.innerRadius || \"0%\",\n            l = g.outerRadius || \"100%\",\n            u = c[0] + d.plotLeft,\n            r = c[1] + d.plotTop,\n            p = this.height,\n            n = a.isCrosshair;\n        g = c[3] / 2;\n        var m = a.value,\n            q;\n        var y = this.getPosition(m);\n        var z = y.x;\n        y = y.y;\n        n && (y = this.getCrosshairPosition(a, u, r), m = y[0], z = y[1], y = y[2]);\n        if (this.isCircular) m = Math.sqrt(Math.pow(z - u, 2) + Math.pow(y - r, 2)), f = \"string\" === typeof h ? k(h, 1) : h / m, d = \"string\" === typeof l ? k(l, 1) : l / m, c && g && (g /= m, f < g && (f = g), d < g && (d = g)), c = [[\"M\", u + f * (z - u), r - f * (r - y)], [\"L\", z - (1 - d) * (z - u), y + (1 - d) * (r - y)]];else if ((m = this.translate(m)) && (0 > m || m > p) && (m = 0), \"circle\" === this.options.gridLineInterpolation) c = this.getLinePath(0, m, g);else if (c = [], d[e ? \"yAxis\" : \"xAxis\"].forEach(function (a) {\n          a.pane === b.pane && (q = a);\n        }), q) for (u = q.tickPositions, q.autoConnect && (u = u.concat([u[0]])), f && (u = u.slice().reverse()), m && (m += g), r = 0; r < u.length; r++) g = q.getPosition(u[r], m), c.push(r ? [\"L\", g.x, g.y] : [\"M\", g.x, g.y]);\n        return c;\n      }\n\n      function B(a, b) {\n        a = this.translate(a);\n        return this.postTranslate(this.isCircular ? a : this.angleRad, d(this.isCircular ? b : 0 > a ? 0 : a, this.center[2] / 2) - this.offset);\n      }\n\n      function C() {\n        var a = this.center,\n            b = this.chart,\n            c = this.options.title;\n        return {\n          x: b.plotLeft + a[0] + (c.x || 0),\n          y: b.plotTop + a[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[c.align] * a[2] + (c.y || 0)\n        };\n      }\n\n      function x(a) {\n        a.beforeSetTickPositions = c;\n        a.createLabelCollector = e;\n        a.getCrosshairPosition = p;\n        a.getLinePath = D;\n        a.getOffset = F;\n        a.getPlotBandPath = G;\n        a.getPlotLinePath = w;\n        a.getPosition = B;\n        a.getTitlePosition = C;\n        a.postTranslate = R;\n        a.setAxisSize = V;\n        a.setAxisTranslation = T;\n        a.setOptions = M;\n      }\n\n      function O() {\n        var a = this.chart,\n            b = this.options,\n            c = this.pane,\n            e = c && c.options;\n        a.angular && this.isXAxis || !c || !a.angular && !a.polar || (this.angleRad = (b.angle || 0) * Math.PI / 180, this.startAngleRad = (e.startAngle - 90) * Math.PI / 180, this.endAngleRad = (d(e.endAngle, e.startAngle + 360) - 90) * Math.PI / 180, this.offset = b.offset || 0);\n      }\n\n      function r(a) {\n        this.isRadial && (a.align = void 0, a.preventDefault());\n      }\n\n      function u() {\n        if (this.chart && this.chart.labelCollectors) {\n          var a = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          0 <= a && this.chart.labelCollectors.splice(a, 1);\n        }\n      }\n\n      function z(b) {\n        var c = this.chart,\n            d = c.inverted,\n            e = c.angular,\n            f = c.polar,\n            k = this.isXAxis,\n            u = this.coll,\n            r = e && k,\n            p = c.options;\n        b = b.userOptions.pane || 0;\n        b = this.pane = c.pane && c.pane[b];\n        var m;\n        if (\"colorAxis\" === u) this.isRadial = !1;else {\n          if (e) {\n            if (r ? (this.isHidden = !0, this.createLabelCollector = h, this.getOffset = l, this.render = this.redraw = S, this.setTitle = this.setCategories = this.setScale = l) : x(this), m = !k) this.defaultPolarOptions = X;\n          } else f && (x(this), this.defaultPolarOptions = (m = this.horiz) ? W : g(\"xAxis\" === u ? a.defaultXAxisOptions : a.defaultYAxisOptions, Y), d && \"yAxis\" === u && (this.defaultPolarOptions.stackLabels = a.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0));\n\n          e || f ? (this.isRadial = !0, p.chart.zooming.type = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && c.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n          b && m && (b.axis = this);\n          this.isCircular = m;\n        }\n      }\n\n      function J() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n\n      function y(a) {\n        var b = this.label;\n\n        if (b) {\n          var c = this.axis,\n              e = b.getBBox(),\n              f = c.options.labels,\n              g = (c.translate(this.pos) + c.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n              h = Math.round(g),\n              u = q(f.y) ? 0 : .3 * -e.height,\n              l = f.y,\n              r = 20,\n              m = f.align,\n              p = \"end\",\n              n = 0 > h ? h + 360 : h,\n              y = n,\n              z = 0,\n              t = 0;\n\n          if (c.isRadial) {\n            var P = c.getPosition(this.pos, c.center[2] / 2 + k(d(f.distance, -25), c.center[2] / 2, -c.center[2] / 2));\n            \"auto\" === f.rotation ? b.attr({\n              rotation: g\n            }) : q(l) || (l = c.chart.renderer.fontMetrics(b.styles && b.styles.fontSize).b - e.height / 2);\n            q(m) || (c.isCircular ? (e.width > c.len * c.tickInterval / (c.max - c.min) && (r = 0), m = g > r && g < 180 - r ? \"left\" : g > 180 + r && g < 360 - r ? \"right\" : \"center\") : m = \"center\", b.attr({\n              align: m\n            }));\n\n            if (\"auto\" === m && 2 === c.tickPositions.length && c.isCircular) {\n              90 < n && 180 > n ? n = 180 - n : 270 < n && 360 >= n && (n = 540 - n);\n              180 < y && 360 >= y && (y = 360 - y);\n              if (c.pane.options.startAngle === h || c.pane.options.startAngle === h + 360 || c.pane.options.startAngle === h - 360) p = \"start\";\n              m = -90 <= h && 90 >= h || -360 <= h && -270 >= h || 270 <= h && 360 >= h ? \"start\" === p ? \"right\" : \"left\" : \"start\" === p ? \"left\" : \"right\";\n              70 < y && 110 > y && (m = \"center\");\n              15 > n || 180 <= n && 195 > n ? z = .3 * e.height : 15 <= n && 35 >= n ? z = \"start\" === p ? 0 : .75 * e.height : 195 <= n && 215 >= n ? z = \"start\" === p ? .75 * e.height : 0 : 35 < n && 90 >= n ? z = \"start\" === p ? .25 * -e.height : e.height : 215 < n && 270 >= n && (z = \"start\" === p ? e.height : .25 * -e.height);\n              15 > y ? t = \"start\" === p ? .15 * -e.height : .15 * e.height : 165 < y && 180 >= y && (t = \"start\" === p ? .15 * e.height : .15 * -e.height);\n              b.attr({\n                align: m\n              });\n              b.translate(t, z + u);\n            }\n\n            a.pos.x = P.x + (f.x || 0);\n            a.pos.y = P.y + (l || 0);\n          }\n        }\n      }\n\n      function P(a) {\n        this.axis.getPosition && A(a.pos, this.axis.getPosition(this.pos));\n      }\n\n      function R(a, b) {\n        var c = this.chart,\n            d = this.center;\n        a = this.startAngleRad + a;\n        return {\n          x: c.plotLeft + d[0] + Math.cos(a) * b,\n          y: c.plotTop + d[1] + Math.sin(a) * b\n        };\n      }\n\n      function S() {\n        this.isDirty = !1;\n      }\n\n      function V() {\n        this.constructor.prototype.setAxisSize.call(this);\n\n        if (this.isRadial) {\n          this.pane.updateCenter(this);\n          var a = this.center = this.pane.center.slice();\n          if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n            var b = this.postTranslate(this.angleRad, a[3] / 2);\n            a[0] = b.x - this.chart.plotLeft;\n            a[1] = b.y - this.chart.plotTop;\n          }\n          this.len = this.width = this.height = (a[2] - a[3]) * d(this.sector, 1) / 2;\n        }\n      }\n\n      function T() {\n        this.constructor.prototype.setAxisTranslation.call(this);\n        this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n      }\n\n      function M(a) {\n        a = this.options = g(this.constructor.defaultOptions, this.defaultPolarOptions, f[this.coll], a);\n        a.plotBands || (a.plotBands = []);\n        v(this, \"afterSetOptions\");\n      }\n\n      function U(a, b, c, d, e, f, g) {\n        var h = this.axis;\n        h.isRadial ? (a = h.getPosition(this.pos, h.center[2] / 2 + d), b = [\"M\", b, c, \"L\", a.x, a.y]) : b = a.call(this, b, c, d, e, f, g);\n        return b;\n      }\n\n      var Q = [],\n          W = {\n        gridLineWidth: 1,\n        labels: {\n          align: void 0,\n          distance: 15,\n          x: 0,\n          y: void 0,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      },\n          X = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: void 0\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      },\n          Y = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n\n      b.compose = function (a, b) {\n        -1 === Q.indexOf(a) && (Q.push(a), m(a, \"afterInit\", O), m(a, \"autoLabelAlign\", r), m(a, \"destroy\", u), m(a, \"init\", z), m(a, \"initialAxisTranslation\", J));\n        -1 === Q.indexOf(b) && (Q.push(b), m(b, \"afterGetLabelPosition\", y), m(b, \"afterGetPosition\", P), n(b.prototype, \"getMarkPath\", U));\n        return a;\n      };\n    })(h || (h = {}));\n\n    return h;\n  });\n  A(e, \"Series/PolarComposition.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Globals.js\"], e[\"Extensions/Pane.js\"], e[\"Core/Axis/RadialAxis.js\"], e[\"Core/Utilities.js\"]], function (a, b, e, c, p) {\n    function f(a, b, c, d) {\n      var e = d ? 1 : 0;\n      var g = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > g - 1 ? a.length - (1 + e) : g - 1;\n      var h = a[b];\n      e = a[g + 1 > a.length - 1 ? e : g + 1];\n      var k = h.plotY;\n      var l = e.plotX;\n      var u = e.plotY;\n      e = a[g].plotX;\n      g = a[g].plotY;\n      h = (1.5 * e + h.plotX) / 2.5;\n      k = (1.5 * g + k) / 2.5;\n      l = (1.5 * e + l) / 2.5;\n      var r = (1.5 * g + u) / 2.5;\n      u = Math.sqrt(Math.pow(h - e, 2) + Math.pow(k - g, 2));\n      var n = Math.sqrt(Math.pow(l - e, 2) + Math.pow(r - g, 2));\n      h = Math.atan2(k - g, h - e);\n      r = Math.PI / 2 + (h + Math.atan2(r - g, l - e)) / 2;\n      Math.abs(h - r) > Math.PI / 2 && (r -= Math.PI);\n      h = e + Math.cos(r) * u;\n      k = g + Math.sin(r) * u;\n      l = e + Math.cos(Math.PI + r) * n;\n      r = g + Math.sin(Math.PI + r) * n;\n      e = {\n        rightContX: l,\n        rightContY: r,\n        leftContX: h,\n        leftContY: k,\n        plotX: e,\n        plotY: g\n      };\n      c && (e.prevPointCont = f(a, b, !1, d));\n      return e;\n    }\n\n    function m() {\n      (this.pane || []).forEach(function (a) {\n        a.render();\n      });\n    }\n\n    function t() {\n      var a = this;\n      this.pane || (this.pane = []);\n      this.options.pane = w(this.options.pane);\n      this.options.pane.forEach(function (b) {\n        new e(b, a);\n      }, this);\n    }\n\n    function q() {\n      var a = this.chart;\n      a.polar && (this.polar = new O(this), a.inverted && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0)));\n    }\n\n    function A() {\n      if (this.chart.polar && this.xAxis) {\n        var a = this.chart;\n        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = v : this.options.findNearestPointBy = \"xy\";\n        if (!this.preventPostTranslate) for (var c = this.points, d = c.length, e = void 0; d--;) e = c[d], this.polar.toXY(e), !a.hasParallelCoordinates && !this.yAxis.reversed && e.y < this.yAxis.min && (e.isNull = !0);\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(H(this, \"afterRender\", function () {\n          if (a.polar) {\n            var c = this.yAxis.pane.center;\n            if (this.clipCircle) this.clipCircle.animate({\n              x: c[0],\n              y: c[1],\n              r: c[2] / 2,\n              innerR: c[3] / 2\n            });else {\n              var d = a.renderer,\n                  e = c[0],\n                  f = c[1],\n                  g = c[2] / 2,\n                  h = c[3] / 2;\n              c = B();\n              var k = d.createElement(\"clipPath\").attr({\n                id: c\n              }).add(d.defs);\n              d = h ? d.arc(e, f, g, h, 0, 2 * Math.PI).add(k) : d.circle(e, f, g).add(k);\n              d.id = c;\n              d.clipPath = k;\n              this.clipCircle = d;\n            }\n            this.group.clip(this.clipCircle);\n            this.setClip = b.noop;\n          }\n        })));\n      }\n    }\n\n    function v(a) {\n      var b = this.chart,\n          c = this.xAxis;\n      c = c.pane && c.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - (c && c[0] || 0) - b.plotLeft, a.chartY - (c && c[1] || 0) - b.plotTop)\n      });\n    }\n\n    function g(a, b) {\n      return N(this.pane || [], function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    }\n\n    function d(a, b, c, d, e, f) {\n      var g = this.chart,\n          h = K(d.inside, !!this.options.stacking);\n      g.polar ? (a = b.rectPlotX / Math.PI * 180, g.inverted ? (this.forceDL = g.isInsidePlot(b.plotX, Math.round(b.plotY)), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate(((e.start || 0) + (e.end || 0)) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {\n        x: e.x - g.plotLeft,\n        y: e.y - g.plotTop\n      }) : b.tooltipPos && (e = {\n        x: b.tooltipPos[0],\n        y: b.tooltipPos[1]\n      }), d.align = K(d.align, \"center\"), d.verticalAlign = K(d.verticalAlign, \"middle\")) : (null === d.align && (d.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\"), null === d.verticalAlign && (d.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\")), Object.getPrototypeOf(Object.getPrototypeOf(this)).alignDataLabel.call(this, b, c, d, e, f), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end ? c.hide() : c.show()) : a.call(this, b, c, d, e, f);\n    }\n\n    function k(a) {\n      var b = this.options,\n          c = b.stacking,\n          d = this.chart,\n          e = this.xAxis,\n          f = this.yAxis,\n          g = f.reversed,\n          h = f.center,\n          k = e.startAngleRad,\n          l = e.endAngleRad - k,\n          n = 0,\n          m = 0,\n          r = 0;\n      this.preventPostTranslate = !0;\n      a.call(this);\n\n      if (e.isRadial) {\n        a = this.points;\n        e = a.length;\n        var q = f.translate(f.min);\n        var t = f.translate(f.max);\n        b = b.threshold || 0;\n        d.inverted && F(b) && (n = f.translate(b), E(n) && (0 > n ? n = 0 : n > l && (n = l), this.translatedThreshold = n + k));\n\n        for (; e--;) {\n          b = a[e];\n          var v = b.barX;\n          var w = b.x;\n          var x = b.y;\n          b.shapeType = \"arc\";\n\n          if (d.inverted) {\n            b.plotY = f.translate(x);\n            c && f.stacking ? (x = f.stacking.stacks[(0 > x ? \"-\" : \"\") + this.stackKey], this.visible && x && x[w] && !b.isNull && (r = x[w].points[this.getStackIndicator(void 0, w, this.index).key], m = f.translate(r[0]), r = f.translate(r[1]), E(m) && (m = p.clamp(m, 0, l)))) : (m = n, r = b.plotY);\n            m > r && (r = [m, m = r][0]);\n            if (!g) {\n              if (m < q) m = q;else if (r > t) r = t;else {\n                if (r < q || m > t) m = r = 0;\n              }\n            } else if (r > q) r = q;else if (m < t) m = t;else if (m > q || r < t) m = r = l;\n            f.min > f.max && (m = r = g ? l : 0);\n            m += k;\n            r += k;\n            h && (b.barX = v += h[3] / 2);\n            w = Math.max(v, 0);\n            x = Math.max(v + b.pointWidth, 0);\n            b.shapeArgs = {\n              x: h && h[0],\n              y: h && h[1],\n              r: x,\n              innerR: w,\n              start: m,\n              end: r\n            };\n            b.opacity = m === r ? 0 : void 0;\n            b.plotY = (E(this.translatedThreshold) && (m < this.translatedThreshold ? m : r)) - k;\n          } else m = v + k, b.shapeArgs = this.polar.arc(b.yBottom, b.plotY, m, m + b.pointWidth);\n\n          this.polar.toXY(b);\n          d.inverted ? (v = f.postTranslate(b.rectPlotY, v + b.pointWidth / 2), b.tooltipPos = [v.x - d.plotLeft, v.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n          h && (b.ttBelow = b.plotY > h[1]);\n        }\n      }\n    }\n\n    function n(a, b) {\n      var c = this;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (var d = 0; d < b.length; d++) if (!b[d].isNull) {\n          var e = d;\n          break;\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var f = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.polar.toXY(a);\n        });\n      }\n\n      e = a.apply(this, [].slice.call(arguments, 1));\n      f && b.pop();\n      return e;\n    }\n\n    function h(a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        if (\"colorAxis\" !== a.coll) {\n          var e = a.isXAxis,\n              f = a.center,\n              g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    }\n\n    function G(a, c) {\n      var d = this,\n          e = this.chart,\n          f = this.group,\n          g = this.markerGroup,\n          h = this.xAxis && this.xAxis.center,\n          k = e.plotLeft,\n          l = e.plotTop,\n          m = this.options.animation,\n          n,\n          p,\n          r,\n          q;\n      if (e.polar) {\n        if (d.isRadialBar) c || (d.startAngleRad = K(d.translatedThreshold, d.xAxis.startAngleRad), b.seriesTypes.pie.prototype.animate.call(d, c));else {\n          if (e.renderer.isSVG) if (m = I(m), d.is(\"column\")) {\n            if (!c) {\n              var u = h[3] / 2;\n              d.points.forEach(function (a) {\n                n = a.graphic;\n                r = (p = a.shapeArgs) && p.r;\n                q = p && p.innerR;\n                n && p && (n.attr({\n                  r: u,\n                  innerR: u\n                }), n.animate({\n                  r: r,\n                  innerR: q\n                }, d.options.animation));\n              });\n            }\n          } else c ? (a = {\n            translateX: h[0] + k,\n            translateY: h[1] + l,\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(a), g && g.attr(a)) : (a = {\n            translateX: k,\n            translateY: l,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(a, m), g && g.animate(a, m));\n        }\n      } else a.call(this, c);\n    }\n\n    function L(a, b, c, d) {\n      this.chart.polar ? d ? (a = f(b, d, !0, this.connectEnds), b = a.prevPointCont && a.prevPointCont.rightContX, c = a.prevPointCont && a.prevPointCont.rightContY, a = [\"C\", F(b) ? b : a.plotX, F(c) ? c : a.plotY, F(a.leftContX) ? a.leftContX : a.plotX, F(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, d);\n      return a;\n    }\n\n    var I = a.animObject,\n        H = p.addEvent,\n        E = p.defined,\n        N = p.find,\n        F = p.isNumber,\n        K = p.pick,\n        w = p.splat,\n        B = p.uniqueKey,\n        C = p.wrap,\n        x = [],\n        O = function () {\n      function a(a) {\n        this.series = a;\n      }\n\n      a.compose = function (a, b, e, f, l, p, r, v, w) {\n        c.compose(a, l);\n        -1 === x.indexOf(b) && (x.push(b), H(b, \"afterDrawChartBox\", m), H(b, \"getAxes\", t), C(b.prototype, \"get\", g));\n        -1 === x.indexOf(e) && (x.push(e), C(e.prototype, \"getCoordinates\", h));\n        -1 === x.indexOf(f) && (x.push(f), H(f, \"afterInit\", q), H(f, \"afterTranslate\", A, {\n          order: 2\n        }), C(f.prototype, \"animate\", G));\n        r && -1 === x.indexOf(r) && (x.push(r), a = r.prototype, C(a, \"alignDataLabel\", d), C(a, \"animate\", G), C(a, \"translate\", k));\n        v && -1 === x.indexOf(v) && (x.push(v), C(v.prototype, \"getGraphPath\", n));\n        w && -1 === x.indexOf(w) && (x.push(w), v = w.prototype, C(v, \"getPointSpline\", L), p && -1 === x.indexOf(p) && (x.push(p), p.prototype.getPointSpline = v.getPointSpline));\n      };\n\n      a.prototype.arc = function (a, b, c, d) {\n        var e = this.series,\n            f = e.xAxis.center,\n            g = e.yAxis.len,\n            h = f[3] / 2;\n        b = g - b + h;\n        a = g - K(a, g) + h;\n        e.yAxis.reversed && (0 > b && (b = h), 0 > a && (a = h));\n        return {\n          x: f[0],\n          y: f[1],\n          r: b,\n          innerR: a,\n          start: c,\n          end: d\n        };\n      };\n\n      a.prototype.toXY = function (a) {\n        var b = this.series,\n            c = b.chart,\n            d = b.xAxis,\n            e = b.yAxis,\n            f = a.plotX,\n            g = c.inverted,\n            h = a.y,\n            k = a.plotY,\n            l = g ? f : e.len - k;\n        g && b && !b.isRadialBar && (a.plotY = k = F(h) ? e.translate(h) : 0);\n        a.rectPlotX = f;\n        a.rectPlotY = k;\n        e.center && (l += e.center[3] / 2);\n        F(k) && (e = g ? e.postTranslate(k, l) : d.postTranslate(f, l), a.plotX = a.polarPlotX = e.x - c.plotLeft, a.plotY = a.polarPlotY = e.y - c.plotTop);\n        b.kdByAngle ? (b = (f / Math.PI * 180 + d.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n      };\n\n      return a;\n    }();\n\n    return O;\n  });\n  A(e, \"masters/highcharts-more.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Series/Bubble/BubbleSeries.js\"], e[\"Series/PackedBubble/PackedBubbleSeries.js\"], e[\"Series/PolarComposition.js\"]], function (a, b, e, c, p) {\n    e.compose(a.Axis, a.Chart, a.Legend, a.Series);\n    c.compose(a.Axis, a.Chart, a.Legend, a.Series);\n    p.compose(a.Axis, a.Chart, a.Pointer, a.Series, a.Tick, b.seriesTypes.areasplinerange, b.seriesTypes.column, b.seriesTypes.line, b.seriesTypes.spline);\n  });\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script"}