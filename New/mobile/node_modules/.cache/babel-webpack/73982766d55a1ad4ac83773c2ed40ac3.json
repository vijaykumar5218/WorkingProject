{"ast":null,"code":"import _asyncToGenerator from \"/Users/vijay.a/Documents/GitHub/MYVOYAGE/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*! Ionic Enterprise Auth Connect: https://ionicframework.com/ - Commercially Licensed */\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\n\nvar requiresPort = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n      return port !== 80;\n\n    case 'https':\n    case 'wss':\n      return port !== 443;\n\n    case 'ftp':\n      return port !== 21;\n\n    case 'gopher':\n      return port !== 70;\n\n    case 'file':\n      return false;\n  }\n\n  return port !== 0;\n};\n\nvar has = Object.prototype.hasOwnProperty,\n    undef;\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\n\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\n\n\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\n\n\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g,\n      result = {},\n      part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1]),\n        value = decode(part[2]); //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\n\n\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n  var pairs = [],\n      value,\n      key; //\n  // Optionally prefix with a '?' if needed\n  //\n\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key]; //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value); //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n\n      if (key === null || value === null) continue;\n      pairs.push(key + '=' + value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n} //\n// Expose the module.\n//\n\n\nvar stringify = querystringify;\nvar parse = querystring;\nvar querystringify_1 = {\n  stringify: stringify,\n  parse: parse\n};\nvar controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/,\n    CRHTLF = /[\\n\\r\\t]/g,\n    slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//,\n    port = /:\\d+$/,\n    protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i,\n    windowsDriveLetter = /^[a-zA-Z]:/;\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */\n\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(controlOrWhitespace, '');\n}\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\n\n\nvar rules = [['#', 'hash'], // Extract from the back.\n['?', 'query'], // Extract from the back.\nfunction sanitize(address, url) {\n  // Sanitize what is left of the address\n  return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n}, ['/', 'pathname'], // Extract from the back.\n['@', 'auth', 1], // Extract from the front.\n[NaN, 'host', undefined, 1, 1], // Set left over value.\n[/:(\\d*)$/, 'port', undefined, 1], // RegExp the back.\n[NaN, 'hostname', undefined, 1, 1] // Set left over.\n];\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\n\nvar ignore = {\n  hash: 1,\n  query: 1\n};\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\n\nfunction lolcation(loc) {\n  var globalVar;\n  if (typeof window !== 'undefined') globalVar = window;else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;else if (typeof self !== 'undefined') globalVar = self;else globalVar = {};\n  var location = globalVar.location || {};\n  loc = loc || location;\n  var finaldestination = {},\n      type = typeof loc,\n      key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\n\n\nfunction isSpecial(scheme) {\n  return scheme === 'file:' || scheme === 'ftp:' || scheme === 'http:' || scheme === 'https:' || scheme === 'ws:' || scheme === 'wss:';\n}\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\n\n\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4];\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\n\n\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\n      i = path.length,\n      last = path[i - 1],\n      unshift = false,\n      up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n  return path.join('/');\n}\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\n\n\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative,\n      extracted,\n      parse,\n      instruction,\n      index,\n      key,\n      instructions = rules.slice(),\n      type = typeof location,\n      url = this,\n      i = 0; //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;\n  location = lolcation(location); //\n  // Extract protocol information before running the instructions.\n  //\n\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest; //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n\n  if (extracted.protocol === 'file:' && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : ''); //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  } //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n\n\n  if (parser) url.query = parser(url.query); //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n\n  if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  } //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n\n\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  } //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n\n\n  if (!requiresPort(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  } //\n  // Parse down the `auth` for the username and password.\n  //\n\n\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password));\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username + ':' + url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null'; //\n  // The href is just the compiled result.\n  //\n\n  url.href = url.toString();\n}\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\n\n\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || querystringify_1.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!requiresPort(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname + ':' + value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n      if (url.port) value += ':' + url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (port.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.auth = url.password ? url.username + ':' + url.password : url.username;\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';\n  url.href = url.toString();\n  return url;\n}\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\n\n\nfunction toString$1(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;\n  var query,\n      url = this,\n      host = url.host,\n      protocol = url.protocol;\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n  var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':' + url.password;\n    result += '@';\n  } else if (url.password) {\n    result += ':' + url.password;\n    result += '@';\n  } else if (url.protocol !== 'file:' && isSpecial(url.protocol) && !host && url.pathname !== '/') {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  } //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n\n\n  if (host[host.length - 1] === ':' || port.test(url.hostname) && !url.port) {\n    host += ':';\n  }\n\n  result += host + url.pathname;\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\n  if (url.hash) result += url.hash;\n  return result;\n}\n\nUrl.prototype = {\n  set: set,\n  toString: toString$1\n}; //\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\n\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = querystringify_1;\nvar urlParse = Url;\n/**\n * @hidden\n */\n\nclass UrlInfo {\n  constructor(url = undefined) {\n    this.url = url;\n    this.headers = undefined;\n    this.payload = undefined;\n  }\n\n}\n\nclass Logger {\n  constructor() {\n    this.log_debug = false;\n    this.log_error = true;\n  }\n\n  setLogLevel(logLevel) {\n    switch (logLevel) {\n      case 'DEBUG':\n        this.log_debug = true;\n        this.log_error = true;\n        break;\n\n      case 'ERROR':\n        this.log_debug = false;\n        this.log_error = true;\n        break;\n\n      case 'NONE':\n        this.log_debug = false;\n        this.log_error = false;\n        break;\n\n      default:\n        this.log_debug = false;\n        this.log_error = true;\n    }\n  }\n\n  debug(...args) {\n    if (this.log_debug) {\n      console.log(...args);\n    }\n  }\n\n  error(...args) {\n    if (this.log_error) {\n      console.error(...args);\n    }\n  }\n\n}\n\nconst logging = new Logger();\nwindow._ionicAuthLogging = logging;\nlet messages = /*#__PURE__*/(() => {\n  class messages {}\n\n  messages.ADDING_COOKIES_NOT_SUPPORTED = 'auth-connect: string = \"setHeader\" does not support adding cookies, please use \"setCookie\" function instead';\n  messages.DATA_TYPE_MISMATCH = 'auth-connect: string = \"data\" argument supports only following data types:';\n  messages.INVALID_CLIENT_AUTH_ALIAS = 'auth-connect: string = invalid client certificate alias, needs to be a string or undefined';\n  messages.INVALID_CLIENT_AUTH_MODE = 'auth-connect: string = invalid client certificate authentication mode, supported modes are:';\n  messages.INVALID_CLIENT_AUTH_OPTIONS = 'auth-connect: string = invalid client certificate authentication options, needs to be an object';\n  messages.INVALID_CLIENT_AUTH_PKCS_PASSWORD = 'auth-connect: string = invalid PKCS12 container password, needs to be a string';\n  messages.INVALID_CLIENT_AUTH_RAW_PKCS = 'auth-connect: string = invalid PKCS12 container, needs to be an array buffer';\n  messages.INVALID_DATA_SERIALIZER = 'auth-connect: string = invalid serializer, supported serializers are:';\n  messages.INVALID_FOLLOW_REDIRECT_VALUE = 'auth-connect: string = invalid follow redirect value, needs to be a boolean value';\n  messages.INVALID_HEADERS_VALUE = 'auth-connect: string = header values must be strings';\n  messages.INVALID_HTTP_METHOD = 'auth-connect: string = invalid HTTP method, supported methods are:';\n  messages.INVALID_PARAMS_VALUE = 'auth-connect: string = invalid params object, needs to be an object with strings';\n  messages.INVALID_RESPONSE_TYPE = 'auth-connect: string = invalid response type, supported types are:';\n  messages.INVALID_SSL_CERT_MODE = 'auth-connect: string = invalid SSL cert mode, supported modes are:';\n  messages.INVALID_TIMEOUT_VALUE = 'auth-connect: string = invalid timeout value, needs to be a positive numeric value';\n  messages.MANDATORY_FAIL = 'auth-connect: string = missing mandatory \"onFail\" callback function';\n  messages.MANDATORY_SUCCESS = 'auth-connect: string = missing mandatory \"onSuccess\" callback function';\n  messages.LOGOUT_UNABLE_TO_RETRIEVE_TOKEN = 'auth-connect: string = Unable to retrieve Id Token from storage';\n  return messages;\n})();\n\nclass jsUtil {\n  // typeof is not working reliably in JS\n  static getTypeOf(object) {\n    switch (Object.prototype.toString.call(object)) {\n      case '[object Array]':\n        return 'Array';\n\n      case '[object Blob]':\n        return 'Blob';\n\n      case '[object ArrayBuffer]':\n        return 'ArrayBuffer';\n\n      case '[object Boolean]':\n        return 'Boolean';\n\n      case '[object Function]':\n        return 'Function';\n\n      case '[object Null]':\n        return 'Null';\n\n      case '[object Number]':\n        return 'Number';\n\n      case '[object Object]':\n        return 'Object';\n\n      case '[object String]':\n        return 'String';\n\n      case '[object Undefined]':\n        return 'Undefined';\n\n      default:\n        return 'Unknown';\n    }\n  }\n\n}\n\nlet helpers = /*#__PURE__*/(() => {\n  class helpers {\n    static mergeHeaders(globalHeaders, localHeaders) {\n      var globalKeys = Object.keys(globalHeaders);\n      var key;\n\n      for (var i = 0; i < globalKeys.length; i++) {\n        key = globalKeys[i];\n\n        if (!localHeaders.hasOwnProperty(key)) {\n          localHeaders[key] = globalHeaders[key];\n        }\n      }\n\n      return localHeaders;\n    }\n\n    static checkForValidStringValue(list, value, onInvalidValueMessage) {\n      if (jsUtil.getTypeOf(value) !== 'String') {\n        throw new Error(onInvalidValueMessage + ' ' + list.join(', '));\n      }\n\n      value = value.trim().toLowerCase();\n\n      if (list.indexOf(value) === -1) {\n        throw new Error(onInvalidValueMessage + ' ' + list.join(', '));\n      }\n\n      return value;\n    }\n\n    static checkKeyValuePairObject(obj, allowedChildren, onInvalidValueMessage) {\n      if (jsUtil.getTypeOf(obj) !== 'Object') {\n        throw new Error(onInvalidValueMessage);\n      }\n\n      var keys = Object.keys(obj);\n\n      for (var i = 0; i < keys.length; i++) {\n        if (allowedChildren.indexOf(jsUtil.getTypeOf(obj[keys[i]])) === -1) {\n          throw new Error(onInvalidValueMessage);\n        }\n      }\n\n      return obj;\n    }\n\n    static checkHttpMethod(method) {\n      return this.checkForValidStringValue(this.validHttpMethods, method, messages.INVALID_HTTP_METHOD);\n    }\n\n    static checkResponseType(type) {\n      return this.checkForValidStringValue(this.validResponseTypes, type, messages.INVALID_RESPONSE_TYPE);\n    }\n\n    static checkSerializer(serializer) {\n      return this.checkForValidStringValue(this.validSerializers, serializer, messages.INVALID_DATA_SERIALIZER);\n    }\n\n    static checkForBlacklistedHeaderKey(key) {\n      if (key.toLowerCase() === 'cookie') {\n        throw new Error(messages.ADDING_COOKIES_NOT_SUPPORTED);\n      }\n\n      return key;\n    }\n\n    static checkForInvalidHeaderValue(value) {\n      if (jsUtil.getTypeOf(value) !== 'String') {\n        throw new Error(messages.INVALID_HEADERS_VALUE);\n      }\n\n      return value;\n    }\n\n    static checkTimeoutValue(timeout) {\n      if (jsUtil.getTypeOf(timeout) !== 'Number' || timeout < 0) {\n        throw new Error(messages.INVALID_TIMEOUT_VALUE);\n      }\n\n      return timeout;\n    }\n\n    static checkFollowRedirectValue(follow) {\n      if (jsUtil.getTypeOf(follow) !== 'Boolean') {\n        throw new Error(messages.INVALID_FOLLOW_REDIRECT_VALUE);\n      }\n\n      return follow;\n    }\n\n    static checkHeadersObject(headers) {\n      return this.checkKeyValuePairObject(headers, ['String'], messages.INVALID_HEADERS_VALUE);\n    }\n\n    static checkParamsObject(params) {\n      return this.checkKeyValuePairObject(params, ['String', 'Array'], messages.INVALID_PARAMS_VALUE);\n    }\n\n    static getMatchingHostHeaders(url, headersList) {\n      var matches = url.match(/^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i);\n      var domain = matches && matches[1];\n      return headersList[domain] || null;\n    }\n\n    static getMergedHeaders(url, requestHeaders, predefinedHeaders) {\n      var globalHeaders = predefinedHeaders['*'] || {};\n      var hostHeaders = this.getMatchingHostHeaders(url, predefinedHeaders) || {};\n      var mergedHeaders = this.mergeHeaders(globalHeaders, hostHeaders);\n      mergedHeaders = this.mergeHeaders(mergedHeaders, requestHeaders);\n      return mergedHeaders;\n    }\n\n    static getAllowedDataTypes(dataSerializer) {\n      switch (dataSerializer) {\n        case 'utf8':\n          return ['String'];\n\n        case 'urlencoded':\n          return ['Object'];\n\n        default:\n          return ['Array', 'Object'];\n      }\n    }\n\n    static getProcessedData(data, dataSerializer) {\n      var currentDataType = jsUtil.getTypeOf(data);\n      var allowedDataTypes = this.getAllowedDataTypes(dataSerializer);\n\n      if (allowedDataTypes.indexOf(currentDataType) === -1) {\n        throw new Error(messages.DATA_TYPE_MISMATCH + ' ' + allowedDataTypes.join(', '));\n      }\n\n      if (dataSerializer === 'utf8') {\n        data = {\n          text: data\n        };\n      }\n\n      return data;\n    }\n\n    static handleMissingCallbacks(successFn, failFn) {\n      if (successFn === undefined) {\n        throw new Error(messages.MANDATORY_SUCCESS);\n      }\n\n      if (failFn === undefined) {\n        throw new Error(messages.MANDATORY_FAIL);\n      }\n    }\n\n    static handleMissingOptions(options, globals) {\n      options = options || {};\n      return {\n        method: this.checkHttpMethod(options.method || this.validHttpMethods[0]),\n        responseType: this.checkResponseType(options.responseType || this.validResponseTypes[0]),\n        serializer: this.checkSerializer(options.serializer || globals.serializer),\n        timeout: this.checkTimeoutValue(options.timeout || globals.timeout),\n        followRedirect: this.checkFollowRedirectValue(options.followRedirect || globals.followRedirect),\n        headers: this.checkHeadersObject(options.headers || {}),\n        params: this.checkParamsObject(options.params || {}),\n        data: jsUtil.getTypeOf(options.data) === 'Undefined' ? null : options.data,\n        filePath: options.filePath || '',\n        name: options.name || ''\n      };\n    }\n\n  }\n\n  helpers.validSerializers = ['urlencoded', 'json', 'utf8'];\n  helpers.validHttpMethods = ['get', 'put', 'post', 'patch', 'head', 'delete', 'upload', 'download'];\n  helpers.validResponseTypes = ['text', 'arraybuffer', 'blob'];\n  return helpers;\n})();\nlet globalConfigs = /*#__PURE__*/(() => {\n  class globalConfigs {}\n\n  globalConfigs.headers = {};\n  globalConfigs.serializer = 'urlencoded';\n  globalConfigs.followRedirect = true;\n  globalConfigs.timeout = 60.0;\n  return globalConfigs;\n})();\n\nclass http {\n  static sendRequest(url, options, success, failure) {\n    helpers.handleMissingCallbacks(success, failure);\n    options = helpers.handleMissingOptions(options, globalConfigs);\n    var headers = helpers.getMergedHeaders(url, options.headers, globalConfigs.headers);\n\n    switch (options.method) {\n      case 'post':\n      case 'put':\n      case 'patch':\n        var data = helpers.getProcessedData(options.data, options.serializer);\n        return cordova.exec(success, failure, 'IonicHttp', options.method, [url, data, options.serializer, headers, options.timeout, options.followRedirect, options.responseType]);\n\n      default:\n        return cordova.exec(success, failure, 'IonicHttp', options.method, [url, headers, options.timeout, options.followRedirect, options.responseType]);\n    }\n  }\n\n  static post(url, data, headers, success, failure) {\n    return http.sendRequest(url, {\n      method: 'post',\n      data: data,\n      headers: headers\n    }, success, failure);\n  }\n\n  static get(url, success, failure) {\n    return http.sendRequest(url, {\n      method: 'get',\n      params: {},\n      headers: {}\n    }, success, failure);\n  }\n\n  static put(url, data, headers, success, failure) {\n    return http.sendRequest(url, {\n      method: 'put',\n      data: data,\n      headers: headers\n    }, success, failure);\n  }\n\n  static patch(url, data, headers, success, failure) {\n    return http.sendRequest(url, {\n      method: 'patch',\n      data: data,\n      headers: headers\n    }, success, failure);\n  }\n\n  static del(url, params, headers, success, failure) {\n    return http.sendRequest(url, {\n      method: 'delete',\n      params: params,\n      headers: headers\n    }, success, failure);\n  }\n\n  static head(url, params, headers, success, failure) {\n    return http.sendRequest(url, {\n      method: 'head',\n      params: params,\n      headers: headers\n    }, success, failure);\n  }\n\n}\n\nlet UrlHelper = /*#__PURE__*/(() => {\n  class UrlHelper {\n    static buildUrl(url, options) {\n      const params = new URLSearchParams(options);\n      const urlObj = new URL(url);\n      params.forEach((val, key) => urlObj.searchParams.append(key, val));\n      logging.debug(urlObj.href, this.logTag, 'buildUrl: ');\n      return new UrlInfo(urlObj.href);\n    }\n\n    static parseHash(urlHash) {\n      let params = {};\n      let queries;\n      let temp;\n      let i;\n      let l;\n\n      if (urlHash[0] === '#') {\n        urlHash = urlHash.slice(1);\n      } // Split into key/value pairs\n\n\n      queries = urlHash.split('&'); // Convert the array of strings into an object\n\n      for (i = 0, l = queries.length; i < l; i++) {\n        temp = queries[i].split('=');\n        params[temp[0]] = temp[1];\n      }\n\n      return params;\n    }\n\n    static post(url, data, headers) {\n      logging.debug('UrlHelper::Post');\n      return new Promise((resolve, reject) => {\n        return http.post(url, data, headers, resolve, reject);\n      });\n    }\n\n    static get(url) {\n      logging.debug('UrlHelper::Post');\n      return new Promise(function (resolve, reject) {\n        return http.get(url, resolve, reject);\n      });\n    }\n\n  }\n\n  UrlHelper.logTag = 'UrlHelper: ';\n  return UrlHelper;\n})();\n\nclass BaseStorage {\n  constructor() {\n    this.accessTokenKey = '_ionicAuth.accessToken';\n    this.refreshTokenKey = '_ionicAuth.refreshToken';\n    this.idTokenKey = '_ionicAuth.idToken';\n    this.authResponseKey = '_ionicAuth.authResponse';\n  }\n\n  setClientId(clientId) {\n    this.accessTokenKey = this.accessTokenKey + '.' + clientId;\n    this.refreshTokenKey = this.refreshTokenKey + '.' + clientId;\n    this.idTokenKey = this.idTokenKey + '.' + clientId;\n    this.authResponseKey = this.authResponseKey + '.' + clientId;\n  } // some keys need to be store per token, helper to ensure consistency\n\n\n  formatKeyForToken(keyName, tokenName) {\n    return tokenName ? this.accessTokenKey + '.' + tokenName : this.accessTokenKey;\n  }\n\n}\n\nconst isTokenStorageProvider = obj => {\n  const provider = obj;\n  return typeof provider === 'object' && provider.getAccessToken && typeof provider.getAccessToken === 'function' || provider.getAuthResponse && typeof provider.getAuthResponse === 'function' || provider.getIdToken && typeof provider.getIdToken === 'function' || provider.getRefreshToken && typeof provider.getRefreshToken === 'function' || provider.setAccessToken && typeof provider.setAccessToken === 'function' || provider.setAuthResponse && typeof provider.setAuthResponse === 'function' || provider.setIdToken && typeof provider.setIdToken === 'function' || provider.setRefreshToken && typeof provider.setRefreshToken === 'function' || false;\n};\n\nconst isIV5UserInterface = obj => {\n  const provider = obj;\n  return provider.getValue && typeof provider.getValue === 'function' && provider.setValue && typeof provider.setValue === 'function' && provider.clear && typeof provider.clear === 'function' && provider.onLock && typeof provider.onLock === 'function';\n};\n\nclass AuthIdentityVault5Storage extends BaseStorage {\n  constructor(vault) {\n    super();\n    this.vault = vault;\n  }\n  /**\n   * get the saved access token\n   */\n\n\n  getAccessToken(tokenName) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const key = _this.formatKeyForToken(_this.accessTokenKey, tokenName);\n\n      logging.debug('getAccessToken key:', key);\n      return (_a = yield _this.vault.getValue(key)) !== null && _a !== void 0 ? _a : undefined;\n    })();\n  }\n  /**\n   * save the access token\n   */\n\n\n  setAccessToken(accessToken, tokenName) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this2.formatKeyForToken(_this2.accessTokenKey, tokenName);\n\n      logging.debug('setAccessToken: key: ', key);\n      return _this2.vault.setValue(key, accessToken);\n    })();\n  }\n  /**\n   * get the saved refresh token\n   */\n\n\n  getRefreshToken() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = yield _this3.vault.getValue(_this3.refreshTokenKey)) !== null && _a !== void 0 ? _a : undefined;\n    })();\n  }\n  /**\n   * save the refresh token\n   */\n\n\n  setRefreshToken(refreshToken) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this4.vault.setValue(_this4.refreshTokenKey, refreshToken);\n    })();\n  }\n  /**\n   * get the id token\n   */\n\n\n  getIdToken() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = yield _this5.vault.getValue(_this5.idTokenKey)) !== null && _a !== void 0 ? _a : undefined;\n    })();\n  }\n  /**\n   * save the id token\n   */\n\n\n  setIdToken(idToken) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this6.vault.setValue(_this6.idTokenKey, idToken);\n    })();\n  }\n  /**\n   * get the full auth result\n   */\n\n\n  getAuthResponse() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this7.vault.getValue(_this7.authResponseKey);\n    })();\n  }\n  /**\n   * save the full auth response\n   */\n\n\n  setAuthResponse(response) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this8.vault.setValue(_this8.authResponseKey, response);\n    })();\n  }\n\n  clear() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this9.vault.clear();\n    })();\n  }\n\n  onLock(callback) {\n    this.vault.onLock(callback);\n  }\n\n}\n\nclass AuthIdentityVaultStorage extends BaseStorage {\n  constructor(iv) {\n    super();\n    this.iv = iv;\n  }\n\n  ensureVaultConfigured(setPasscodeIfNeeded) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this10.iv.getVault();\n      const ivConfig = yield vault.getConfig();\n\n      if (ivConfig.isPasscodeSetupNeeded && setPasscodeIfNeeded) {\n        yield _this10.iv.setPasscode();\n      }\n\n      return vault;\n    })();\n  }\n  /**\n   * get the saved access token\n   */\n\n\n  getAccessToken(tokenName) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this11.formatKeyForToken(_this11.accessTokenKey, tokenName);\n\n      logging.debug('getAccessToken: key: ', key);\n      const vault = yield _this11.ensureVaultConfigured(false);\n      return vault.getValue(key);\n    })();\n  }\n  /**\n   * save the access token\n   */\n\n\n  setAccessToken(accessToken, tokenName) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this12.formatKeyForToken(_this12.accessTokenKey, tokenName);\n\n      logging.debug('setAccessToken: key: ', key);\n      const vault = yield _this12.ensureVaultConfigured(true);\n      return vault.storeValue(key, accessToken);\n    })();\n  }\n  /**\n   * get the saved refresh token\n   */\n\n\n  getRefreshToken() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this13.ensureVaultConfigured(false);\n      return vault.getValue(_this13.refreshTokenKey);\n    })();\n  }\n  /**\n   * save the refresh token\n   */\n\n\n  setRefreshToken(refreshToken) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this14.ensureVaultConfigured(true);\n      return vault.storeValue(_this14.refreshTokenKey, refreshToken);\n    })();\n  }\n  /**\n   * get the id token\n   */\n\n\n  getIdToken() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this15.ensureVaultConfigured(false);\n      return vault.getValue(_this15.idTokenKey);\n    })();\n  }\n  /**\n   * save the id token\n   */\n\n\n  setIdToken(idToken) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this16.ensureVaultConfigured(true);\n      return vault.storeValue(_this16.idTokenKey, idToken);\n    })();\n  }\n  /**\n   * get the full auth result\n   */\n\n\n  getAuthResponse() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this17.ensureVaultConfigured(false);\n      return vault.getValue(_this17.authResponseKey);\n    })();\n  }\n  /**\n   * save the full auth response\n   */\n\n\n  setAuthResponse(response) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this18.ensureVaultConfigured(true);\n      return vault.storeValue(_this18.authResponseKey, response);\n    })();\n  }\n\n  clear() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      const vault = yield _this19.iv.getVault();\n      return vault.clear();\n    })();\n  }\n\n}\n\nclass AuthLocalStorage extends BaseStorage {\n  /**\n   * get the saved access token\n   */\n  getAccessToken(tokenName) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this20.formatKeyForToken(_this20.accessTokenKey, tokenName);\n\n      const accessToken = localStorage.getItem(key);\n      return accessToken || undefined;\n    })();\n  }\n  /**\n   * save the access token\n   */\n\n\n  setAccessToken(accessToken, tokenName) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this21.formatKeyForToken(_this21.accessTokenKey, tokenName);\n\n      return localStorage.setItem(key, accessToken);\n    })();\n  }\n  /**\n   * get the saved refresh token\n   */\n\n\n  getRefreshToken() {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      const refreshToken = localStorage.getItem(_this22.refreshTokenKey);\n      return refreshToken || undefined;\n    })();\n  }\n  /**\n   * save the refresh token\n   */\n\n\n  setRefreshToken(refreshToken) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      return localStorage.setItem(_this23.refreshTokenKey, refreshToken);\n    })();\n  }\n  /**\n   * get the id token\n   */\n\n\n  getIdToken() {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      const idToken = localStorage.getItem(_this24.idTokenKey);\n      return idToken || undefined;\n    })();\n  }\n  /**\n   * save the id token\n   */\n\n\n  setIdToken(idToken) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      return localStorage.setItem(_this25.idTokenKey, idToken);\n    })();\n  }\n  /**\n   * get the full auth result\n   */\n\n\n  getAuthResponse() {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      const authResponseString = localStorage.getItem(_this26.authResponseKey);\n\n      if (authResponseString) {\n        try {\n          return JSON.parse(authResponseString);\n        } catch (e) {\n          logging.error(`auth response of ${authResponseString} is not valid json`);\n        }\n      }\n    })();\n  }\n  /**\n   * save the full auth response\n   */\n\n\n  setAuthResponse(response) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const authRespString = JSON.stringify(response);\n        return localStorage.setItem(_this27.authResponseKey, authRespString);\n      } catch (e) {}\n    })();\n  }\n\n  clear() {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      localStorage.removeItem(_this28.accessTokenKey);\n      localStorage.removeItem(_this28.refreshTokenKey);\n      localStorage.removeItem(_this28.idTokenKey);\n      localStorage.removeItem(_this28.authResponseKey);\n    })();\n  }\n\n}\n\nclass SessionHelper {\n  constructor(clientId, storage) {\n    this.authDataKey = 'ionicauth.authdata';\n    this.expiresAtKey = 'ionicauth.expiresAt';\n    this.nonceKey = 'ionicauth.nonce';\n    this.tokenScopes = 'ionicauth.scopes';\n    this.overrideUrlKey = 'ionicauth.overrideUrl';\n    this.expiresAtKeys = [];\n    this.tokenScopesKeys = [];\n    this.authDataKey = clientId + '.' + this.authDataKey;\n    this.expiresAtKey = clientId + '.' + this.expiresAtKey;\n    this.nonceKey = clientId + '.' + this.nonceKey;\n    this.overrideUrlKey = clientId + '.' + this.overrideUrlKey;\n    this.tokenScopes = clientId + '.' + this.tokenScopes;\n    this.storage = storage;\n  }\n\n  getAuthData() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      const dataKey = yield _this29.storage.get(_this29.authDataKey);\n\n      if (dataKey) {\n        const session = JSON.parse(dataKey);\n        return session;\n      } else {\n        return undefined;\n      }\n    })();\n  }\n\n  setAuthData(session) {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this30.storage.set(_this30.authDataKey, JSON.stringify(session));\n    })();\n  }\n\n  setOverrideUrl(url) {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this31.storage.set(_this31.overrideUrlKey, url);\n    })();\n  }\n\n  getOverrideUrl() {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      const overrideUrl = yield _this32.storage.get(_this32.overrideUrlKey);\n      return overrideUrl ? overrideUrl : undefined;\n    })();\n  }\n\n  clearOverrideUrl() {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this33.storage.remove(_this33.overrideUrlKey);\n    })();\n  }\n\n  clearAuthData() {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this34.storage.remove(_this34.authDataKey);\n    })();\n  }\n\n  getExpiresAt(tokenName) {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      let expiresAtKeyName = _this35.expiresAtKey;\n\n      if (tokenName) {\n        expiresAtKeyName = _this35.expiresAtKey + '.' + tokenName;\n      }\n\n      const expiresAtKey = yield _this35.storage.get(expiresAtKeyName);\n\n      if (expiresAtKey) {\n        const expiresAt = JSON.parse(expiresAtKey);\n        return expiresAt;\n      }\n\n      return undefined;\n    })();\n  }\n\n  setExpiresAt(expiresAt, tokenName) {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      let expiresAtKey = _this36.expiresAtKey;\n\n      if (tokenName) {\n        expiresAtKey = _this36.expiresAtKey + '.' + tokenName;\n\n        _this36.tokenScopesKeys.push(expiresAtKey);\n      }\n\n      logging.debug('setExpiresAt', 'expiresAtKey', expiresAtKey);\n      yield _this36.storage.set(expiresAtKey, JSON.stringify(expiresAt));\n    })();\n  }\n\n  getTokenScopes(tokenName) {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      let tokenScopesKey = _this37.tokenScopes + '.' + tokenName;\n      logging.debug('getTokenScopes', 'tokenScopes', tokenScopesKey);\n      const tokenScopes = yield _this37.storage.get(tokenScopesKey);\n\n      if (tokenScopes) {\n        const expiresAt = JSON.parse(tokenScopes);\n        return expiresAt;\n      }\n\n      return undefined;\n    })();\n  }\n\n  setTokenScopes(scopes, tokenName) {\n    var _this38 = this;\n\n    return _asyncToGenerator(function* () {\n      let tokenScopesKey = _this38.tokenScopes + '.' + tokenName;\n\n      _this38.tokenScopesKeys.push(tokenScopesKey);\n\n      logging.debug('setTokenScopes', 'tokenScopes', tokenScopesKey);\n      yield _this38.storage.set(tokenScopesKey, JSON.stringify(scopes));\n    })();\n  }\n\n  clearTokenScopes() {\n    var _this39 = this;\n\n    return _asyncToGenerator(function* () {\n      _this39.tokenScopesKeys.forEach( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (key) {\n          yield _this39.storage.remove(key);\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  clearExpiresAt() {\n    var _this40 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this40.storage.remove(_this40.expiresAtKey);\n\n      _this40.expiresAtKeys.forEach( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (key) {\n          yield _this40.storage.remove(key);\n        });\n\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  getNonce() {\n    var _this41 = this;\n\n    return _asyncToGenerator(function* () {\n      const nonceKey = yield _this41.storage.get(_this41.nonceKey);\n\n      if (nonceKey) {\n        const nonce = JSON.parse(nonceKey);\n        return nonce;\n      }\n\n      return undefined;\n    })();\n  }\n\n  setNonce(nonce) {\n    var _this42 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this42.storage.set(_this42.nonceKey, JSON.stringify(nonce));\n    })();\n  }\n\n  clearNonce() {\n    var _this43 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this43.storage.remove(_this43.nonceKey);\n    })();\n  }\n\n  clear() {\n    var _this44 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this44.clearAuthData();\n      yield _this44.clearExpiresAt();\n      yield _this44.clearNonce();\n      yield _this44.clearTokenScopes();\n    })();\n  }\n\n}\n\nvar toByteArray_1 = toByteArray;\nvar fromByteArray_1 = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}\n\nconst generateChallengeAndVerifier = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (useBase64String = false) {\n    const verifierPlain = getRandomCharacters(128, useBase64String);\n    const verifierHashArray = yield sha256(verifierPlain);\n    const challenge = base64Encode(verifierHashArray);\n    logging.debug('challenge: ' + challenge);\n    return {\n      verifier: verifierPlain,\n      challenge\n    };\n  });\n\n  return function generateChallengeAndVerifier() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst getRandomNonce = () => {\n  return getRandomCharacters(20);\n};\n\nconst bufferToString = arrayBuffer => {\n  const coder = new TextDecoder();\n  return coder.decode(arrayBuffer);\n};\n\nconst parseJwt = token => {\n  const parts = token.split('.');\n  const headerString = base64Decode(parts[0]);\n  const payloadString = base64Decode(parts[1]);\n  const header = JSON.parse(headerString);\n  const payload = JSON.parse(payloadString);\n  return {\n    header,\n    payload\n  };\n};\n\nconst base64Encode = byteArray => {\n  const base64String = fromByteArray_1(byteArray);\n  const urlString = escapeUrl(base64String);\n  return urlString;\n};\n\nconst base64Decode = encodedString => {\n  const unescapedString = unescapeUrl(encodedString);\n  const byteArray = toByteArray_1(unescapedString);\n  const string = bufferToString(byteArray);\n  return string;\n};\n\nconst escapeUrl = baseString => {\n  return baseString.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n};\n\nconst unescapeUrl = baseString => {\n  let newString = baseString.replace(/\\-/g, '+').replace(/_/g, '/'); // .replace(/\\-/g, \"+\")\n  // .replace(/_/g, \"/\");\n\n  while (newString.length % 4 !== 0) {\n    newString += '=';\n  }\n\n  return newString;\n};\n/**\n *  Secure Hash Algorithm (SHA256)\n *  http://www.webtoolkit.info/\n *  Original code by Angel Marin, Paul Johnston.\n **/\n\n\nconst sha256 = /*#__PURE__*/function () {\n  var _sha = _asyncToGenerator(function* (s) {\n    var chrsz = 8;\n\n    function safe_add(x, y) {\n      var lsw = (x & 0xffff) + (y & 0xffff);\n      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n      return msw << 16 | lsw & 0xffff;\n    }\n\n    function S(X, n) {\n      return X >>> n | X << 32 - n;\n    }\n\n    function R(X, n) {\n      return X >>> n;\n    }\n\n    function Ch(x, y, z) {\n      return x & y ^ ~x & z;\n    }\n\n    function Maj(x, y, z) {\n      return x & y ^ x & z ^ y & z;\n    }\n\n    function Sigma0256(x) {\n      return S(x, 2) ^ S(x, 13) ^ S(x, 22);\n    }\n\n    function Sigma1256(x) {\n      return S(x, 6) ^ S(x, 11) ^ S(x, 25);\n    }\n\n    function Gamma0256(x) {\n      return S(x, 7) ^ S(x, 18) ^ R(x, 3);\n    }\n\n    function Gamma1256(x) {\n      return S(x, 17) ^ S(x, 19) ^ R(x, 10);\n    }\n\n    function core_sha256(m, l) {\n      var K = new Array(0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2);\n      var HASH = new Array(0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19);\n      var W = new Array(64);\n      var a, b, c, d, e, f, g, h;\n      var T1, T2;\n      m[l >> 5] |= 0x80 << 24 - l % 32;\n      m[(l + 64 >> 9 << 4) + 15] = l;\n\n      for (var i = 0; i < m.length; i += 16) {\n        a = HASH[0];\n        b = HASH[1];\n        c = HASH[2];\n        d = HASH[3];\n        e = HASH[4];\n        f = HASH[5];\n        g = HASH[6];\n        h = HASH[7];\n\n        for (var j = 0; j < 64; j++) {\n          if (j < 16) W[j] = m[j + i];else W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n          T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n          T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n          h = g;\n          g = f;\n          f = e;\n          e = safe_add(d, T1);\n          d = c;\n          c = b;\n          b = a;\n          a = safe_add(T1, T2);\n        }\n\n        HASH[0] = safe_add(a, HASH[0]);\n        HASH[1] = safe_add(b, HASH[1]);\n        HASH[2] = safe_add(c, HASH[2]);\n        HASH[3] = safe_add(d, HASH[3]);\n        HASH[4] = safe_add(e, HASH[4]);\n        HASH[5] = safe_add(f, HASH[5]);\n        HASH[6] = safe_add(g, HASH[6]);\n        HASH[7] = safe_add(h, HASH[7]);\n      }\n\n      return HASH;\n    }\n\n    function str2binb(str) {\n      var bin = Array();\n      var mask = (1 << chrsz) - 1;\n\n      for (var i = 0; i < str.length * chrsz; i += chrsz) {\n        bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << 24 - i % 32;\n      }\n\n      return bin;\n    }\n\n    function Utf8Encode(string) {\n      string = string.replace(/\\r\\n/g, '\\n');\n      var utftext = '';\n\n      for (var n = 0; n < string.length; n++) {\n        var c = string.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        } else if (c > 127 && c < 2048) {\n          utftext += String.fromCharCode(c >> 6 | 192);\n          utftext += String.fromCharCode(c & 63 | 128);\n        } else {\n          utftext += String.fromCharCode(c >> 12 | 224);\n          utftext += String.fromCharCode(c >> 6 & 63 | 128);\n          utftext += String.fromCharCode(c & 63 | 128);\n        }\n      }\n\n      return utftext;\n    }\n\n    function binb2hex(binarray) {\n      var hex_tab = '0123456789abcdef';\n      var str = '';\n\n      for (var i = 0; i < binarray.length * 4; i++) {\n        str += hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 + 4 & 0xf) + hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 & 0xf);\n      }\n\n      return str;\n    }\n\n    function hex2uint8(string) {\n      var bytes = new Uint8Array(Math.ceil(string.length / 2));\n\n      for (var i = 0; i < bytes.length; i++) bytes[i] = parseInt(string.substr(i * 2, 2), 16);\n\n      return bytes;\n    }\n\n    s = Utf8Encode(s);\n    return hex2uint8(binb2hex(core_sha256(str2binb(s), s.length * chrsz)));\n  });\n\n  function sha256(_x3) {\n    return _sha.apply(this, arguments);\n  }\n\n  return sha256;\n}();\n\nconst getRandomCharacters = (length, useBase64String = false) => {\n  const values = useBase64String ? 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n  const array = new Array();\n\n  for (let i = 0; i < length; i++) {\n    array.push(values.charAt(Math.floor(Math.random() * values.length)));\n  }\n\n  return array.join('');\n};\n\nconst ready$1 = new Promise(resolve => {\n  const DEVICE_READY_TIMEOUT = 5000;\n  const readyTimeout = setTimeout(() => {\n    console.warn(`Auth Connect: deviceready did not fire within ${DEVICE_READY_TIMEOUT}ms.`);\n    resolve();\n  }, DEVICE_READY_TIMEOUT);\n  document.addEventListener('deviceready', () => {\n    clearTimeout(readyTimeout);\n    resolve();\n  });\n});\n/**\n * @hidden\n */\n\nclass IonicAuthConfig {\n  constructor(options) {\n    this.options = options;\n    this.logTag = 'IonicAuthConfig';\n    this.defaultDiscoveryUrl = '';\n    this.overrideDiscoveryUrl = '';\n    this.currentDiscoveryUrl = '';\n    this.locations = undefined;\n    logging.setLogLevel(options.logLevel);\n    this.logger = logging;\n  }\n\n  generateChallengeAndVerifier() {\n    return generateChallengeAndVerifier();\n  }\n\n  validateLocations() {\n    if (this.locations === undefined) {\n      this.logger.debug(this.logTag, 'locations undefined');\n      return false;\n    } // we have locations loaded are they the right ones? yep, unless we have an override\n\n\n    if (this.overrideDiscoveryUrl === undefined || this.overrideDiscoveryUrl === '') {\n      this.logger.debug(this.logTag, 'override discovery url empty or null');\n      return true;\n    }\n\n    this.logger.debug(this.logTag, 'override discovery url: ', this.overrideDiscoveryUrl); // does the current equal the override?\n\n    if (this.overrideDiscoveryUrl !== this.currentDiscoveryUrl) {\n      this.logger.debug(this.logTag, 'override not eq current discovery url');\n      return false;\n    }\n\n    this.logger.debug(this.logTag, 'all ok?');\n    return true;\n  }\n\n  loadLocations() {\n    var _this45 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this45.validateLocations()) {\n        return;\n      }\n\n      _this45.currentDiscoveryUrl = _this45.overrideDiscoveryUrl;\n\n      if (_this45.currentDiscoveryUrl === '') {\n        _this45.currentDiscoveryUrl = _this45.options.discoveryUrl || _this45.defaultDiscoveryUrl;\n      }\n\n      _this45.logger.debug(_this45.logTag, 'discoveryUrl: ', _this45.currentDiscoveryUrl);\n\n      if (_this45.options.platform === 'cordova' || _this45.options.platform === 'capacitor') {\n        // validate?\n        yield ready$1;\n\n        try {\n          const result = yield UrlHelper.get(_this45.currentDiscoveryUrl);\n\n          _this45.logger.debug(_this45.logTag, 'result.data: ', result);\n\n          _this45.locations = JSON.parse(result.data);\n        } catch (err) {\n          throw new Error(err.error);\n        }\n      } else {\n        const resp = yield fetch(_this45.currentDiscoveryUrl);\n        _this45.locations = yield resp.json(); // Transform the data into json\n\n        _this45.logger.debug(_this45.logTag, 'locations resp: ', _this45.locations);\n      }\n    })();\n  }\n\n  getIssuer() {\n    var _this46 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this46.loadLocations();\n      return _this46.locations['issuer'];\n    })();\n  }\n\n}\n/** Detect free variable `global` from Node.js. */\n\n\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\nvar freeGlobal$1 = freeGlobal;\n/** Detect free variable `self`. */\n\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal$1 || freeSelf || Function('return this')();\nvar root$1 = root;\n/** Built-in value references. */\n\nvar Symbol = root$1.Symbol;\nvar Symbol$1 = Symbol;\n/** Used for built-in method references. */\n\nvar objectProto$1 = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto$1.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar nativeObjectToString$1 = objectProto$1.toString;\n/** Built-in value references. */\n\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\n\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString$1.call(value);\n\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n\n  return result;\n}\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar nativeObjectToString = objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\n\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n/** `Object#toString` result references. */\n\n\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n/** Built-in value references. */\n\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\n\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n/** `Object#toString` result references. */\n\n\nvar symbolTag = '[object Symbol]';\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\nfunction isSymbol(value) {\n  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n}\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\n\n\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n\n  return result;\n}\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\n\n\nvar isArray = Array.isArray;\nvar isArray$1 = isArray;\n/** Used as references for various `Number` constants. */\n\nvar INFINITY = 1 / 0;\n/** Used to convert symbols to primitives and strings. */\n\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\n\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n\n  if (isArray$1(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\n\n\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n\n  return accumulator;\n}\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\n\n\nfunction basePropertyOf(object) {\n  return function (key) {\n    return object == null ? undefined : object[key];\n  };\n}\n/** Used to map Latin Unicode letters to basic Latin letters. */\n\n\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',\n  '\\xc1': 'A',\n  '\\xc2': 'A',\n  '\\xc3': 'A',\n  '\\xc4': 'A',\n  '\\xc5': 'A',\n  '\\xe0': 'a',\n  '\\xe1': 'a',\n  '\\xe2': 'a',\n  '\\xe3': 'a',\n  '\\xe4': 'a',\n  '\\xe5': 'a',\n  '\\xc7': 'C',\n  '\\xe7': 'c',\n  '\\xd0': 'D',\n  '\\xf0': 'd',\n  '\\xc8': 'E',\n  '\\xc9': 'E',\n  '\\xca': 'E',\n  '\\xcb': 'E',\n  '\\xe8': 'e',\n  '\\xe9': 'e',\n  '\\xea': 'e',\n  '\\xeb': 'e',\n  '\\xcc': 'I',\n  '\\xcd': 'I',\n  '\\xce': 'I',\n  '\\xcf': 'I',\n  '\\xec': 'i',\n  '\\xed': 'i',\n  '\\xee': 'i',\n  '\\xef': 'i',\n  '\\xd1': 'N',\n  '\\xf1': 'n',\n  '\\xd2': 'O',\n  '\\xd3': 'O',\n  '\\xd4': 'O',\n  '\\xd5': 'O',\n  '\\xd6': 'O',\n  '\\xd8': 'O',\n  '\\xf2': 'o',\n  '\\xf3': 'o',\n  '\\xf4': 'o',\n  '\\xf5': 'o',\n  '\\xf6': 'o',\n  '\\xf8': 'o',\n  '\\xd9': 'U',\n  '\\xda': 'U',\n  '\\xdb': 'U',\n  '\\xdc': 'U',\n  '\\xf9': 'u',\n  '\\xfa': 'u',\n  '\\xfb': 'u',\n  '\\xfc': 'u',\n  '\\xdd': 'Y',\n  '\\xfd': 'y',\n  '\\xff': 'y',\n  '\\xc6': 'Ae',\n  '\\xe6': 'ae',\n  '\\xde': 'Th',\n  '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',\n  '\\u0102': 'A',\n  '\\u0104': 'A',\n  '\\u0101': 'a',\n  '\\u0103': 'a',\n  '\\u0105': 'a',\n  '\\u0106': 'C',\n  '\\u0108': 'C',\n  '\\u010a': 'C',\n  '\\u010c': 'C',\n  '\\u0107': 'c',\n  '\\u0109': 'c',\n  '\\u010b': 'c',\n  '\\u010d': 'c',\n  '\\u010e': 'D',\n  '\\u0110': 'D',\n  '\\u010f': 'd',\n  '\\u0111': 'd',\n  '\\u0112': 'E',\n  '\\u0114': 'E',\n  '\\u0116': 'E',\n  '\\u0118': 'E',\n  '\\u011a': 'E',\n  '\\u0113': 'e',\n  '\\u0115': 'e',\n  '\\u0117': 'e',\n  '\\u0119': 'e',\n  '\\u011b': 'e',\n  '\\u011c': 'G',\n  '\\u011e': 'G',\n  '\\u0120': 'G',\n  '\\u0122': 'G',\n  '\\u011d': 'g',\n  '\\u011f': 'g',\n  '\\u0121': 'g',\n  '\\u0123': 'g',\n  '\\u0124': 'H',\n  '\\u0126': 'H',\n  '\\u0125': 'h',\n  '\\u0127': 'h',\n  '\\u0128': 'I',\n  '\\u012a': 'I',\n  '\\u012c': 'I',\n  '\\u012e': 'I',\n  '\\u0130': 'I',\n  '\\u0129': 'i',\n  '\\u012b': 'i',\n  '\\u012d': 'i',\n  '\\u012f': 'i',\n  '\\u0131': 'i',\n  '\\u0134': 'J',\n  '\\u0135': 'j',\n  '\\u0136': 'K',\n  '\\u0137': 'k',\n  '\\u0138': 'k',\n  '\\u0139': 'L',\n  '\\u013b': 'L',\n  '\\u013d': 'L',\n  '\\u013f': 'L',\n  '\\u0141': 'L',\n  '\\u013a': 'l',\n  '\\u013c': 'l',\n  '\\u013e': 'l',\n  '\\u0140': 'l',\n  '\\u0142': 'l',\n  '\\u0143': 'N',\n  '\\u0145': 'N',\n  '\\u0147': 'N',\n  '\\u014a': 'N',\n  '\\u0144': 'n',\n  '\\u0146': 'n',\n  '\\u0148': 'n',\n  '\\u014b': 'n',\n  '\\u014c': 'O',\n  '\\u014e': 'O',\n  '\\u0150': 'O',\n  '\\u014d': 'o',\n  '\\u014f': 'o',\n  '\\u0151': 'o',\n  '\\u0154': 'R',\n  '\\u0156': 'R',\n  '\\u0158': 'R',\n  '\\u0155': 'r',\n  '\\u0157': 'r',\n  '\\u0159': 'r',\n  '\\u015a': 'S',\n  '\\u015c': 'S',\n  '\\u015e': 'S',\n  '\\u0160': 'S',\n  '\\u015b': 's',\n  '\\u015d': 's',\n  '\\u015f': 's',\n  '\\u0161': 's',\n  '\\u0162': 'T',\n  '\\u0164': 'T',\n  '\\u0166': 'T',\n  '\\u0163': 't',\n  '\\u0165': 't',\n  '\\u0167': 't',\n  '\\u0168': 'U',\n  '\\u016a': 'U',\n  '\\u016c': 'U',\n  '\\u016e': 'U',\n  '\\u0170': 'U',\n  '\\u0172': 'U',\n  '\\u0169': 'u',\n  '\\u016b': 'u',\n  '\\u016d': 'u',\n  '\\u016f': 'u',\n  '\\u0171': 'u',\n  '\\u0173': 'u',\n  '\\u0174': 'W',\n  '\\u0175': 'w',\n  '\\u0176': 'Y',\n  '\\u0177': 'y',\n  '\\u0178': 'Y',\n  '\\u0179': 'Z',\n  '\\u017b': 'Z',\n  '\\u017d': 'Z',\n  '\\u017a': 'z',\n  '\\u017c': 'z',\n  '\\u017e': 'z',\n  '\\u0132': 'IJ',\n  '\\u0133': 'ij',\n  '\\u0152': 'Oe',\n  '\\u0153': 'oe',\n  '\\u0149': \"'n\",\n  '\\u017f': 's'\n};\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\n\nvar deburrLetter = basePropertyOf(deburredLetters);\nvar deburrLetter$1 = deburrLetter;\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\n\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n/** Used to compose unicode character classes. */\n\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff',\n    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\n/** Used to compose unicode capture groups. */\n\nvar rsCombo$1 = '[' + rsComboRange$1 + ']';\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\n\nvar reComboMark = RegExp(rsCombo$1, 'g');\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('déjà vu');\n * // => 'deja vu'\n */\n\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, '');\n}\n/** Used to match words composed of alphanumeric characters. */\n\n\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\n\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n/** Used to detect strings that need a more robust regexp to match words. */\n\n\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\n\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n/** Used to compose unicode character classes. */\n\n\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n/** Used to compose unicode capture groups. */\n\nvar rsApos$1 = \"['\\u2019]\",\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nvar rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n    rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;\n/** Used to match complex or compound words. */\n\nvar reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\n\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\n\n\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = guard ? undefined : pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n\n  return string.match(pattern) || [];\n}\n/** Used to compose unicode capture groups. */\n\n\nvar rsApos = \"['\\u2019]\";\n/** Used to match apostrophes. */\n\nvar reApos = RegExp(rsApos, 'g');\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\n\nfunction createCompounder(callback) {\n  return function (string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n/**\n * Converts `string` to\n * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the snake cased string.\n * @example\n *\n * _.snakeCase('Foo Bar');\n * // => 'foo_bar'\n *\n * _.snakeCase('fooBar');\n * // => 'foo_bar'\n *\n * _.snakeCase('--FOO-BAR--');\n * // => 'foo_bar'\n */\n\n\nvar snakeCase = createCompounder(function (result, word, index) {\n  return result + (index ? '_' : '') + word.toLowerCase();\n});\nvar snakeCase$1 = snakeCase;\nvar validAuthorizationParams = ['acr_values', 'audience', 'claims', 'claims_locales', 'client_id', 'client_secret', 'code_challenge', 'code_challenge_method', 'domain_hint', 'display', 'id_token_hint', 'login_hint', 'logout_uri', 'max_age', 'nonce', 'post_logout_redirect_uri', 'prompt', 'redirect_uri', 'registration', 'request', 'request_uri', 'response_mode', 'response_type', 'return_to', 'scope', 'state', 'ui_locales', 'vtr'];\n\nclass OAuthPacker {\n  static packParams(options) {\n    const validParams = {};\n\n    for (let key in options) {\n      if (!options[key]) continue; // skip null/undefined/empty string values\n\n      const snakedKey = snakeCase$1(key);\n\n      if (validAuthorizationParams.includes(snakedKey)) {\n        validParams[snakedKey] = options[key];\n      } else {\n        logging.debug('OAuthPacker::packParams', 'adding additional param:', key);\n        validParams[key] = options[key];\n      }\n    }\n\n    return validParams;\n  }\n\n}\n\nclass IonicAuth0Config extends IonicAuthConfig {\n  constructor(options) {\n    super(options);\n    this.options = options;\n\n    if (options.discoveryUrl == undefined) {\n      throw \"IonicAuthOptions.discoveryUrl must be defined for Auth0, it usually is 'https://YOUR_DOMAIN/.well-known/openid-configuration'\";\n    }\n  }\n\n  loadLocations() {\n    var _superprop_getLoadLocations = () => super.loadLocations,\n        _this47 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _superprop_getLoadLocations().call(_this47);\n\n      if (_this47.locations['logout_endpoint'] == undefined) {\n        _this47.locations['logout_endpoint'] = _this47.locations['issuer'] + 'logout';\n      }\n    })();\n  }\n\n  getAuthorizeUrl(nonce, challenge, parameters) {\n    var _this48 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this48.loadLocations();\n      const base = Object.assign(Object.assign({}, parameters), {\n        clientId: _this48.options.clientID,\n        redirectUri: _this48.options.redirectUri,\n        audience: _this48.options.audience,\n        nonce: nonce,\n        state: nonce,\n        scope: _this48.options.scope\n      });\n      const PKCE = {\n        code_challenge_method: 'S256',\n        code_challenge: challenge,\n        responseType: 'code'\n      };\n\n      if (_this48.options.platform !== 'web') {\n        const options = Object.assign(Object.assign({}, base), PKCE);\n        return UrlHelper.buildUrl(_this48.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      } else {\n        // web case\n        const webBase = Object.assign(Object.assign({}, base), {\n          client_secret: _this48.options.clientSecret\n        });\n        let options = {};\n\n        if (_this48.options.webAuthFlow && _this48.options.webAuthFlow === 'PKCE') {\n          options = Object.assign(Object.assign({}, webBase), PKCE);\n        } else {\n          options = Object.assign(Object.assign({}, webBase), {\n            response_type: 'id_token token',\n            response_mode: 'fragment'\n          });\n        }\n\n        return UrlHelper.buildUrl(_this48.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      }\n    })();\n  }\n\n  getLogoutUrl() {\n    var _this49 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this49.loadLocations();\n      const options = {\n        clientId: _this49.options.clientID\n      };\n      let params = OAuthPacker.packParams(options);\n      params['returnTo'] = _this49.options.logoutUrl;\n      let logoutUrl = UrlHelper.buildUrl(_this49.locations['logout_endpoint'], params);\n      return logoutUrl;\n    })();\n  }\n\n  getTokenUrl() {\n    var _this50 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this50.loadLocations();\n      return {\n        url: _this50.locations['token_endpoint'],\n        headers: {},\n        payload: {}\n      };\n    })();\n  }\n\n}\n\nclass IonicAzureConfig extends IonicAuthConfig {\n  constructor(options) {\n    super(options);\n    this.options = options;\n    this.defaultDiscoveryUrl = 'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration';\n  }\n\n  getAuthorizeUrl(nonce, challenge, parameters) {\n    var _this51 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this51.loadLocations();\n      const base = Object.assign(Object.assign({}, parameters), {\n        clientId: _this51.options.clientID,\n        redirectUri: _this51.options.redirectUri,\n        audience: _this51.options.audience,\n        nonce: nonce,\n        state: nonce,\n        scope: _this51.options.scope\n      });\n\n      if (_this51.options.platform != 'web') {\n        const options = Object.assign(Object.assign({}, base), {\n          code_challenge_method: 'S256',\n          code_challenge: challenge,\n          responseType: 'code'\n        });\n        return UrlHelper.buildUrl(_this51.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      } else {\n        // web case\n        let options = {};\n\n        if (_this51.options.webAuthFlow && _this51.options.webAuthFlow === 'PKCE') {\n          options = Object.assign(Object.assign({}, base), {\n            code_challenge_method: 'S256',\n            code_challenge: challenge,\n            responseType: 'code'\n          });\n        } else {\n          options = Object.assign(Object.assign({}, base), {\n            response_type: 'id_token token',\n            response_mode: 'fragment',\n            client_secret: _this51.options.clientSecret\n          });\n        }\n\n        return UrlHelper.buildUrl(_this51.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      }\n    })();\n  }\n\n  getLogoutUrl() {\n    var _this52 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this52.loadLocations();\n      const options = {\n        clientId: _this52.options.clientID,\n        returnTo: _this52.options.redirectUri,\n        redirectUri: _this52.options.redirectUri,\n        postLogoutRedirectUri: _this52.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this52.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n  getTokenUrl() {\n    var _this53 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this53.loadLocations();\n      return {\n        url: _this53.locations['token_endpoint'],\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          Accept: 'application/json'\n        },\n        payload: {\n          scope: String(_this53.options.scope)\n        }\n      };\n    })();\n  }\n\n}\n\nclass IonicCognitoConfig extends IonicAuthConfig {\n  constructor(options) {\n    super(options);\n    this.options = options; // validate that client_id and client_secret are set\n\n    if (this.options.discoveryUrl == undefined) {\n      throw \"IonicAuthOptions.discoveryUrl must be defined for Cognito, it usually is 'https://cognito-idp.REGION.amazonaws.com/USER-POOL-ID'\";\n    }\n  }\n\n  loadLocations() {\n    var _superprop_getLoadLocations2 = () => super.loadLocations,\n        _this54 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _superprop_getLoadLocations2().call(_this54);\n\n      if (_this54.locations['logout_endpoint'] == undefined) {\n        const auth_endpoint = _this54.locations['authorization_endpoint'] || '';\n        const url = new URL(auth_endpoint);\n        url.pathname = 'logout';\n        _this54.locations['logout_endpoint'] = url.href;\n      }\n    })();\n  }\n\n  getAuthorizeUrl(nonce, challenge, parameters) {\n    var _this55 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this55.loadLocations();\n      const base = Object.assign(Object.assign({}, parameters), {\n        clientId: _this55.options.clientID,\n        redirectUri: _this55.options.redirectUri,\n        audience: _this55.options.audience,\n        nonce: nonce,\n        state: nonce,\n        scope: _this55.options.scope\n      });\n      const PKCE = Object.assign(Object.assign({}, base), {\n        code_challenge_method: 'S256',\n        code_challenge: challenge,\n        responseType: 'code'\n      });\n\n      if (_this55.options.platform !== 'web') {\n        const options = Object.assign({}, PKCE);\n        return UrlHelper.buildUrl(_this55.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      } else {\n        // web case\n        let options = {};\n\n        if (_this55.options.webAuthFlow && _this55.options.webAuthFlow === 'PKCE') {\n          options = Object.assign({}, PKCE);\n        } else {\n          options = Object.assign(Object.assign({}, base), {\n            response_type: 'token',\n            response_mode: 'fragment'\n          });\n        }\n\n        return UrlHelper.buildUrl(_this55.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      }\n    })();\n  }\n\n  getLogoutUrl() {\n    var _this56 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this56.loadLocations();\n      const options = {\n        clientId: _this56.options.clientID,\n        logoutUri: _this56.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this56.locations['logout_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n  getTokenUrl() {\n    var _this57 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this57.loadLocations();\n      const headers = {};\n\n      if (_this57.options.clientSecret) {\n        const auth_header = base64Encode(new TextEncoder().encode(`${_this57.options.clientID}:${_this57.options.clientSecret}`));\n        headers['Authorization'] = `Basic ${auth_header}`;\n      }\n\n      return {\n        url: _this57.locations['token_endpoint'],\n        headers,\n        payload: {}\n      };\n    })();\n  }\n\n}\n\nclass IonicGeneralAuthConfig extends IonicAuthConfig {\n  constructor(options) {\n    super(options);\n    this.options = options;\n\n    if (options.discoveryUrl == undefined) {\n      throw \"IonicAuthOptions.discoveryUrl must be defined, it usually is 'https://YOUR_DOMAIN/.well-known/openid-configuration'\";\n    }\n  }\n\n  loadLocations() {\n    var _superprop_getLoadLocations3 = () => super.loadLocations,\n        _this58 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _superprop_getLoadLocations3().call(_this58);\n\n      if (_this58.locations['logout_endpoint'] == undefined) {\n        const issuer = _this58.locations['issuer'];\n        _this58.locations['logout_endpoint'] = issuer.endsWith('/') ? `${issuer}logout` : `${issuer}/logout`;\n      }\n    })();\n  }\n\n  getAuthorizeUrl(nonce, challenge, parameters) {\n    var _this59 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this59.loadLocations();\n      const base = Object.assign(Object.assign({}, parameters), {\n        clientId: _this59.options.clientID,\n        redirectUri: _this59.options.redirectUri,\n        audience: _this59.options.audience,\n        nonce: nonce,\n        state: nonce,\n        scope: _this59.options.scope\n      });\n      const PKCE = {\n        code_challenge_method: 'S256',\n        code_challenge: challenge,\n        responseType: 'code'\n      };\n\n      if (_this59.options.platform !== 'web') {\n        const options = Object.assign(Object.assign({}, base), PKCE);\n        return UrlHelper.buildUrl(_this59.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      } else {\n        // web case\n        const webBase = Object.assign(Object.assign({}, base), {\n          client_secret: _this59.options.clientSecret\n        });\n        let options = {};\n\n        if (_this59.options.webAuthFlow && _this59.options.webAuthFlow === 'PKCE') {\n          options = Object.assign(Object.assign({}, webBase), PKCE);\n        } else {\n          options = Object.assign(Object.assign({}, webBase), {\n            response_type: 'id_token token',\n            response_mode: 'fragment'\n          });\n        }\n\n        return UrlHelper.buildUrl(_this59.locations['authorization_endpoint'], OAuthPacker.packParams(options));\n      }\n    })();\n  }\n\n  getLogoutUrl() {\n    var _this60 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this60.loadLocations();\n      const options = {\n        clientId: _this60.options.clientID\n      };\n      let params = OAuthPacker.packParams(options);\n      params['returnTo'] = _this60.options.logoutUrl;\n      let logoutUrl = UrlHelper.buildUrl(_this60.locations['end_session_endpoint'] || _this60.locations['logout_endpoint'], params);\n      return logoutUrl;\n    })();\n  }\n\n  getTokenUrl() {\n    var _this61 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this61.loadLocations();\n      const generalConfig = _this61.options;\n      let payload = {}; // defaults to true\n\n      if (generalConfig.alwaysSendClientSecretOnLogin !== false && !!generalConfig.clientSecret) {\n        payload = {\n          client_secret: generalConfig.clientSecret\n        };\n      }\n\n      return {\n        url: _this61.locations['token_endpoint'],\n        headers: {},\n        payload: payload\n      };\n    })();\n  }\n\n}\n\nclass IonicSalesForceAuthConfig extends IonicGeneralAuthConfig {\n  // The only unique salesforce quirk is that the challenge/verifier can only consist of hexidecimal chars\n  generateChallengeAndVerifier() {\n    return generateChallengeAndVerifier(true);\n  }\n\n  getLogoutUrl() {\n    var _this62 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this62.loadLocations();\n      const options = {\n        clientId: _this62.options.clientID,\n        postLogoutRedirectUri: _this62.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this62.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n\nclass IonicPingAuthConfig extends IonicGeneralAuthConfig {\n  getLogoutUrl() {\n    var _this63 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this63.loadLocations();\n      const options = {\n        clientId: _this63.options.clientID,\n        redirectUri: _this63.options.redirectUri\n      };\n      return UrlHelper.buildUrl(_this63.locations['ping_end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n\nclass IonicOneLoginConfig extends IonicGeneralAuthConfig {\n  constructor(options, onGetRawIdToken) {\n    super(options);\n    this.onGetRawIdToken = onGetRawIdToken;\n  }\n\n  getLogoutUrl() {\n    var _this64 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this64.loadLocations();\n      let token;\n\n      try {\n        token = yield _this64.onGetRawIdToken();\n      } catch (e) {\n        throw new Error(messages.LOGOUT_UNABLE_TO_RETRIEVE_TOKEN);\n      }\n\n      const options = {\n        postLogoutRedirectUri: _this64.options.logoutUrl,\n        idTokenHint: token\n      };\n      return UrlHelper.buildUrl(_this64.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n\nclass IonicOktaAuthConfig extends IonicGeneralAuthConfig {\n  constructor(options, onGetRawIdToken) {\n    super(options);\n    this.onGetRawIdToken = onGetRawIdToken;\n  } // OKTA doesn't have a logout_endpoint in their config, rather they use end_session_endpoint\n\n\n  getLogoutUrl() {\n    var _this65 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this65.loadLocations();\n      let token;\n\n      try {\n        token = yield _this65.onGetRawIdToken();\n      } catch (e) {\n        throw new Error(messages.LOGOUT_UNABLE_TO_RETRIEVE_TOKEN);\n      }\n\n      const options = {\n        idTokenHint: token,\n        postLogoutRedirectUri: _this65.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this65.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n\nclass IdentityServerAuthConfig extends IonicGeneralAuthConfig {\n  constructor(options, onGetRawIdToken) {\n    super(options);\n    this.onGetRawIdToken = onGetRawIdToken;\n  } // IdentityServer doesn't have a logout_endpoint in their config, rather they use end_session_endpoint\n\n\n  getLogoutUrl() {\n    var _this66 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this66.loadLocations();\n      let token;\n\n      try {\n        token = yield _this66.onGetRawIdToken();\n      } catch (e) {\n        throw new Error(messages.LOGOUT_UNABLE_TO_RETRIEVE_TOKEN);\n      }\n\n      const options = {\n        idTokenHint: token,\n        postLogoutRedirectUri: _this66.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this66.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n\nclass IonicKeyCloakConfig extends IonicGeneralAuthConfig {\n  // The only unique salesforce quirk is that the challenge/verifier can only consist of hexidecimal chars\n  getLogoutUrl() {\n    var _this67 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this67.loadLocations();\n      const options = {\n        clientId: _this67.options.clientID,\n        postLogoutRedirectUri: _this67.options.logoutUrl\n      };\n      return UrlHelper.buildUrl(_this67.locations['end_session_endpoint'], OAuthPacker.packParams(options));\n    })();\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass WebStorageProvider {\n  constructor(keyPrefix = 'ionic-ac-storage:') {\n    this.keyPrefix = keyPrefix;\n  }\n\n  get(key) {\n    var _this68 = this;\n\n    return _asyncToGenerator(function* () {\n      return localStorage.getItem(_this68.getKey(key));\n    })();\n  }\n\n  set(key, value) {\n    var _this69 = this;\n\n    return _asyncToGenerator(function* () {\n      return localStorage.setItem(_this69.getKey(key), value);\n    })();\n  }\n\n  remove(key) {\n    var _this70 = this;\n\n    return _asyncToGenerator(function* () {\n      return localStorage.removeItem(_this70.getKey(key));\n    })();\n  }\n\n  clear() {\n    var _this71 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const length = localStorage.length;\n\n      for (let i = 0; i < length; i++) {\n        if ((_a = localStorage.key(i)) === null || _a === void 0 ? void 0 : _a.startsWith(_this71.keyPrefix)) {\n          localStorage.removeItem(localStorage.key(i));\n        }\n      }\n    })();\n  }\n\n  getKey(key) {\n    return `${this.keyPrefix}${key}`;\n  }\n\n}\n/**\n * @hidden\n */\n\n\nclass NativeStorageProvider {\n  get(key) {\n    return _asyncToGenerator(function* () {\n      return new Promise((res, rej) => {\n        cordova.exec(function (result) {\n          res(result);\n        }, function (error) {\n          rej(error);\n        }, 'IonicAuthConnectStorage', 'get', [key]);\n      });\n    })();\n  }\n\n  set(key, value) {\n    return _asyncToGenerator(function* () {\n      return new Promise((res, rej) => {\n        cordova.exec(function (_winParam) {\n          res();\n        }, function (error) {\n          rej(error);\n        }, 'IonicAuthConnectStorage', 'set', [key, value]);\n      });\n    })();\n  }\n\n  remove(key) {\n    return _asyncToGenerator(function* () {\n      return new Promise((res, rej) => {\n        cordova.exec(function () {\n          res();\n        }, function (error) {\n          rej(error);\n        }, 'IonicAuthConnectStorage', 'remove', [key]);\n      });\n    })();\n  }\n\n  clear() {\n    return _asyncToGenerator(function* () {\n      return new Promise((res, rej) => {\n        cordova.exec(function () {\n          res();\n        }, function (error) {\n          rej(error);\n        }, 'IonicAuthConnectStorage', 'clear');\n      });\n    })();\n  }\n\n}\n\nclass IonicBaseAuth {\n  constructor(options, handlers) {\n    var _this72 = this;\n\n    this.options = options;\n    this.handlers = handlers;\n    this.logTag = 'IonicBaseAuth: ';\n    this.addedLoginParameters = {};\n    this.storage = this.getStorageProvider(options.tokenStorageProvider);\n    this.session = new SessionHelper(options.clientID, this.options.platform === 'web' ? new WebStorageProvider() : new NativeStorageProvider());\n    logging.setLogLevel(options.logLevel);\n    this.logger = logging;\n\n    switch (this.options.authConfig) {\n      case 'auth0':\n        this.authConfig = new IonicAuth0Config(options);\n        break;\n\n      case 'azure':\n        this.authConfig = new IonicAzureConfig(options);\n        break;\n\n      case 'cognito':\n        this.authConfig = new IonicCognitoConfig(options);\n        break;\n\n      case 'general':\n        this.authConfig = new IonicGeneralAuthConfig(options);\n        break;\n\n      case 'salesforce':\n        this.authConfig = new IonicSalesForceAuthConfig(options);\n        break;\n\n      case 'ping':\n        this.authConfig = new IonicPingAuthConfig(options);\n        break;\n\n      case 'identity-server':\n        this.authConfig = new IdentityServerAuthConfig(options, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this72.getRawIdToken();\n        }));\n        break;\n\n      case 'okta':\n        this.authConfig = new IonicOktaAuthConfig(options, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this72.getRawIdToken();\n        }));\n        break;\n\n      case 'keycloak':\n        this.authConfig = new IonicKeyCloakConfig(options);\n        break;\n\n      case 'onelogin':\n        this.authConfig = new IonicOneLoginConfig(options, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this72.getRawIdToken();\n        }));\n        break;\n\n      default:\n        this.authConfig = new IonicAzureConfig(options);\n        break;\n    }\n  }\n\n  getRawIdToken() {\n    var _this73 = this;\n\n    return _asyncToGenerator(function* () {\n      let idToken = undefined;\n\n      if (_this73.storage.getIdToken) {\n        idToken = yield _this73.storage.getIdToken();\n      } else {\n        idToken = _this73.authResult && _this73.authResult.idToken;\n      }\n\n      return idToken;\n    })();\n  }\n\n  setStorageOnLockCallback(onLockCallback) {\n    if (this.storage.onLock && typeof this.storage.onLock === 'function') {\n      this.storage.onLock(onLockCallback);\n    }\n  }\n\n  getStorageProvider(type) {\n    if (!type || type === 'localStorage') {\n      const authLocalStorage = new AuthLocalStorage();\n      authLocalStorage.setClientId(this.options.clientID);\n      return authLocalStorage;\n    } else if (isTokenStorageProvider(type)) {\n      return type;\n    } else if (isIV5UserInterface(type)) {\n      const authIV5Storage = new AuthIdentityVault5Storage(type);\n      authIV5Storage.setClientId(this.options.clientID);\n      return authIV5Storage;\n    } else {\n      const authIVStorage = new AuthIdentityVaultStorage(type);\n      authIVStorage.setClientId(this.options.clientID);\n      return authIVStorage;\n    }\n  }\n\n  validateIdToken(idToken) {\n    return _asyncToGenerator(function* () {\n      return parseJwt(idToken).payload;\n    })();\n  }\n\n  setSession(authResult, tokenName, scopes) {\n    var _this74 = this;\n\n    return _asyncToGenerator(function* () {\n      const expiresAt = authResult.expiresIn ? authResult.expiresIn * 1000 + new Date().getTime() : undefined;\n\n      if (expiresAt) {\n        _this74.logger.debug('setting expires at', expiresAt);\n\n        yield _this74.session.setExpiresAt(expiresAt, tokenName);\n      } else {\n        _this74.logger.debug('no expiration sent in result');\n      } // if we have a valid tokenName we are refreshing a secondary token\n      //   save the scopes, but not the result\n\n\n      if (tokenName) {\n        yield _this74.session.setTokenScopes(scopes, tokenName);\n      } else {\n        _this74.authResult = authResult;\n      }\n\n      if (_this74.storage.setIdToken && authResult.idToken) {\n        yield _this74.storage.setIdToken(authResult.idToken);\n      }\n\n      if (_this74.storage.setAccessToken && authResult.accessToken) {\n        yield _this74.storage.setAccessToken(authResult.accessToken, tokenName);\n      }\n\n      if (_this74.storage.setRefreshToken && authResult.refreshToken) {\n        yield _this74.storage.setRefreshToken(authResult.refreshToken);\n      }\n\n      return _this74.authResult;\n    })();\n  }\n\n  additionalLoginParameters(parameters) {\n    this.addedLoginParameters = parameters;\n  }\n\n  setOverrideDiscoveryUrl(url) {\n    var _this75 = this;\n\n    return _asyncToGenerator(function* () {\n      _this75.authConfig.overrideDiscoveryUrl = url;\n      yield _this75.session.setOverrideUrl(url);\n    })();\n  }\n\n  clearOverrideDiscoveryUrl() {\n    var _this76 = this;\n\n    return _asyncToGenerator(function* () {\n      _this76.authConfig.overrideDiscoveryUrl = '';\n      yield _this76.session.clearOverrideUrl();\n    })();\n  }\n\n  getOverrideDiscoveryUrl() {\n    var _this77 = this;\n\n    return _asyncToGenerator(function* () {\n      _this77.authConfig.overrideDiscoveryUrl = (yield _this77.session.getOverrideUrl()) || '';\n      return _this77.authConfig.overrideDiscoveryUrl || undefined;\n    })();\n  }\n\n  getAccessTokenExpiration(tokenName) {\n    var _this78 = this;\n\n    return _asyncToGenerator(function* () {\n      const expiresAt = yield _this78.session.getExpiresAt(tokenName);\n      return typeof expiresAt === 'number' ? expiresAt : undefined;\n    })();\n  }\n\n  login(overrideUrl) {\n    var _this79 = this;\n\n    return _asyncToGenerator(function* () {\n      return new Promise( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (resolve, reject) {\n          const keys = yield _this79.authConfig.generateChallengeAndVerifier();\n          const nonce = getRandomNonce();\n          yield _this79.session.clearAuthData();\n          yield _this79.session.setAuthData(keys);\n          yield _this79.session.setNonce(nonce);\n          const previousOverrideUrl = yield _this79.session.getOverrideUrl();\n          _this79.authConfig.overrideDiscoveryUrl = overrideUrl || previousOverrideUrl || '';\n\n          try {\n            const url = yield _this79.authConfig.getAuthorizeUrl(nonce, keys.challenge, _this79.addedLoginParameters);\n\n            _this79.showUrl(url.url, undefined, _this79.options.redirectUri).then( /*#__PURE__*/function () {\n              var _ref8 = _asyncToGenerator(function* (result) {\n                const callbackString = result.callback;\n\n                if (callbackString) {\n                  const searchParams = new URL(callbackString).searchParams;\n\n                  if (searchParams.has('error_description')) {\n                    const errorDescription = searchParams.get('error_description');\n                    logging.debug('error_description' + errorDescription);\n                    throw new Error(errorDescription);\n                  }\n\n                  const authResult = yield _this79.internalHandleCallback(callbackString, false);\n\n                  _this79.onLoginSuccess(authResult);\n\n                  resolve();\n                } else {\n                  if (result.event === 'closed') {\n                    throw new Error('browser was closed');\n                  } else {\n                    throw new Error('no callback string');\n                  }\n                }\n              });\n\n              return function (_x6) {\n                return _ref8.apply(this, arguments);\n              };\n            }()).catch(error => {\n              reject(error);\n            });\n          } catch (err) {\n            reject(err);\n          }\n        });\n\n        return function (_x4, _x5) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  getIdToken() {\n    var _this80 = this;\n\n    return _asyncToGenerator(function* () {\n      const idToken = yield _this80.getRawIdToken();\n\n      if (!idToken) {\n        return;\n      }\n\n      const result = yield _this80.validateIdToken(idToken);\n      return result;\n    })();\n  }\n\n  getAuthResponse() {\n    var _this81 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this81.storage.getAuthResponse) {\n        return _this81.storage.getAuthResponse();\n      }\n    })();\n  }\n\n  handleLoginCallback(url = window.location.href) {\n    var _this82 = this;\n\n    return _asyncToGenerator(function* () {\n      const authResult = yield _this82.internalHandleCallback(url, true);\n\n      _this82.onLoginSuccess(authResult);\n\n      return authResult;\n    })();\n  }\n\n  handleLogoutCallback() {\n    var _this83 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this83.finishLogout();\n    })();\n  }\n  /**\n   * @deprecated Use `handleLoginCallback()` instead\n   */\n\n\n  handleCallback(url) {\n    var _this84 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this84.handleLoginCallback(url);\n    })();\n  }\n\n  isAccessTokenAvailable(tokenName) {\n    var _this85 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this85.storage.getAccessToken) {\n        const token = yield _this85.storage.getAccessToken(tokenName);\n        return !!token;\n      }\n\n      return false;\n    })();\n  }\n\n  isAccessTokenExpired(tokenName) {\n    var _this86 = this;\n\n    return _asyncToGenerator(function* () {\n      const expiresAt = yield _this86.session.getExpiresAt(tokenName);\n\n      _this86.logger.debug(_this86.logTag, 'expiresAt: ', expiresAt); // If the result didn't include an expires_in we can't know whether it's expired or not\n\n\n      return typeof expiresAt === 'number' ? new Date().getTime() >= expiresAt : false;\n    })();\n  }\n\n  isAuthenticated(tokenName) {\n    var _this87 = this;\n\n    return _asyncToGenerator(function* () {\n      const idToken = yield _this87.getIdToken();\n\n      if (!idToken) {\n        _this87.logger.debug(_this87.logTag, 'no idToken, false');\n\n        return false;\n      }\n\n      try {\n        let isAuthenticated = !(yield _this87.isAccessTokenExpired(tokenName));\n\n        if (!isAuthenticated) {\n          _this87.logger.debug(_this87.logTag, 'after expiresAt time');\n\n          try {\n            yield _this87.refreshSession(tokenName);\n\n            _this87.logger.debug(_this87.logTag, 'refresh succeeded, returning true');\n\n            isAuthenticated = true;\n          } catch (e) {\n            yield _this87.clearStorage();\n\n            _this87.logger.debug(_this87.logTag, 'refresh threw, false', e);\n\n            isAuthenticated = false;\n          }\n        }\n\n        return isAuthenticated;\n      } catch (e) {\n        _this87.logger.error(`${_this87.logTag} isAuthenticated`, e);\n\n        yield _this87.clearStorage();\n        return false;\n      }\n    })();\n  }\n\n  getRefreshToken() {\n    var _this88 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this88.storage.getRefreshToken ? yield _this88.storage.getRefreshToken() : undefined;\n    })();\n  }\n\n  isRefreshTokenAvailable() {\n    var _this89 = this;\n\n    return _asyncToGenerator(function* () {\n      return !!(yield _this89.getRefreshToken());\n    })();\n  }\n\n  internalGetToken(codeName, code, grantType, verifier, scope) {\n    return _asyncToGenerator(function* () {\n      throw Error('Not Implemented');\n    })();\n  }\n\n  getAccessToken(tokenName, scopes) {\n    var _this90 = this;\n\n    return _asyncToGenerator(function* () {\n      const isAuthenticated = yield _this90.isAuthenticated();\n\n      if (!isAuthenticated) {\n        _this90.logger.debug(_this90.logTag, 'Not authenticated, refresh failed.');\n\n        throw 'Not authenticated, refresh failed.';\n      }\n\n      if (_this90.storage.getAccessToken) {\n        _this90.logger.debug(_this90.logTag, 'returning storage accessToken', tokenName);\n\n        if (tokenName) {\n          const tempAccessToken = yield _this90.storage.getAccessToken(tokenName);\n\n          if (tempAccessToken) {\n            const isAuthenticatedToken = yield _this90.isAuthenticated(tokenName);\n\n            if (!isAuthenticatedToken) {\n              _this90.logger.debug(_this90.logTag, 'Not authenticated, refresh2 failed.');\n\n              throw 'Not authenticated, refresh2 failed.';\n            }\n          }\n        }\n\n        const accessToken = yield _this90.storage.getAccessToken(tokenName);\n\n        if (accessToken) {\n          return accessToken;\n        }\n      }\n\n      if (tokenName) {\n        let session = yield _this90.session.getAuthData();\n\n        if (!session) {\n          session = yield _this90.authConfig.generateChallengeAndVerifier();\n        }\n\n        let refreshToken = '';\n\n        if (_this90.storage.getRefreshToken) {\n          refreshToken = yield _this90.storage.getRefreshToken();\n        }\n\n        const result = yield _this90.internalGetToken('refresh_token', refreshToken, 'refresh_token', session.verifier, scopes);\n\n        if (result) {\n          yield _this90.setSession(result, tokenName, scopes);\n\n          _this90.logger.debug(_this90.logTag, 'Acquired a new token.', tokenName, scopes);\n\n          return result.accessToken;\n        }\n\n        _this90.logger.debug(_this90.logTag, 'Could not acquire a new token for: ', tokenName, scopes);\n\n        throw 'No token could be acquired.';\n      } else {\n        if (_this90.storage.getAuthResponse) {\n          const authResponse = yield _this90.storage.getAuthResponse();\n\n          if (authResponse && authResponse.accessToken) {\n            _this90.logger.debug(_this90.logTag, 'returning authResponse accessToken');\n\n            return authResponse.accessToken;\n          }\n        }\n\n        if (_this90.authResult && _this90.authResult.accessToken) {\n          _this90.logger.debug(_this90.logTag, 'returning authResult accessToken');\n\n          return _this90.authResult.accessToken;\n        }\n      }\n\n      _this90.logger.debug(_this90.logTag, 'Could not find a token, failing.');\n\n      throw 'Authenticated, but token not found.';\n    })();\n  }\n\n  expire(tokenName) {\n    var _this91 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this91.session.setExpiresAt(0, tokenName);\n    })();\n  }\n\n  logout() {\n    var _this92 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this92.getOverrideDiscoveryUrl();\n      const url = yield _this92.authConfig.getLogoutUrl();\n      logging.debug('logout url: ' + url.url);\n      yield _this92.showUrl(url.url, {\n        hide: true\n      }, _this92.options.logoutUrl);\n      yield _this92.finishLogout();\n    })();\n  }\n\n  finishLogout() {\n    var _this93 = this;\n\n    return _asyncToGenerator(function* () {\n      _this93.authResult = undefined;\n      yield _this93.clearStorage();\n      _this93.authConfig.locations = undefined;\n      yield _this93.clearOverrideDiscoveryUrl();\n\n      _this93.onLogout();\n    })();\n  }\n\n  onLoginSuccess(authResponse) {\n    this.authConfig.locations = undefined;\n    this.authConfig.overrideDiscoveryUrl = '';\n    this.handlers.onLoginSuccess(authResponse);\n  }\n\n  onLogout() {\n    this.handlers.onLogout();\n  }\n\n  clearStorage() {\n    var _this94 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this94.session.clear();\n\n      if (_this94.storage.clear) {\n        yield _this94.storage.clear();\n      }\n    })();\n  }\n\n}\n\nclass IonicAuthWeb extends IonicBaseAuth {\n  constructor(options, handlers) {\n    super(options, handlers);\n    this.options = options;\n    this.handlers = handlers;\n    this.logTag = 'IonicWebAuth: ';\n    this.lastAuthPopup = null;\n    this.logger.debug(this.logTag, 'ctor options', options);\n    window.addEventListener('message', event => {\n      this.logger.debug(this.logTag, 'event: ', event);\n    });\n  }\n\n  internalGetToken(_codeName, _code, _grantType, _verifier, scope) {\n    var _this95 = this;\n\n    return _asyncToGenerator(function* () {\n      _this95.logger.debug(_this95.logTag, 'getting token'); // setup the env for a new token request\n\n\n      const keys = yield _this95.authConfig.generateChallengeAndVerifier();\n      yield _this95.session.setAuthData(keys);\n      const nonce = (yield _this95.session.getNonce()) || ''; // setup the url for the token\n\n      let urlInfo = yield _this95.authConfig.getAuthorizeUrl(nonce, keys.challenge, {});\n      let url = new URL(urlInfo.url);\n      url.searchParams.set('prompt', 'none');\n      url.searchParams.set('scope', scope);\n      url.searchParams.set('response_type', 'token');\n\n      _this95.logger.debug(_this95.logTag, 'url for internalGetToken: ', url.href);\n\n      const result = yield _this95.hiddenLoadUrl(url.href);\n      const callbackString = result.callback;\n\n      if (callbackString != undefined && callbackString != '') {\n        const parsedUrl = urlParse(callbackString, true);\n        let result = UrlHelper.parseHash(parsedUrl.hash);\n        const authResult = {\n          accessToken: result.access_token,\n          idToken: result.id_token,\n          refreshToken: result.refresh_token,\n          expiresIn: result.expires_in,\n          scope: result.scope,\n          tokenType: result.token_type\n        };\n\n        _this95.logger.debug(_this95.logTag, 'returning authResult: ', authResult);\n\n        return authResult;\n      } else {\n        var error = 'could not get token';\n\n        _this95.logger.error(error);\n\n        throw error;\n      }\n    })();\n  }\n\n  internalHandleCallback(url, externalCallback) {\n    var _this96 = this;\n\n    return _asyncToGenerator(function* () {\n      _this96.logger.debug(_this96.logTag, 'handleCallback url:' + url);\n\n      const parsedUrl = urlParse(url, true);\n      const searchParams = new URLSearchParams(parsedUrl.hash);\n\n      _this96.logger.debug(_this96.logTag, 'searchParams: ', JSON.stringify(searchParams));\n\n      if (searchParams.has('error_description')) {\n        const errorDescription = searchParams.get('error_description');\n\n        _this96.logger.debug('error_description' + errorDescription);\n\n        throw new Error(errorDescription);\n      }\n\n      const query_params = parsedUrl.query;\n\n      _this96.logger.debug(_this96.logTag, 'query params: ', query_params);\n\n      const hash = UrlHelper.parseHash(parsedUrl.hash);\n\n      _this96.logger.debug(_this96.logTag, 'hash: ', hash);\n\n      if (hash.access_token != undefined && hash.id_token != undefined || _this96.options.webAuthFlow && _this96.options.webAuthFlow === 'PKCE' && query_params.code != undefined) {\n        let result = {};\n        const session = yield _this96.session.getAuthData();\n\n        if (!session) {\n          throw new Error('No session data stored');\n        }\n\n        _this96.logger.debug(_this96.logTag, 'got a session');\n\n        if (query_params.code != undefined) {\n          var options = {\n            grant_type: 'authorization_code',\n            client_id: _this96.options.clientID,\n            code_verifier: session.verifier,\n            code: query_params.code,\n            redirect_uri: String(_this96.options.redirectUri)\n          };\n          result = yield _this96.postToken(options);\n        } else {\n          result = hash;\n        }\n\n        return yield _this96.handleAuthResult(result);\n      } else {\n        var error = 'Web only supports implicit login with id and access token returned from the authorize call or PKCE';\n\n        _this96.logger.error(error);\n\n        throw error;\n      }\n    })();\n  }\n\n  refreshSession(tokenName) {\n    var _this97 = this;\n\n    return _asyncToGenerator(function* () {\n      _this97.logger.debug(_this97.logTag, 'refreshing session');\n\n      yield _this97.getOverrideDiscoveryUrl();\n\n      if (tokenName) {\n        _this97.logger.debug(_this97.logTag, 'refreshing other token: ', tokenName);\n\n        const scope = yield _this97.session.getTokenScopes(tokenName);\n        const authResult = yield _this97.internalGetToken('', '', '', undefined, scope);\n        yield _this97.setSession(authResult, tokenName, scope);\n        return;\n      }\n\n      if (_this97.options.webAuthFlow === 'PKCE') {\n        const refreshToken = yield _this97.getRefreshToken();\n\n        if (!refreshToken) {\n          throw new Error('No refresh token available');\n        }\n\n        let options = {\n          grant_type: 'refresh_token',\n          client_id: _this97.options.clientID,\n          refresh_token: refreshToken\n        };\n        const result = yield _this97.postToken(options);\n        yield _this97.handleAuthResult(result);\n      } else {\n        const keys = yield _this97.authConfig.generateChallengeAndVerifier();\n        yield _this97.session.clearAuthData();\n        yield _this97.session.setAuthData(keys);\n\n        _this97.logger.debug(_this97.logTag, 'keys: ', keys);\n\n        const nonce = (yield _this97.session.getNonce()) || '';\n\n        _this97.logger.debug(_this97.logTag, 'nonce: ', nonce);\n\n        let url = yield _this97.authConfig.getAuthorizeUrl(nonce, keys.challenge, {});\n        url.url = url.url + '&prompt=none';\n\n        _this97.logger.debug(_this97.logTag, 'url for refresh: ', url.url);\n\n        try {\n          const result = yield _this97.hiddenLoadUrl(url.url);\n\n          _this97.logger.debug(_this97.logTag, 'result for refresh: ', result);\n\n          const callbackString = result.callback;\n\n          if (callbackString != undefined && callbackString != '') {\n            _this97.logger.debug(_this97.logTag, 'calling handleCallback');\n\n            yield _this97.internalHandleCallback(callbackString, false);\n          }\n        } catch (e) {\n          var error = 'Failed to refresh session';\n\n          _this97.logger.error(error);\n\n          throw error;\n        }\n      }\n    })();\n  }\n\n  handleAuthResult(result) {\n    var _this98 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this98.storage.setAuthResponse) {\n        yield _this98.storage.setAuthResponse(result);\n      }\n\n      _this98.logger.debug(_this98.logTag, 'result: ', result);\n\n      const authResult = {\n        accessToken: result.access_token,\n        idToken: result.id_token,\n        refreshToken: result.refresh_token,\n        expiresIn: result.expires_in,\n        scope: result.scope,\n        tokenType: result.token_type\n      };\n      yield _this98.setSession(authResult);\n\n      _this98.logger.debug(_this98.logTag, 'clear auth data');\n\n      yield _this98.session.clearAuthData();\n\n      _this98.logger.debug(_this98.logTag, 'return auth result', authResult);\n\n      return authResult;\n    })();\n  }\n\n  postToken(options) {\n    var _this99 = this;\n\n    return _asyncToGenerator(function* () {\n      const tokenUrlInfo = yield _this99.authConfig.getTokenUrl();\n      const tokenUrl = tokenUrlInfo.url || '';\n      const headers = Object.assign(Object.assign({}, tokenUrlInfo.headers), {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      options = Object.assign(Object.assign({}, tokenUrlInfo.payload), options);\n      const bodyParams = Object.keys(options).map(key => {\n        return encodeURIComponent(key) + '=' + encodeURIComponent(options[key]);\n      }).join('&');\n      const response = yield fetch(tokenUrl, {\n        method: 'POST',\n        headers: headers,\n        body: bodyParams\n      });\n\n      if (!response.ok) {\n        const jsonRes = yield response.json();\n        const errorMessage = `POST to token endpoint failed with error: ${jsonRes.error_description ? jsonRes.error_description : jsonRes.error}`;\n\n        _this99.logger.error(errorMessage);\n\n        throw errorMessage;\n      }\n\n      return JSON.parse(yield response.text());\n    })();\n  }\n\n  hiddenLoadUrl(url) {\n    try {\n      return new Promise((resolve, reject) => {\n        this.logger.debug(this.logTag, 'opening browser.');\n        let iframeLocation;\n        const iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        iframe.src = url;\n        document.getElementsByTagName('body')[0].appendChild(iframe);\n        iframe.src = url;\n        const that = this;\n        var timer = window.setInterval(() => {\n          try {\n            if (iframe === null) {\n              return;\n            }\n\n            if (iframe.contentWindow !== null) {\n              iframeLocation = iframe.contentWindow.location;\n            } else if (iframe.contentDocument !== null) {\n              iframeLocation = iframe.contentDocument.location;\n            } else {\n              this.logger.debug(this.logTag, 'no doc or window');\n              return;\n            }\n\n            if (!encodeURI(iframeLocation.href).indexOf(encodeURI(that.options.redirectUri))) {\n              window.clearInterval(timer);\n              const href = iframeLocation.href;\n              this.logger.debug(this.logTag, 'closing iframe: ', href);\n\n              if (iframe.parentNode !== null) {\n                iframe.parentNode.removeChild(iframe);\n              }\n\n              this.logger.debug(this.logTag, 'calling resolve');\n              resolve({\n                event: 'opened',\n                callback: href\n              });\n            }\n\n            return;\n          } catch (e) {\n            window.clearInterval(timer);\n            this.logger.error(this.logTag, e.message);\n            reject(e.message);\n          }\n        }, 1);\n      });\n    } catch (err) {\n      this.logger.error(this.logTag, 'hiddenLoadUrl error: ', err);\n      throw err;\n    }\n  }\n\n  showUrl(url, _options, urlToCloseWindow = this.options.redirectUri) {\n    try {\n      if (this.options.implicitLogin !== 'CURRENT') {\n        // POPUP\n        return new Promise((resolve, reject) => {\n          this.logger.debug(this.logTag, 'opening browser.');\n          let popupLocation;\n          const popup = window.open(url, '_system');\n          this.lastAuthPopup = popup;\n          var timer = window.setInterval(() => {\n            if (!popup || popup.closed) {\n              window.clearInterval(timer);\n              const error = 'popup window closed without navigating to result url';\n              this.logger.error(this.logTag, error);\n              reject(error);\n            }\n\n            try {\n              if (!popup) {\n                return;\n              }\n\n              popupLocation = popup.location;\n\n              if (!encodeURI(popupLocation.href).indexOf(encodeURI(urlToCloseWindow))) {\n                window.clearInterval(timer);\n                const popupString = popupLocation.toString();\n                this.logger.debug(this.logTag, 'closing popup: ', popupLocation);\n                popup.close();\n                this.logger.debug(this.logTag, 'closed popup', popupString);\n                resolve({\n                  event: 'opened',\n                  callback: popupString\n                });\n              }\n\n              return;\n            } catch (e) {// While the URL is at the auth provider, we will get a DOMException error trying to access the window.\n              // We eat the error and try again.\n            }\n          }, 1);\n        });\n      } else {\n        // CURRENT\n        logging.debug(this.logTag, 'about to navigate forward');\n        window.location.replace(url);\n        return new Promise(() => {});\n      }\n    } catch (err) {\n      this.logger.error(this.logTag, 'showUrl error: ', err);\n      throw err;\n    }\n  }\n\n}\n\nclass SecureWebView {\n  isAvailable(callback) {\n    var errorHandler = function errorHandler(error) {\n      // An error has occurred while trying to access the\n      // SecureWebView native implementation, most likely because\n      // we are on an unsupported platform.\n      callback(false);\n    };\n\n    cordova.exec(callback, errorHandler, 'SecureWebView', 'isAvailable', []);\n  } // options:\n  //  url - url to display\n  //  webView - for iOS which webview to display, if possible. By default we use the newest one available for OS version\n  //      - ASWebAuth - ASWebAuthenticationSession (avaialble starting in iOS 12)\n  //      - SFAuth - SFAuthenticationSession (available starting in iOS 11)\n  //      - SFSafari - SFSafariViewController (available starting in iOS 9)\n  //      - MobileSafari - Mobile Safari (pre-iOS 8)\n\n\n  show(options, onSuccess, onError) {\n    options = options || {};\n\n    if (!options.hasOwnProperty('animated')) {\n      options.animated = true;\n    }\n\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'show', [options]);\n  }\n\n  hide(onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'hide', []);\n  }\n\n  getViewHandlerPackages(onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'getViewHandlerPackages', []);\n  }\n\n  useCustomTabsImplementation(packageName, onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'useCustomTabsImplementation', [packageName]);\n  }\n\n  connectToService(onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'connectToService', []);\n  }\n\n  warmUp(onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'warmUp', []);\n  }\n\n  mayLaunchUrl(url, onSuccess, onError) {\n    cordova.exec(onSuccess, onError, 'SecureWebView', 'mayLaunchUrl', [url]);\n  }\n\n}\n\nconst IonicSecureWebView = new SecureWebView();\nconst ready = new Promise(resolve => {\n  const DEVICE_READY_TIMEOUT = 5000;\n  const readyTimeout = setTimeout(() => {\n    console.warn(`Auth Connect: deviceready did not fire within ${DEVICE_READY_TIMEOUT}ms.`);\n    resolve();\n  }, DEVICE_READY_TIMEOUT);\n  document.addEventListener('deviceready', () => {\n    clearTimeout(readyTimeout);\n    resolve();\n  });\n});\n\nclass IonicNativeAuth extends IonicBaseAuth {\n  constructor() {\n    super(...arguments);\n    this.logTag = 'IonicNativeAuth: ';\n  }\n\n  internalGetToken(codeName, code, grantType, verifier, scope) {\n    var _this100 = this;\n\n    return _asyncToGenerator(function* () {\n      let payload;\n      payload = {\n        grant_type: grantType,\n        client_id: _this100.options.clientID,\n        code_verifier: verifier,\n        redirect_uri: String(_this100.options.redirectUri)\n      };\n      payload[codeName] = String(code);\n      const tokenUrlInfo = yield _this100.authConfig.getTokenUrl();\n      const tokenUrl = tokenUrlInfo.url || '';\n\n      if (tokenUrlInfo.payload) {\n        payload = Object.assign(Object.assign({}, tokenUrlInfo.payload), payload);\n      }\n\n      if (scope != undefined) {\n        payload.scope = scope;\n      }\n\n      let headers = {};\n\n      if (tokenUrlInfo.headers) {\n        headers = tokenUrlInfo.headers;\n      } else {\n        headers = {\n          'Content-Type': 'application/json'\n        };\n      } // need to await device ready\n\n\n      return yield UrlHelper.post(tokenUrl, payload, headers).then( /*#__PURE__*/function () {\n        var _ref9 = _asyncToGenerator(function* (response) {\n          const result = JSON.parse(response.data);\n\n          if (_this100.storage.setAuthResponse && grantType != 'refresh_token') {\n            yield _this100.storage.setAuthResponse(result);\n          }\n\n          _this100.logger.debug(_this100.logTag, 'got result', result);\n\n          _this100.logger.debug(_this100.logTag, 'access_token', result.access_token);\n\n          _this100.logger.debug(_this100.logTag, 'id_token', result.id_token);\n\n          _this100.logger.debug(_this100.logTag, 'refresh_token', result.refresh_token);\n\n          _this100.logger.debug(_this100.logTag, 'profile_info', result.profile_info);\n\n          _this100.logger.debug(_this100.logTag, 'expires_in', result.expires_in);\n\n          const authResult = {\n            accessToken: result.access_token,\n            idToken: result.id_token,\n            refreshToken: result.refresh_token,\n            expiresIn: result.expires_in,\n            scope: result.scope,\n            tokenType: result.token_type\n          };\n          return authResult;\n        });\n\n        return function (_x7) {\n          return _ref9.apply(this, arguments);\n        };\n      }()).catch(error => {\n        _this100.logger.debug(tokenUrl, _this100.logTag, ' - tokenUrl');\n\n        _this100.logger.debug(headers, _this100.logTag, ' - headers');\n\n        _this100.logger.debug(payload, _this100.logTag, ' - payload');\n\n        _this100.logger.error(_this100.logTag, error);\n\n        return {};\n      });\n    })();\n  }\n\n  internalHandleCallback(url, _externalCallback) {\n    var _this101 = this;\n\n    return _asyncToGenerator(function* () {\n      const session = yield _this101.session.getAuthData();\n\n      if (!session) {\n        throw new Error('No session data stored');\n      }\n\n      let {\n        code\n      } = urlParse(url, true).query;\n      yield ready;\n      let grantType = 'authorization_code';\n      let codeName = 'code';\n\n      try {\n        const result = yield _this101.internalGetToken(codeName, code, grantType, session.verifier, undefined);\n        yield _this101.setSession(result);\n        yield _this101.session.clearAuthData();\n        IonicSecureWebView.hide(data => {\n          _this101.logger.debug(_this101.logTag, 'IonicSecureWebView.hide succeeded: ', data);\n        }, err => {\n          _this101.logger.error(_this101.logTag, 'IonicSecureWebView.hide failed: ', err);\n        });\n        return result;\n      } catch (err) {\n        yield _this101.session.clearAuthData();\n\n        _this101.logout();\n\n        throw err;\n      }\n    })();\n  }\n\n  refreshSession(tokenName) {\n    var _this102 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this102.getOverrideDiscoveryUrl();\n\n      _this102.logger.debug(_this102.logTag, 'refresh flow');\n\n      const url = yield _this102.authConfig.getTokenUrl();\n      const nonce = yield _this102.session.getNonce();\n      const refreshToken = yield _this102.getRefreshToken();\n\n      if (!refreshToken) {\n        throw new Error('No refresh token available');\n      }\n\n      let payload;\n      payload = {\n        client_id: _this102.options.clientID,\n        refresh_token: refreshToken,\n        grant_type: 'refresh_token',\n        nonce,\n        state: nonce\n      };\n\n      if (url.payload) {\n        payload = Object.assign(Object.assign({}, url.payload), payload);\n      }\n\n      let secondaryToken = false;\n\n      if (tokenName) {\n        payload.scope = yield _this102.session.getTokenScopes(tokenName);\n        secondaryToken = true;\n      }\n\n      const headers = url.headers ? url.headers : {\n        'Content-Type': 'application/json'\n      };\n      yield ready;\n      return yield UrlHelper.post(url.url || '', payload, headers).then( /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator(function* (response) {\n          const result = JSON.parse(response.data);\n\n          if (_this102.storage.setAuthResponse && !secondaryToken) {\n            yield _this102.storage.setAuthResponse(result);\n          }\n\n          const authResult = {\n            accessToken: result.access_token,\n            idToken: result.id_token,\n            refreshToken: result.refresh_token,\n            expiresIn: result.expires_in,\n            scope: result.scope,\n            tokenType: result.token_type\n          };\n          yield _this102.setSession(authResult, tokenName, result.scope);\n          return;\n        });\n\n        return function (_x8) {\n          return _ref10.apply(this, arguments);\n        };\n      }()).catch(error => {\n        _this102.logger.debug(_this102.logTag, 'tokenUrl: ' + url.url);\n\n        _this102.logger.debug(_this102.logTag, 'headers: ', headers);\n\n        _this102.logger.debug(_this102.logTag, 'payload: ', payload);\n\n        _this102.logger.error(_this102.logTag, error);\n\n        throw error;\n      });\n    })();\n  }\n\n  showUrl(url, options) {\n    return new Promise((resolve, reject) => {\n      let curOptions = {};\n\n      if (this.options.androidToolbarColor) {\n        curOptions = Object.assign(Object.assign({}, curOptions), {\n          toolbarColor: this.options.androidToolbarColor\n        });\n      }\n\n      if (this.options.safariWebViewOptions) {\n        curOptions = Object.assign(Object.assign({}, curOptions), this.options.safariWebViewOptions);\n      }\n\n      this.logger.debug(this.logTag, 'webView option: ', this.authConfig.options.iosWebView);\n      const params = Object.assign({}, {\n        url,\n        callbackUrl: this.authConfig.options.redirectUri,\n        iosWebView: this.authConfig.options.iosWebView\n      }, curOptions);\n      this.logger.debug(this.logTag, 'using params: ', params);\n      IonicSecureWebView.show(params, result => {\n        this.logger.debug(this.logTag, 'result :', result);\n        resolve(result);\n      }, error => {\n        this.logger.error(this.logTag, 'show failed: ', error);\n        reject(error);\n      });\n    });\n  }\n\n}\n\nclass IonicAuth {\n  constructor(options) {\n    this.implementation = this.getImplementation(options);\n  }\n  /**\n   * Using configuration display the auth provider's login UI.\n   *\n   *  The overrideUrl parameter should only be used when the default\n   *  discovery url needs to be overrode. (The known use case is with Azure AD\n   *  custom user flows/policies.)\n   *\n   * @example\n   * myAuthService.login(\"\")\n   */\n\n\n  login(overrideUrl) {\n    return this.implementation.login(overrideUrl);\n  }\n  /**\n   * Add additional parameters to the login request.\n   *\n   * @example\n   * myAuthService.additionalLoginParameters({ 'login_hint': 'neighbors cat name' })\n   *\n   * @param parameters any additional parameters that should be added to the login request\n   *  examples: `login_hint`, `domain_hint`\n   */\n\n\n  additionalLoginParameters(parameters) {\n    return this.implementation.additionalLoginParameters(parameters);\n  }\n  /**\n   * Get the access token, once logged in, for API calls.\n   *\n   * @example\n   * myAuthService.getAccessToken()\n   *\n   * @param tokenName Optional token name, only used when multiple tokens are required (Azure specific feature).\n   * @param scopes The scopes for the access token.\n   */\n\n\n  getAccessToken(tokenName, scopes) {\n    return this.implementation.getAccessToken(tokenName, scopes);\n  }\n  /**\n   * Get the unparsed id token.\n   *\n   * @example\n   * myAuthService.getRawIdToken()\n   */\n\n\n  getRawIdToken() {\n    return this.implementation.getRawIdToken();\n  }\n  /**\n   * Get the parsed id token, includes requested scope values.\n   *\n   * @example\n   * myAuthService.getIdToken()\n   */\n\n\n  getIdToken() {\n    return this.implementation.getIdToken();\n  }\n  /**\n   * Get the full original auth response.\n   *\n   * @example\n   * myAuthService.getAuthResponse()\n   */\n\n\n  getAuthResponse() {\n    return this.implementation.getAuthResponse();\n  }\n  /**\n   * Check to see if the access token is available.\n   *\n   * @example\n   * myAuthService.isAccessTokenAvailable()\n   *\n   * @param tokenName Optional token name, only used when multiple tokens are required (Azure specific feature).\n   */\n\n\n  isAccessTokenAvailable(tokenName) {\n    return this.implementation.isAccessTokenAvailable(tokenName);\n  }\n  /**\n   * Check to see if the access token is expired.\n   *\n   * @example\n   * myAuthService.isAccessTokenExpired()\n   */\n\n\n  isAccessTokenExpired() {\n    return this.implementation.isAccessTokenExpired();\n  }\n  /**\n   * Check to see if the refresh token is available.\n   *\n   * @example\n   * myAuthService.isRefreshTokenAvailable()\n   */\n\n\n  isRefreshTokenAvailable() {\n    return this.implementation.isRefreshTokenAvailable();\n  }\n  /**\n   * Get the refresh token if available.\n   *\n   * @example\n   * myAuthService.getRefreshToken()\n   */\n\n\n  getRefreshToken() {\n    return this.implementation.getRefreshToken();\n  }\n  /**\n   * Refresh the session, throws if refresh token is invalid or missing.\n   *\n   * @example\n   * myAuthService.refreshSession()\n   *\n   * @param tokenName Optional token name, only used when multiple tokens are required (Azure specific feature).\n   */\n\n\n  refreshSession() {\n    return this.implementation.refreshSession();\n  }\n  /**\n   * Check to see if the user is logged in, and refresh the token if needed.\n   *\n   * @example\n   * const isAuth = myAuthService.isAuthenticated()\n   */\n\n\n  isAuthenticated() {\n    return this.implementation.isAuthenticated();\n  }\n  /**\n   * Log the user out and clear all tokens & data stored in the {@link TokenStorageProvider} as well as any\n   * metadata relevant to the existing session such as access token expiration time.\n   *\n   * @example\n   * myAuthService.logout()\n   */\n\n\n  logout() {\n    return this.implementation.logout();\n  }\n  /**\n   * Expire the current access token, but keep the refresh token, useful for testing.\n   *\n   * @example\n   * myAuthService.expire()\n   */\n\n\n  expire() {\n    return this.implementation.expire();\n  }\n  /**\n   * Called by the hosting app when login callbacks happen, these will be to the URL specified\n   *  in the options for RedirectUri.\n   *\n   * @example\n   * myAuthService.handleLoginCallback()\n   *\n   * @param url callback url to handle @default defaults to `window.location.href`\n   */\n\n\n  handleLoginCallback(url) {\n    return this.implementation.handleLoginCallback(url);\n  }\n  /**\n   * Called by the hosting app when logout callbacks happens.\n   *\n   * @example\n   * myAuthService.handleLogoutCallback()\n   */\n\n\n  handleLogoutCallback() {\n    return this.implementation.handleLogoutCallback();\n  }\n  /**\n   * Called by the hosting app when callbacks happen, these will be to the URL specified\n   *  in the options for LogoutUrl and RedirectUri.\n   *\n   * @example\n   * myAuthService.handleCallback(window.location.href)\n   *\n   * @deprecated Use [handleLoginCallback](#iionicauth.handlelogincallback) instead\n   * @param url callback url to handle\n   */\n\n\n  handleCallback(url) {\n    return this.implementation.handleLoginCallback(url);\n  }\n  /**\n   * This method will clear all tokens & data stored in the {@link TokenStorageProvider} as well as any\n   * metadata relevant to the existing session such as access token expiration time.\n   *\n   * @example\n   * myAuthService.clearStorage()\n   */\n\n\n  clearStorage() {\n    var _this103 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this103.implementation.clearStorage();\n    })();\n  }\n  /**\n   * Override the discovery url used for login in a way that persists.\n   *\n   * @example\n   * myAuthService.setOverrideDiscoveryUrl(\"https://myurl\")\n   *\n   * @param url the discovery url used for login\n   */\n\n\n  setOverrideDiscoveryUrl(url) {\n    return this.implementation.setOverrideDiscoveryUrl(url);\n  }\n  /**\n   * Clear previosly persisted override of the discovery url used for login.\n   *\n   * @example\n   * myAuthService.clearOverrideDiscoveryUrl()\n   */\n\n\n  clearOverrideDiscoveryUrl() {\n    return this.implementation.clearOverrideDiscoveryUrl();\n  }\n  /**\n   * Clear previosly persisted override of the discovery url used for login.\n   *\n   * @example\n   * myAuthService.getOverrideDiscoveryUrl()\n   */\n\n\n  getOverrideDiscoveryUrl() {\n    return this.implementation.getOverrideDiscoveryUrl();\n  }\n  /**\n   * Get the time the access token will expire in milliseconds from the epoch.\n   *\n   * @example\n   * myAuthService.getAccessTokenExpiration()\n   */\n\n\n  getAccessTokenExpiration() {\n    return this.implementation.getAccessTokenExpiration();\n  }\n  /**\n   * Event handler which can be overridden to handle successful login events.\n   *\n   * @usage\n   * ```typescript\n   * async onLoginSuccess(): Promise<void> {\n   *  // do something here\n   * }\n   * ```\n   * @param result the auth result from a successful login\n   */\n\n\n  onLoginSuccess(result) {}\n  /**\n   * Event handler which can be overridden to handle successful logout events.\n   *\n   * @usage\n   * ```typescript\n   * async onLogout(): Promise<void> {\n   *  // do something here\n   * }\n   * ```\n   */\n\n\n  onLogout() {}\n\n  getImplementation(options) {\n    switch (options.platform) {\n      case 'web':\n        return new IonicAuthWeb(options, {\n          onLoginSuccess: this.onLoginSuccess.bind(this),\n          onLogout: this.onLogout.bind(this)\n        });\n\n      default:\n        return new IonicNativeAuth(options, {\n          onLoginSuccess: this.onLoginSuccess.bind(this),\n          onLogout: this.onLogout.bind(this)\n        });\n    }\n  }\n\n}\n\nexport { IonicAuth, NativeStorageProvider, WebStorageProvider }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}