{"ast":null,"code":"/*\n Highcharts JS v10.3.3 (2023-01-20)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (d) {\n  \"object\" === typeof module && module.exports ? (d[\"default\"] = d, module.exports = d) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (D) {\n    d(D);\n    d.Highcharts = D;\n    return d;\n  }) : d(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (d) {\n  function D(b, c, h, a) {\n    b.hasOwnProperty(c) || (b[c] = a.apply(null, h), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: c,\n        module: b[c]\n      }\n    })));\n  }\n\n  d = d ? d._modules : {};\n  D(d, \"Extensions/Pane.js\", [d[\"Core/Chart/Chart.js\"], d[\"Series/CenteredUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Pointer.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f) {\n    function w(g, k, e, a, G) {\n      var m = !0,\n          E = e[0],\n          v = e[1],\n          c = Math.sqrt(Math.pow(g - E, 2) + Math.pow(k - v, 2));\n      q(a) && q(G) && (g = Math.atan2(r(k - v, 8), r(g - E, 8)), G !== a && (m = a > G ? g >= a && g <= Math.PI || g <= G && g >= -Math.PI : g >= a && g <= r(G, 8)));\n      return c <= Math.ceil(e[2] / 2) && m;\n    }\n\n    var d = f.addEvent,\n        r = f.correctFloat,\n        q = f.defined,\n        F = f.extend,\n        p = f.merge,\n        l = f.pick,\n        e = f.splat;\n    b.prototype.collectionsWithUpdate.push(\"pane\");\n\n    f = function () {\n      function g(k, g) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(k, g);\n      }\n\n      g.prototype.init = function (k, g) {\n        this.chart = g;\n        this.background = [];\n        g.pane.push(this);\n        this.setOptions(k);\n      };\n\n      g.prototype.setOptions = function (k) {\n        this.options = p(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, k);\n      };\n\n      g.prototype.render = function () {\n        var k = this.options,\n            g = this.options.background,\n            a = this.chart.renderer;\n        this.group || (this.group = a.g(\"pane-group\").attr({\n          zIndex: k.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (g) for (g = e(g), k = Math.max(g.length, this.background.length || 0), a = 0; a < k; a++) g[a] && this.axis ? this.renderBackground(p(this.defaultBackgroundOptions, g[a]), a) : this.background[a] && (this.background[a] = this.background[a].destroy(), this.background.splice(a, 1));\n      };\n\n      g.prototype.renderBackground = function (g, e) {\n        var k = \"animate\",\n            m = {\n          \"class\": \"highcharts-pane \" + (g.className || \"\")\n        };\n        this.chart.styledMode || F(m, {\n          fill: g.backgroundColor,\n          stroke: g.borderColor,\n          \"stroke-width\": g.borderWidth\n        });\n        this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), k = \"attr\");\n        this.background[e][k]({\n          d: this.axis.getPlotBandPath(g.from, g.to, g)\n        }).attr(m);\n      };\n\n      g.prototype.updateCenter = function (g) {\n        this.center = (g || this.axis || {}).center = c.getCenter.call(this);\n      };\n\n      g.prototype.update = function (g, e) {\n        p(!0, this.options, g);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (g) {\n          g.pane === this && (g.pane = null, g.update({}, e));\n        }, this);\n      };\n\n      return g;\n    }();\n\n    b.prototype.getHoverPane = function (g) {\n      var e = this,\n          m;\n      g && e.pane.forEach(function (k) {\n        w(g.chartX - e.plotLeft, g.chartY - e.plotTop, k.center) && (m = k);\n      });\n      return m;\n    };\n\n    d(b, \"afterIsInsidePlot\", function (g) {\n      if (this.polar) {\n        if (g.options.inverted) {\n          var e = [g.y, g.x];\n          g.x = e[0];\n          g.y = e[1];\n        }\n\n        g.isInsidePlot = this.pane.some(function (e) {\n          return w(g.x, g.y, e.center, e.axis && e.axis.normalizedStartAngleRad, e.axis && e.axis.normalizedEndAngleRad);\n        });\n      }\n    });\n    d(a, \"beforeGetHoverData\", function (g) {\n      var e = this.chart;\n      e.polar ? (e.hoverPane = e.getHoverPane(g), g.filter = function (k) {\n        return k.visible && !(!g.shared && k.directTouch) && l(k.options.enableMouseTracking, !0) && (!e.hoverPane || k.xAxis.pane === e.hoverPane);\n      }) : e.hoverPane = void 0;\n    });\n    d(a, \"afterGetHoverData\", function (g) {\n      var e = this.chart;\n      g.hoverPoint && g.hoverPoint.plotX && g.hoverPoint.plotY && e.hoverPane && !w(g.hoverPoint.plotX, g.hoverPoint.plotY, e.hoverPane.center) && (g.hoverPoint = void 0);\n    });\n    h.Pane = f;\n    return h.Pane;\n  });\n  D(d, \"Series/AreaRange/AreaRangePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var h = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function f() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n      };\n    }();\n\n    b = b.seriesTypes.area.prototype;\n    var a = b.pointClass.prototype,\n        f = c.defined,\n        d = c.isNumber;\n    return function (c) {\n      function b() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.high = void 0;\n        a.low = void 0;\n        a.options = void 0;\n        a.plotX = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      h(b, c);\n\n      b.prototype.setState = function () {\n        var c = this.state,\n            b = this.series,\n            h = b.chart.polar;\n        f(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0));\n        f(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0));\n        b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic);\n        this.graphic = this.graphics && this.graphics[1];\n        this.plotY = this.plotHigh;\n        h && d(this.plotHighX) && (this.plotX = this.plotHighX);\n        a.setState.apply(this, arguments);\n        this.state = c;\n        this.plotY = this.plotLow;\n        this.graphic = this.graphics && this.graphics[0];\n        h && d(this.plotLowX) && (this.plotX = this.plotLowX);\n        b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0);\n        a.setState.apply(this, arguments);\n      };\n\n      b.prototype.haloPath = function () {\n        var b = this.series.chart.polar,\n            c = [];\n        this.plotY = this.plotLow;\n        b && d(this.plotLowX) && (this.plotX = this.plotLowX);\n        this.isInside && (c = a.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        b && d(this.plotHighX) && (this.plotX = this.plotHighX);\n        this.isTopInside && (c = c.concat(a.haloPath.apply(this, arguments)));\n        return c;\n      };\n\n      b.prototype.isValid = function () {\n        return d(this.low) && d(this.high);\n      };\n\n      return b;\n    }(b.pointClass);\n  });\n  D(d, \"Series/AreaRange/AreaRangeSeries.js\", [d[\"Series/AreaRange/AreaRangePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var g = function (e, k) {\n        g = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (g, e) {\n          g.__proto__ = e;\n        } || function (g, e) {\n          for (var k in e) e.hasOwnProperty(k) && (g[k] = e[k]);\n        };\n\n        return g(e, k);\n      };\n\n      return function (e, k) {\n        function m() {\n          this.constructor = e;\n        }\n\n        g(e, k);\n        e.prototype = null === k ? Object.create(k) : (m.prototype = k.prototype, new m());\n      };\n    }();\n\n    c = c.noop;\n    var d = h.seriesTypes,\n        n = d.area,\n        r = d.area.prototype,\n        q = d.column.prototype;\n    d = a.addEvent;\n    var F = a.defined,\n        p = a.extend,\n        l = a.isArray,\n        e = a.isNumber,\n        g = a.pick,\n        k = a.merge,\n        m = {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    };\n\n    a = function (e) {\n      function a() {\n        var g = null !== e && e.apply(this, arguments) || this;\n        g.data = void 0;\n        g.options = void 0;\n        g.points = void 0;\n        g.lowerStateMarkerGraphic = void 0;\n        g.xAxis = void 0;\n        return g;\n      }\n\n      f(a, e);\n\n      a.prototype.toYData = function (g) {\n        return [g.low, g.high];\n      };\n\n      a.prototype.highToXY = function (g) {\n        var e = this.chart,\n            k = this.xAxis.postTranslate(g.rectPlotX || 0, this.yAxis.len - (g.plotHigh || 0));\n        g.plotHighX = k.x - e.plotLeft;\n        g.plotHigh = k.y - e.plotTop;\n        g.plotLowX = g.plotX;\n      };\n\n      a.prototype.getGraphPath = function (e) {\n        var k = [],\n            a = [],\n            m = r.getGraphPath,\n            b = this.options,\n            c = this.chart.polar,\n            x = c && !1 !== b.connectEnds,\n            B = b.connectNulls,\n            y,\n            f = b.step;\n        e = e || this.points;\n\n        for (y = e.length; y--;) {\n          var t = e[y];\n          var G = c ? {\n            plotX: t.rectPlotX,\n            plotY: t.yBottom,\n            doCurve: !1\n          } : {\n            plotX: t.plotX,\n            plotY: t.plotY,\n            doCurve: !1\n          };\n          t.isNull || x || B || e[y + 1] && !e[y + 1].isNull || a.push(G);\n          var l = {\n            polarPlotY: t.polarPlotY,\n            rectPlotX: t.rectPlotX,\n            yBottom: t.yBottom,\n            plotX: g(t.plotHighX, t.plotX),\n            plotY: t.plotHigh,\n            isNull: t.isNull\n          };\n          a.push(l);\n          k.push(l);\n          t.isNull || x || B || e[y - 1] && !e[y - 1].isNull || a.push(G);\n        }\n\n        e = m.call(this, e);\n        f && (!0 === f && (f = \"left\"), b.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[f]);\n        k = m.call(this, k);\n        a = m.call(this, a);\n        b.step = f;\n        b = [].concat(e, k);\n        !this.chart.polar && a[0] && \"M\" === a[0][0] && (a[0] = [\"L\", a[0][1], a[0][2]]);\n        this.graphPath = b;\n        this.areaPath = e.concat(a);\n        b.isArea = !0;\n        b.xMap = e.xMap;\n        this.areaPath.xMap = e.xMap;\n        return b;\n      };\n\n      a.prototype.drawDataLabels = function () {\n        var e = this.points,\n            g = e.length,\n            k = [],\n            a = this.options.dataLabels,\n            m = this.chart.inverted,\n            b,\n            x;\n\n        if (a) {\n          if (l(a)) {\n            var c = a[0] || {\n              enabled: !1\n            };\n            var y = a[1] || {\n              enabled: !1\n            };\n          } else c = p({}, a), c.x = a.xHigh, c.y = a.yHigh, y = p({}, a), y.x = a.xLow, y.y = a.yLow;\n\n          if (c.enabled || this._hasPointLabels) {\n            for (b = g; b--;) if (x = e[b]) {\n              var f = x.plotHigh;\n              f = void 0 === f ? 0 : f;\n              var t = x.plotLow;\n              t = void 0 === t ? 0 : t;\n              t = c.inside ? f < t : f > t;\n              x.y = x.high;\n              x._plotY = x.plotY;\n              x.plotY = f;\n              k[b] = x.dataLabel;\n              x.dataLabel = x.dataLabelUpper;\n              x.below = t;\n              m ? c.align || (c.align = t ? \"right\" : \"left\") : c.verticalAlign || (c.verticalAlign = t ? \"top\" : \"bottom\");\n            }\n\n            this.options.dataLabels = c;\n            r.drawDataLabels && r.drawDataLabels.apply(this, arguments);\n\n            for (b = g; b--;) if (x = e[b]) x.dataLabelUpper = x.dataLabel, x.dataLabel = k[b], delete x.dataLabels, x.y = x.low, x.plotY = x._plotY;\n          }\n\n          if (y.enabled || this._hasPointLabels) {\n            for (b = g; b--;) if (x = e[b]) k = x.plotHigh, f = void 0 === k ? 0 : k, k = x.plotLow, t = void 0 === k ? 0 : k, t = y.inside ? f < t : f > t, x.below = !t, m ? y.align || (y.align = t ? \"left\" : \"right\") : y.verticalAlign || (y.verticalAlign = t ? \"bottom\" : \"top\");\n\n            this.options.dataLabels = y;\n            r.drawDataLabels && r.drawDataLabels.apply(this, arguments);\n          }\n\n          if (c.enabled) for (b = g; b--;) if (x = e[b]) x.dataLabels = [x.dataLabelUpper, x.dataLabel].filter(function (e) {\n            return !!e;\n          });\n          this.options.dataLabels = a;\n        }\n      };\n\n      a.prototype.alignDataLabel = function () {\n        q.alignDataLabel.apply(this, arguments);\n      };\n\n      a.prototype.drawPoints = function () {\n        var e = this.points.length,\n            k;\n        r.drawPoints.apply(this, arguments);\n\n        for (k = 0; k < e;) {\n          var a = this.points[k];\n          a.graphics = a.graphics || [];\n          a.origProps = {\n            plotY: a.plotY,\n            plotX: a.plotX,\n            isInside: a.isInside,\n            negative: a.negative,\n            zone: a.zone,\n            y: a.y\n          };\n          if (a.graphic || a.graphics[0]) a.graphics[0] = a.graphic;\n          a.graphic = a.graphics[1];\n          a.plotY = a.plotHigh;\n          F(a.plotHighX) && (a.plotX = a.plotHighX);\n          a.y = g(a.high, a.origProps.y);\n          a.negative = a.y < (this.options.threshold || 0);\n          this.zones.length && (a.zone = a.getZone());\n          this.chart.polar || (a.isInside = a.isTopInside = \"undefined\" !== typeof a.plotY && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len);\n          k++;\n        }\n\n        r.drawPoints.apply(this, arguments);\n\n        for (k = 0; k < e;) {\n          a = this.points[k];\n          a.graphics = a.graphics || [];\n          if (a.graphic || a.graphics[1]) a.graphics[1] = a.graphic;\n          a.graphic = a.graphics[0];\n          a.origProps && (p(a, a.origProps), delete a.origProps);\n          k++;\n        }\n      };\n\n      a.defaultOptions = k(n.defaultOptions, m);\n      return a;\n    }(n);\n\n    d(a, \"afterTranslate\", function () {\n      var g = this;\n      \"low,high\" === this.pointArrayMap.join(\",\") && this.points.forEach(function (a) {\n        var k = a.high,\n            m = a.plotY;\n        a.isNull ? a.plotY = void 0 : (a.plotLow = m, a.plotHigh = e(k) ? g.yAxis.translate(g.dataModify ? g.dataModify.modifyValue(k) : k, !1, !0, void 0, !0) : void 0, g.dataModify && (a.yBottom = a.plotHigh));\n      });\n    }, {\n      order: 0\n    });\n    d(a, \"afterTranslate\", function () {\n      var e = this;\n      this.points.forEach(function (g) {\n        if (e.chart.polar) e.highToXY(g), g.plotLow = g.plotY, g.tooltipPos = [((g.plotHighX || 0) + (g.plotLowX || 0)) / 2, ((g.plotHigh || 0) + (g.plotLow || 0)) / 2];else {\n          var a = g.pos(!1, g.plotLow),\n              k = g.pos(!1, g.plotHigh);\n          a && k && (a[0] = (a[0] + k[0]) / 2, a[1] = (a[1] + k[1]) / 2);\n          g.tooltipPos = a;\n        }\n      });\n    }, {\n      order: 3\n    });\n    p(a.prototype, {\n      deferTranslatePolar: !0,\n      pointArrayMap: [\"low\", \"high\"],\n      pointClass: b,\n      pointValKey: \"low\",\n      setStackedPoints: c\n    });\n    h.registerSeriesType(\"arearange\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [d[\"Series/AreaRange/AreaRangeSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var e in b) b.hasOwnProperty(e) && (a[e] = b[e]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        f = c.seriesTypes.spline.prototype,\n        d = h.merge;\n\n    h = h.extend;\n\n    var n = function (c) {\n      function f() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.data = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      a(f, c);\n      f.defaultOptions = d(b.defaultOptions);\n      return f;\n    }(b);\n\n    h(n.prototype, {\n      getPointSpline: f.getPointSpline\n    });\n    c.registerSeriesType(\"areasplinerange\", n);\n    \"\";\n    return n;\n  });\n  D(d, \"Series/BoxPlot/BoxPlotSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var g in e) e.hasOwnProperty(g) && (a[g] = e[g]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    c = c.noop;\n    var d = a.extend,\n        n = a.merge,\n        r = a.pick;\n\n    a = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      f(c, a);\n\n      c.prototype.pointAttribs = function () {\n        return {};\n      };\n\n      c.prototype.translate = function () {\n        var b = this.yAxis,\n            c = this.pointArrayMap;\n        a.prototype.translate.apply(this);\n        this.points.forEach(function (a) {\n          c.forEach(function (g) {\n            null !== a[g] && (a[g + \"Plot\"] = b.translate(a[g], 0, 1, 0, 1));\n          });\n          a.plotHigh = a.highPlot;\n        });\n      };\n\n      c.prototype.drawPoints = function () {\n        var a = this,\n            b = a.options,\n            e = a.chart,\n            g = e.renderer,\n            k,\n            c,\n            f,\n            h,\n            d,\n            E,\n            v = 0,\n            n,\n            I,\n            K,\n            x,\n            B = !1 !== a.doQuartiles,\n            y,\n            H = a.options.whiskerLength;\n        a.points.forEach(function (m) {\n          var t = m.graphic,\n              G = t ? \"animate\" : \"attr\",\n              N = m.shapeArgs,\n              L = {},\n              l = {},\n              w = {},\n              u = {},\n              C = m.color || a.color;\n          \"undefined\" !== typeof m.plotY && (n = Math.round(N.width), I = Math.floor(N.x), K = I + n, x = Math.round(n / 2), k = Math.floor(B ? m.q1Plot : m.lowPlot), c = Math.floor(B ? m.q3Plot : m.lowPlot), f = Math.floor(m.highPlot), h = Math.floor(m.lowPlot), t || (m.graphic = t = g.g(\"point\").add(a.group), m.stem = g.path().addClass(\"highcharts-boxplot-stem\").add(t), H && (m.whiskers = g.path().addClass(\"highcharts-boxplot-whisker\").add(t)), B && (m.box = g.path(void 0).addClass(\"highcharts-boxplot-box\").add(t)), m.medianShape = g.path(void 0).addClass(\"highcharts-boxplot-median\").add(t)), e.styledMode || (l.stroke = m.stemColor || b.stemColor || C, l[\"stroke-width\"] = r(m.stemWidth, b.stemWidth, b.lineWidth), l.dashstyle = m.stemDashStyle || b.stemDashStyle || b.dashStyle, m.stem.attr(l), H && (w.stroke = m.whiskerColor || b.whiskerColor || C, w[\"stroke-width\"] = r(m.whiskerWidth, b.whiskerWidth, b.lineWidth), w.dashstyle = m.whiskerDashStyle || b.whiskerDashStyle || b.dashStyle, m.whiskers.attr(w)), B && (L.fill = m.fillColor || b.fillColor || C, L.stroke = b.lineColor || C, L[\"stroke-width\"] = b.lineWidth || 0, L.dashstyle = m.boxDashStyle || b.boxDashStyle || b.dashStyle, m.box.attr(L)), u.stroke = m.medianColor || b.medianColor || C, u[\"stroke-width\"] = r(m.medianWidth, b.medianWidth, b.lineWidth), u.dashstyle = m.medianDashStyle || b.medianDashStyle || b.dashStyle, m.medianShape.attr(u)), E = m.stem.strokeWidth() % 2 / 2, v = I + x + E, t = [[\"M\", v, c], [\"L\", v, f], [\"M\", v, k], [\"L\", v, h]], m.stem[G]({\n            d: t\n          }), B && (E = m.box.strokeWidth() % 2 / 2, k = Math.floor(k) + E, c = Math.floor(c) + E, I += E, K += E, t = [[\"M\", I, c], [\"L\", I, k], [\"L\", K, k], [\"L\", K, c], [\"L\", I, c], [\"Z\"]], m.box[G]({\n            d: t\n          })), H && (E = m.whiskers.strokeWidth() % 2 / 2, f += E, h += E, y = /%$/.test(H) ? x * parseFloat(H) / 100 : H / 2, t = [[\"M\", v - y, f], [\"L\", v + y, f], [\"M\", v - y, h], [\"L\", v + y, h]], m.whiskers[G]({\n            d: t\n          })), d = Math.round(m.medianPlot), E = m.medianShape.strokeWidth() % 2 / 2, d += E, t = [[\"M\", I, d], [\"L\", K, d]], m.medianShape[G]({\n            d: t\n          }));\n        });\n      };\n\n      c.prototype.toYData = function (a) {\n        return [a.low, a.q1, a.median, a.q3, a.high];\n      };\n\n      c.defaultOptions = n(b.defaultOptions, {\n        threshold: null,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n        },\n        whiskerLength: \"50%\",\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        medianWidth: 2,\n        whiskerWidth: 2\n      });\n      return c;\n    }(b);\n\n    d(a.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: c,\n      setStackedPoints: c\n    });\n    h.registerSeriesType(\"boxplot\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"10px\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  });\n  D(d, \"Series/Bubble/BubbleLegendItem.js\", [d[\"Core/Color/Color.js\"], d[\"Core/FormatUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = b.parse,\n        d = h.noop,\n        n = a.arrayMax,\n        r = a.arrayMin,\n        q = a.isNumber,\n        F = a.merge,\n        p = a.pick,\n        l = a.stableSort;\n\n    b = function () {\n      function a(a, e) {\n        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = d;\n        this.init(a, e);\n      }\n\n      a.prototype.init = function (a, e) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = e.chart;\n        this.legend = e;\n      };\n\n      a.prototype.addToLegend = function (a) {\n        a.splice(this.options.legendIndex, 0, this);\n      };\n\n      a.prototype.drawLegendSymbol = function (a) {\n        var g = this.chart,\n            e = p(a.options.itemDistance, 20),\n            b = this.legendItem || {},\n            c = this.options,\n            f = c.ranges,\n            h = c.connectorDistance;\n        this.fontMetrics = g.renderer.fontMetrics(c.labels.style.fontSize);\n        f && f.length && q(f[0].value) ? (l(f, function (a, g) {\n          return g.value - a.value;\n        }), this.ranges = f, this.setOptions(), this.render(), a = this.getMaxLabelSize(), f = this.ranges[0].radius, g = 2 * f, h = h - f + a.width, h = 0 < h ? h : 0, this.maxLabel = a, this.movementX = \"left\" === c.labels.align ? h : 0, b.labelWidth = g + h + e, b.labelHeight = g + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;\n      };\n\n      a.prototype.setOptions = function () {\n        var a = this.ranges,\n            e = this.options,\n            b = this.chart.series[e.seriesIndex],\n            c = this.legend.baseline,\n            h = {\n          zIndex: e.zIndex,\n          \"stroke-width\": e.borderWidth\n        },\n            d = {\n          zIndex: e.zIndex,\n          \"stroke-width\": e.connectorWidth\n        },\n            E = {\n          align: this.legend.options.rtl || \"left\" === e.labels.align ? \"right\" : \"left\",\n          zIndex: e.zIndex\n        },\n            v = b.options.marker.fillOpacity,\n            l = this.chart.styledMode;\n        a.forEach(function (g, k) {\n          l || (h.stroke = p(g.borderColor, e.borderColor, b.color), h.fill = p(g.color, e.color, 1 !== v ? f(b.color).setOpacity(v).get(\"rgba\") : b.color), d.stroke = p(g.connectorColor, e.connectorColor, b.color));\n          a[k].radius = this.getRangeRadius(g.value);\n          a[k] = F(a[k], {\n            center: a[0].radius - a[k].radius + c\n          });\n          l || F(!0, a[k], {\n            bubbleAttribs: F(h),\n            connectorAttribs: F(d),\n            labelAttribs: E\n          });\n        }, this);\n      };\n\n      a.prototype.getRangeRadius = function (a) {\n        var e = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, e.ranges[e.ranges.length - 1].value, e.ranges[0].value, e.minSize, e.maxSize, a);\n      };\n\n      a.prototype.render = function () {\n        var a = this.legendItem || {},\n            e = this.chart.renderer,\n            b = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        a.symbol = e.g(\"bubble-legend\");\n        a.label = e.g(\"bubble-legend-item\");\n        a.symbol.translateX = 0;\n        e = a.symbol.translateY = 0;\n\n        for (var c = this.ranges; e < c.length; e++) {\n          var f = c[e];\n          f.value >= b && this.renderRange(f);\n        }\n\n        a.symbol.add(a.label);\n        a.label.add(a.group);\n        this.hideOverlappingLabels();\n      };\n\n      a.prototype.renderRange = function (a) {\n        var e = this.options,\n            g = e.labels,\n            b = this.chart,\n            c = b.series[e.seriesIndex],\n            f = b.renderer,\n            h = this.symbols;\n        b = h.labels;\n        var d = a.center,\n            l = Math.abs(a.radius),\n            I = e.connectorDistance || 0,\n            K = g.align,\n            x = e.connectorWidth,\n            B = this.ranges[0].radius || 0,\n            y = d - l - e.borderWidth / 2 + x / 2,\n            H = this.fontMetrics;\n        H = H.f / 2 - (H.h - H.f) / 2;\n        var t = f.styledMode;\n        I = this.legend.options.rtl || \"left\" === K ? -I : I;\n        \"center\" === K && (I = 0, e.connectorDistance = 0, a.labelAttribs.align = \"center\");\n        K = y + e.labels.y;\n        var n = B + I + e.labels.x;\n        h.bubbleItems.push(f.circle(B, d + ((y % 1 ? 1 : .5) - (x % 2 ? 0 : .5)), l).attr(t ? {} : a.bubbleAttribs).addClass((t ? \"highcharts-color-\" + c.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (e.className || \"\")).add(this.legendItem.symbol));\n        h.connectors.push(f.path(f.crispLine([[\"M\", B, y], [\"L\", B + I, y]], e.connectorWidth)).attr(t ? {} : a.connectorAttribs).addClass((t ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (e.connectorClassName || \"\")).add(this.legendItem.symbol));\n        a = f.text(this.formatLabel(a), n, K + H).attr(t ? {} : a.labelAttribs).css(t ? {} : g.style).addClass(\"highcharts-bubble-legend-labels \" + (e.labels.className || \"\")).add(this.legendItem.symbol);\n        b.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: n,\n          y: K + H\n        };\n      };\n\n      a.prototype.getMaxLabelSize = function () {\n        var a, e;\n        this.symbols.labels.forEach(function (g) {\n          e = g.getBBox(!0);\n          a = a ? e.width > a.width ? e : a : e;\n        });\n        return a || {};\n      };\n\n      a.prototype.formatLabel = function (a) {\n        var e = this.options,\n            g = e.labels.formatter;\n        e = e.labels.format;\n        var b = this.chart.numberFormatter;\n        return e ? c.format(e, a) : g ? g.call(a) : b(a.value, 1);\n      };\n\n      a.prototype.hideOverlappingLabels = function () {\n        var a = this.chart,\n            e = this.symbols;\n        !this.options.labels.allowOverlap && e && (a.hideOverlappingLabels(e.labels), e.labels.forEach(function (a, g) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && e.connectors[g].show() : e.connectors[g].hide();\n        }));\n      };\n\n      a.prototype.getRanges = function () {\n        var a = this.legend.bubbleLegend,\n            e = a.options.ranges,\n            b,\n            c = Number.MAX_VALUE,\n            f = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (b = a.zData.filter(q), b.length && (c = p(a.options.zMin, Math.min(c, Math.max(r(b), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), f = p(a.options.zMax, Math.max(f, n(b)))));\n        });\n        var h = c === f ? [{\n          value: f\n        }] : [{\n          value: c\n        }, {\n          value: (c + f) / 2\n        }, {\n          value: f,\n          autoRanges: !0\n        }];\n        e.length && e[0].radius && h.reverse();\n        h.forEach(function (a, g) {\n          e && e[g] && (h[g] = F(e[g], a));\n        });\n        return h;\n      };\n\n      a.prototype.predictBubbleSizes = function () {\n        var a = this.chart,\n            e = this.fontMetrics,\n            b = a.legend.options,\n            c = b.floating,\n            f = (b = \"horizontal\" === b.layout) ? a.legend.lastLineHeight : 0,\n            h = a.plotSizeX,\n            d = a.plotSizeY,\n            v = a.series[this.options.seriesIndex],\n            l = v.getPxExtremes();\n        a = Math.ceil(l.minPxSize);\n        l = Math.ceil(l.maxPxSize);\n        var I = Math.min(d, h);\n        v = v.options.maxSize;\n        if (c || !/%$/.test(v)) e = l;else if (v = parseFloat(v), e = (I + f - e.h / 2) * v / 100 / (v / 100 + 1), b && d - e >= h || !b && h - e >= d) e = l;\n        return [a, Math.ceil(e)];\n      };\n\n      a.prototype.updateRanges = function (a, e) {\n        var b = this.legend.options.bubbleLegend;\n        b.minSize = a;\n        b.maxSize = e;\n        b.ranges = this.getRanges();\n      };\n\n      a.prototype.correctSizes = function () {\n        var a = this.legend,\n            e = this.chart.series[this.options.seriesIndex].getPxExtremes();\n        1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), a.render());\n      };\n\n      return a;\n    }();\n\n    \"\";\n    return b;\n  });\n  D(d, \"Series/Bubble/BubbleLegendComposition.js\", [d[\"Series/Bubble/BubbleLegendDefaults.js\"], d[\"Series/Bubble/BubbleLegendItem.js\"], d[\"Core/Defaults.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    function f(a, b, g) {\n      var c = this.legend,\n          m = 0 <= d(this),\n          f;\n\n      if (c && c.options.enabled && c.bubbleLegend && c.options.bubbleLegend.autoRanges && m) {\n        var k = c.bubbleLegend.options;\n        m = c.bubbleLegend.predictBubbleSizes();\n        c.bubbleLegend.updateRanges(m[0], m[1]);\n        k.placed || (c.group.placed = !1, c.allItems.forEach(function (a) {\n          f = a.legendItem || {};\n          f.group && (f.group.translateY = null);\n        }));\n        c.render();\n        this.getMargins();\n        this.axes.forEach(function (a) {\n          a.visible && a.render();\n          k.placed || (a.setScale(), a.updateNames(), e(a.ticks, function (a) {\n            a.isNew = !0;\n            a.isNewLabel = !0;\n          }));\n        });\n        k.placed = !0;\n        this.getMargins();\n        a.call(this, b, g);\n        c.bubbleLegend.correctSizes();\n        F(c, n(c));\n      } else a.call(this, b, g), c && c.options.enabled && c.bubbleLegend && (c.render(), F(c, n(c)));\n    }\n\n    function d(a) {\n      a = a.series;\n\n      for (var e = 0; e < a.length;) {\n        if (a[e] && a[e].isBubble && a[e].visible && a[e].zData.length) return e;\n        e++;\n      }\n\n      return -1;\n    }\n\n    function n(a) {\n      a = a.allItems;\n      var e = [],\n          b = a.length,\n          g,\n          c = 0;\n\n      for (g = 0; g < b; g++) {\n        var f = a[g].legendItem || {};\n        var k = (a[g + 1] || {}).legendItem || {};\n        f.labelHeight && (a[g].itemHeight = f.labelHeight);\n\n        if (a[g] === a[b - 1] || f.y !== k.y) {\n          e.push({\n            height: 0\n          });\n          f = e[e.length - 1];\n\n          for (c; c <= g; c++) a[c].itemHeight > f.height && (f.height = a[c].itemHeight);\n\n          f.step = g;\n        }\n      }\n\n      return e;\n    }\n\n    function r(a) {\n      var e = this.bubbleLegend,\n          b = this.options,\n          g = b.bubbleLegend,\n          f = d(this.chart);\n      e && e.ranges && e.ranges.length && (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges), this.destroyItem(e));\n      0 <= f && b.enabled && g.enabled && (g.seriesIndex = f, this.bubbleLegend = new c(g, this), this.bubbleLegend.addToLegend(a.allItems));\n    }\n\n    function q() {\n      var a = this.chart,\n          e = this.visible,\n          b = this.chart.legend;\n      b && b.bubbleLegend && (this.visible = !e, this.ignoreSeries = e, a = 0 <= d(a), b.bubbleLegend.visible !== a && (b.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), b.bubbleLegend.visible = a), this.visible = e);\n    }\n\n    function F(a, e) {\n      var b = a.options.rtl,\n          g,\n          c,\n          f,\n          k,\n          m = 0;\n      a.allItems.forEach(function (a, x) {\n        k = a.legendItem || {};\n\n        if (k.group) {\n          g = k.group.translateX || 0;\n          c = k.y || 0;\n          if ((f = a.movementX) || b && a.ranges) f = b ? g - a.options.maxSize / 2 : g + f, k.group.attr({\n            translateX: f\n          });\n          x > e[m].step && m++;\n          k.group.attr({\n            translateY: Math.round(c + e[m].height / 2)\n          });\n          k.y = c + e[m].height / 2;\n        }\n      });\n    }\n\n    var p = h.setOptions,\n        l = a.addEvent,\n        e = a.objectEach,\n        g = a.wrap,\n        k = [];\n    return {\n      compose: function (a, e, c) {\n        -1 === k.indexOf(a) && (k.push(a), p({\n          legend: {\n            bubbleLegend: b\n          }\n        }), g(a.prototype, \"drawChartBox\", f));\n        -1 === k.indexOf(e) && (k.push(e), l(e, \"afterGetAllItems\", r));\n        -1 === k.indexOf(c) && (k.push(c), l(c, \"legendItemClick\", q));\n      }\n    };\n  });\n  D(d, \"Series/Bubble/BubblePoint.js\", [d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    h = h.extend;\n\n    c = function (c) {\n      function f() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(f, c);\n\n      f.prototype.haloPath = function (a) {\n        return b.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      };\n\n      return f;\n    }(c.seriesTypes.scatter.prototype.pointClass);\n\n    h(c.prototype, {\n      ttBelow: !1\n    });\n    return c;\n  });\n  D(d, \"Series/Bubble/BubbleSeries.js\", [d[\"Series/Bubble/BubbleLegendComposition.js\"], d[\"Series/Bubble/BubblePoint.js\"], d[\"Core/Color/Color.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f, d) {\n    function n() {\n      var a = this,\n          e = this.len,\n          b = this.chart,\n          g = this.isXAxis,\n          c = g ? \"xData\" : \"yData\",\n          f = this.min,\n          k = this.max - f,\n          m = 0,\n          d = e,\n          h = e / k,\n          l;\n      this.series.forEach(function (e) {\n        if (e.bubblePadding && (e.visible || !b.options.chart.ignoreHiddenSeries)) {\n          l = a.allowZoomOutside = !0;\n          var x = e[c];\n          g && ((e.onPoint || e).getRadii(0, 0, e), e.onPoint && (e.radii = e.onPoint.radii));\n          if (0 < k) for (var B = x.length; B--;) if (N(x[B]) && a.dataMin <= x[B] && x[B] <= a.max) {\n            var y = e.radii && e.radii[B] || 0;\n            m = Math.min((x[B] - f) * h - y, m);\n            d = Math.max((x[B] - f) * h + y, d);\n          }\n        }\n      });\n      l && 0 < k && !this.logarithmic && (d -= e, h *= (e + Math.max(0, m) - Math.min(d, e)) / e, [[\"min\", \"userMin\", m], [\"max\", \"userMax\", d]].forEach(function (e) {\n        \"undefined\" === typeof L(a.options[e[0]], a[e[1]]) && (a[e[0]] += e[2] / h);\n      }));\n    }\n\n    var w = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function g() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());\n      };\n    }(),\n        q = h.parse;\n\n    h = a.noop;\n    var F = f.series,\n        p = f.seriesTypes;\n    a = p.column.prototype;\n    var l = p.scatter;\n    p = d.addEvent;\n    var e = d.arrayMax,\n        g = d.arrayMin,\n        k = d.clamp,\n        m = d.extend,\n        N = d.isNumber,\n        G = d.merge,\n        L = d.pick,\n        E = [];\n\n    d = function (a) {\n      function c() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.maxPxSize = void 0;\n        e.minPxSize = void 0;\n        e.options = void 0;\n        e.points = void 0;\n        e.radii = void 0;\n        e.yData = void 0;\n        e.zData = void 0;\n        return e;\n      }\n\n      w(c, a);\n\n      c.compose = function (a, e, c, g) {\n        b.compose(e, c, g);\n        -1 === E.indexOf(a) && (E.push(a), a.prototype.beforePadding = n);\n      };\n\n      c.prototype.animate = function (a) {\n        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {\n          var e = a.graphic;\n          e && e.width && (this.hasRendered || e.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), e.animate(this.markerAttribs(a), this.options.animation));\n        }, this);\n      };\n\n      c.prototype.getRadii = function () {\n        var a = this,\n            e = this.zData,\n            b = this.yData,\n            c = [],\n            g = this.chart.bubbleZExtremes;\n        var f = this.getPxExtremes();\n        var k = f.minPxSize,\n            m = f.maxPxSize;\n\n        if (!g) {\n          var d = Number.MAX_VALUE,\n              h = -Number.MAX_VALUE,\n              l;\n          this.chart.series.forEach(function (e) {\n            e.bubblePadding && (e.visible || !a.chart.options.chart.ignoreHiddenSeries) && (e = (e.onPoint || e).getZExtremes()) && (d = Math.min(d || e.zMin, e.zMin), h = Math.max(h || e.zMax, e.zMax), l = !0);\n          });\n          l ? (g = {\n            zMin: d,\n            zMax: h\n          }, this.chart.bubbleZExtremes = g) : g = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n\n        var n = 0;\n\n        for (f = e.length; n < f; n++) {\n          var v = e[n];\n          c.push(this.getRadius(g.zMin, g.zMax, k, m, v, b && b[n]));\n        }\n\n        this.radii = c;\n      };\n\n      c.prototype.getRadius = function (a, e, b, c, g, f) {\n        var x = this.options,\n            k = \"width\" !== x.sizeBy,\n            m = x.zThreshold,\n            d = e - a,\n            h = .5;\n        if (null === f || null === g) return null;\n\n        if (N(g)) {\n          x.sizeByAbsoluteValue && (g = Math.abs(g - m), d = Math.max(e - m, Math.abs(a - m)), a = 0);\n          if (g < a) return b / 2 - 1;\n          0 < d && (h = (g - a) / d);\n        }\n\n        k && 0 <= h && (h = Math.sqrt(h));\n        return Math.ceil(b + h * (c - b)) / 2;\n      };\n\n      c.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      c.prototype.pointAttribs = function (a, e) {\n        var b = this.options.marker.fillOpacity;\n        a = F.prototype.pointAttribs.call(this, a, e);\n        1 !== b && (a.fill = q(a.fill).setOpacity(b).get(\"rgba\"));\n        return a;\n      };\n\n      c.prototype.translate = function () {\n        a.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n\n      c.prototype.translateBubble = function () {\n        for (var a = this.data, e = this.radii, b = this.getPxExtremes().minPxSize, c = a.length; c--;) {\n          var g = a[c],\n              f = e ? e[c] : 0;\n          N(f) && f >= b / 2 ? (g.marker = m(g.marker, {\n            radius: f,\n            width: 2 * f,\n            height: 2 * f\n          }), g.dlBox = {\n            x: g.plotX - f,\n            y: g.plotY - f,\n            width: 2 * f,\n            height: 2 * f\n          }) : (g.shapeArgs = g.plotY = g.dlBox = void 0, g.isInside = !1);\n        }\n      };\n\n      c.prototype.getPxExtremes = function () {\n        var a = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n            e = function (e) {\n          if (\"string\" === typeof e) {\n            var b = /%$/.test(e);\n            e = parseInt(e, 10);\n          }\n\n          return b ? a * e / 100 : e;\n        },\n            b = e(L(this.options.minSize, 8));\n\n        e = Math.max(e(L(this.options.maxSize, \"20%\")), b);\n        return {\n          minPxSize: b,\n          maxPxSize: e\n        };\n      };\n\n      c.prototype.getZExtremes = function () {\n        var a = this.options,\n            b = (this.zData || []).filter(N);\n\n        if (b.length) {\n          var c = L(a.zMin, k(g(b), !1 === a.displayNegative ? a.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));\n          a = L(a.zMax, e(b));\n          if (N(c) && N(a)) return {\n            zMin: c,\n            zMax: a\n          };\n        }\n      };\n\n      c.defaultOptions = G(l.defaultOptions, {\n        dataLabels: {\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n                e = this.point.z;\n            return N(e) ? a(e, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        animationLimit: 250,\n        marker: {\n          lineColor: null,\n          lineWidth: 1,\n          fillOpacity: .5,\n          radius: null,\n          states: {\n            hover: {\n              radiusPlus: 0\n            }\n          },\n          symbol: \"circle\"\n        },\n        minSize: 8,\n        maxSize: \"20%\",\n        softThreshold: !1,\n        states: {\n          hover: {\n            halo: {\n              size: 5\n            }\n          }\n        },\n        tooltip: {\n          pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: \"z\"\n      });\n      return c;\n    }(l);\n\n    m(d.prototype, {\n      alignDataLabel: a.alignDataLabel,\n      applyZones: h,\n      bubblePadding: !0,\n      buildKDTree: h,\n      directTouch: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: c,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    });\n    p(d, \"updatedData\", function (a) {\n      delete a.target.chart.bubbleZExtremes;\n    });\n    p(d, \"remove\", function (a) {\n      delete a.target.chart.bubbleZExtremes;\n    });\n    f.registerSeriesType(\"bubble\", d);\n    \"\";\n    \"\";\n    return d;\n  });\n  D(d, \"Series/ColumnRange/ColumnRangePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        a = b.seriesTypes;\n\n    b = a.column.prototype.pointClass.prototype;\n    var f = c.extend,\n        d = c.isNumber;\n\n    c = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.prototype.isValid = function () {\n        return d(this.low);\n      };\n\n      return b;\n    }(a.arearange.prototype.pointClass);\n\n    f(c.prototype, {\n      setState: b.setState\n    });\n    return c;\n  });\n  D(d, \"Series/ColumnRange/ColumnRangeSeries.js\", [d[\"Series/ColumnRange/ColumnRangePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function c() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    c = c.noop;\n    var h = d.seriesTypes,\n        n = h.arearange,\n        r = h.column,\n        q = h.column.prototype,\n        F = a.clamp;\n    h = a.extend;\n    var p = a.isNumber,\n        l = a.merge,\n        e = a.pick,\n        g = {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    };\n\n    a = function (a) {\n      function b() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      f(b, a);\n\n      b.prototype.setOptions = function () {\n        l(!0, arguments[0], {\n          stacking: void 0\n        });\n        return n.prototype.setOptions.apply(this, arguments);\n      };\n\n      b.prototype.translate = function () {\n        var a = this,\n            b = this.yAxis,\n            c = this.xAxis,\n            g = c.startAngleRad,\n            f = this.chart,\n            k = this.xAxis.isRadial,\n            d = Math.max(f.chartWidth, f.chartHeight) + 999,\n            h,\n            x,\n            m,\n            l;\n        q.translate.apply(this);\n        this.points.forEach(function (B) {\n          var t = B.shapeArgs || {},\n              y = a.options.minPointLength,\n              n = B.plotY,\n              H = b.translate(B.high, 0, 1, 0, 1);\n          p(H) && p(n) && (B.plotHigh = F(H, -d, d), B.plotLow = F(n, -d, d), l = B.plotHigh, h = e(B.rectPlotY, B.plotY) - B.plotHigh, Math.abs(h) < y ? (x = y - h, h += x, l -= x / 2) : 0 > h && (h *= -1, l -= h), k && a.polar ? (m = B.barX + g, B.shapeType = \"arc\", B.shapeArgs = a.polar.arc(l + h, l, m, m + B.pointWidth)) : (t.height = h, t.y = l, y = t.x, y = void 0 === y ? 0 : y, t = t.width, t = void 0 === t ? 0 : t, B.tooltipPos = f.inverted ? [b.len + b.pos - f.plotLeft - l - h / 2, c.len + c.pos - f.plotTop - y - t / 2, h] : [c.left - f.plotLeft + y + t / 2, b.pos - f.plotTop + l + h / 2, h]));\n        });\n      };\n\n      b.prototype.pointAttribs = function () {\n        return q.pointAttribs.apply(this, arguments);\n      };\n\n      b.prototype.translate3dPoints = function () {\n        return q.translate3dPoints.apply(this, arguments);\n      };\n\n      b.prototype.translate3dShapes = function () {\n        return q.translate3dShapes.apply(this, arguments);\n      };\n\n      b.defaultOptions = l(r.defaultOptions, n.defaultOptions, g);\n      return b;\n    }(n);\n\n    h(a.prototype, {\n      directTouch: !0,\n      pointClass: b,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      adjustForMissingColumns: q.adjustForMissingColumns,\n      animate: q.animate,\n      crispCol: q.crispCol,\n      drawGraph: c,\n      drawPoints: q.drawPoints,\n      getSymbol: c,\n      drawTracker: q.drawTracker,\n      getColumnMetrics: q.getColumnMetrics\n    });\n    d.registerSeriesType(\"columnrange\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        f = b.prototype,\n        d = h.clamp,\n        n = h.merge,\n        r = h.pick;\n\n    h = function (c) {\n      function h() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      a(h, c);\n\n      h.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            c = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        c = a.borderWidth = r(e.borderWidth, c ? 0 : 1);\n        var k = a.yAxis,\n            h = e.threshold,\n            n = a.translatedThreshold = k.getThreshold(h),\n            G = r(e.minPointLength, 5),\n            w = a.getColumnMetrics(),\n            E = w.width,\n            v = a.barW = Math.max(E, 1 + 2 * c),\n            q = a.pointXOffset = w.offset;\n        b.inverted && (n -= .5);\n        e.pointPadding && (v = Math.ceil(v));\n        f.translate.apply(a);\n        a.points.forEach(function (c) {\n          var g = r(c.yBottom, n),\n              f = 999 + Math.abs(g),\n              m = d(c.plotY, -f, k.len + f);\n          f = c.plotX + q;\n          var y = v / 2,\n              l = Math.min(m, g);\n          g = Math.max(m, g) - l;\n          var t;\n          c.barX = f;\n          c.pointWidth = E;\n          c.tooltipPos = b.inverted ? [k.len + k.pos - b.plotLeft - m, a.xAxis.len - f - y, g] : [f + y, m + k.pos - b.plotTop, g];\n          m = h + (c.total || c.y);\n          \"percent\" === e.stacking && (m = h + (0 > c.y) ? -100 : 100);\n          m = k.toPixels(m, !0);\n          var J = (t = b.plotHeight - m - (b.plotHeight - n)) ? y * (l - m) / t : 0;\n          var w = t ? y * (l + g - m) / t : 0;\n          t = f - J + y;\n          J = f + J + y;\n          var p = f + w + y;\n          w = f - w + y;\n          var A = l - G;\n          var F = l + g;\n          0 > c.y && (A = l, F = l + g + G);\n          b.inverted && (p = k.width - l, t = m - (k.width - n), J = y * (m - p) / t, w = y * (m - (p - g)) / t, t = f + y + J, J = t - 2 * J, p = f - w + y, w = f + w + y, A = l, F = l + g - G, 0 > c.y && (F = l + g + G));\n          c.shapeType = \"path\";\n          c.shapeArgs = {\n            x: t,\n            y: A,\n            width: J - t,\n            height: g,\n            d: [[\"M\", t, A], [\"L\", J, A], [\"L\", p, F], [\"L\", w, F], [\"Z\"]]\n          };\n        });\n      };\n\n      h.defaultOptions = n(b.defaultOptions, {});\n      return h;\n    }(b);\n\n    c.registerSeriesType(\"columnpyramid\", h);\n    \"\";\n    return h;\n  });\n  D(d, \"Series/ErrorBar/ErrorBarSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      whiskerWidth: null\n    };\n  });\n  D(d, \"Series/ErrorBar/ErrorBarSeries.js\", [d[\"Series/BoxPlot/BoxPlotSeries.js\"], d[\"Series/Column/ColumnSeries.js\"], d[\"Series/ErrorBar/ErrorBarSeriesDefaults.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f) {\n    var d = this && this.__extends || function () {\n      var a = function (b, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(b, e);\n      };\n\n      return function (b, e) {\n        function c() {\n          this.constructor = b;\n        }\n\n        a(b, e);\n        b.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());\n      };\n    }(),\n        n = a.seriesTypes.arearange,\n        r = f.addEvent,\n        q = f.merge;\n\n    f = f.extend;\n\n    var F = function (a) {\n      function f() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.options = void 0;\n        e.points = void 0;\n        return e;\n      }\n\n      d(f, a);\n\n      f.prototype.getColumnMetrics = function () {\n        return this.linkedParent && this.linkedParent.columnMetrics || c.prototype.getColumnMetrics.call(this);\n      };\n\n      f.prototype.drawDataLabels = function () {\n        var a = this.pointValKey;\n        n && (n.prototype.drawDataLabels.call(this), this.data.forEach(function (e) {\n          e.y = e[a];\n        }));\n      };\n\n      f.prototype.toYData = function (a) {\n        return [a.low, a.high];\n      };\n\n      f.defaultOptions = q(b.defaultOptions, h);\n      return f;\n    }(b);\n\n    r(F, \"afterTranslate\", function () {\n      this.points.forEach(function (a) {\n        a.plotLow = a.plotY;\n      });\n    }, {\n      order: 0\n    });\n    f(F.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    });\n    a.registerSeriesType(\"errorbar\", F);\n    return F;\n  });\n  D(d, \"Series/Gauge/GaugePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"]], function (b) {\n    var c = this && this.__extends || function () {\n      var b = function (a, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return b(a, c);\n      };\n\n      return function (a, c) {\n        function f() {\n          this.constructor = a;\n        }\n\n        b(a, c);\n        a.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    return function (b) {\n      function a() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        a.shapeArgs = void 0;\n        return a;\n      }\n\n      c(a, b);\n\n      a.prototype.setState = function (a) {\n        this.state = a;\n      };\n\n      return a;\n    }(b.series.prototype.pointClass);\n  });\n  D(d, \"Series/Gauge/GaugeSeries.js\", [d[\"Series/Gauge/GaugePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function c() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    c = c.noop;\n    var d = h.series,\n        n = h.seriesTypes.column,\n        r = a.clamp,\n        q = a.isNumber,\n        F = a.extend,\n        p = a.merge,\n        l = a.pick,\n        e = a.pInt;\n\n    a = function (a) {\n      function b() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.points = void 0;\n        e.options = void 0;\n        e.yAxis = void 0;\n        return e;\n      }\n\n      f(b, a);\n\n      b.prototype.translate = function () {\n        var a = this.yAxis,\n            b = this.options,\n            c = a.center;\n        this.generatePoints();\n        this.points.forEach(function (g) {\n          var f = p(b.dial, g.dial),\n              d = e(f.radius) * c[2] / 200,\n              h = e(f.baseLength) * d / 100,\n              k = e(f.rearLength) * d / 100,\n              m = f.baseWidth,\n              x = f.topWidth,\n              B = b.overshoot,\n              y = a.startAngleRad + a.translate(g.y, void 0, void 0, void 0, !0);\n          if (q(B) || !1 === b.wrap) B = q(B) ? B / 180 * Math.PI : 0, y = r(y, a.startAngleRad - B, a.endAngleRad + B);\n          y = 180 * y / Math.PI;\n          g.shapeType = \"path\";\n          g.shapeArgs = {\n            d: f.path || [[\"M\", -k, -m / 2], [\"L\", h, -m / 2], [\"L\", d, -x / 2], [\"L\", d, x / 2], [\"L\", h, m / 2], [\"L\", -k, m / 2], [\"Z\"]],\n            translateX: c[0],\n            translateY: c[1],\n            rotation: y\n          };\n          g.plotX = c[0];\n          g.plotY = c[1];\n        });\n      };\n\n      b.prototype.drawPoints = function () {\n        var a = this,\n            e = a.chart,\n            b = a.yAxis.center,\n            c = a.pivot,\n            g = a.options,\n            f = g.pivot,\n            d = e.renderer;\n        a.points.forEach(function (b) {\n          var c = b.graphic,\n              f = b.shapeArgs,\n              h = f.d,\n              k = p(g.dial, b.dial);\n          c ? (c.animate(f), f.d = h) : b.graphic = d[b.shapeType](f).attr({\n            rotation: f.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!e.styledMode) b.graphic[c ? \"animate\" : \"attr\"]({\n            stroke: k.borderColor,\n            \"stroke-width\": k.borderWidth,\n            fill: k.backgroundColor\n          });\n        });\n        c ? c.animate({\n          translateX: b[0],\n          translateY: b[1]\n        }) : f && (a.pivot = d.circle(0, 0, f.radius).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(b[0], b[1]).add(a.group), e.styledMode || a.pivot.attr({\n          fill: f.backgroundColor,\n          stroke: f.borderColor,\n          \"stroke-width\": f.borderWidth\n        }));\n      };\n\n      b.prototype.animate = function (a) {\n        var e = this;\n        a || e.points.forEach(function (a) {\n          var b = a.graphic;\n          b && (b.attr({\n            rotation: 180 * e.yAxis.startAngleRad / Math.PI\n          }), b.animate({\n            rotation: a.shapeArgs.rotation\n          }, e.options.animation));\n        });\n      };\n\n      b.prototype.render = function () {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"inherit\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        d.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      };\n\n      b.prototype.setData = function (a, e) {\n        d.prototype.setData.call(this, a, !1);\n        this.processData();\n        this.generatePoints();\n        l(e, !0) && this.chart.redraw();\n      };\n\n      b.prototype.hasData = function () {\n        return !!this.points.length;\n      };\n\n      b.defaultOptions = p(d.defaultOptions, {\n        dataLabels: {\n          borderColor: \"#cccccc\",\n          borderRadius: 3,\n          borderWidth: 1,\n          crop: !1,\n          defer: !1,\n          enabled: !0,\n          verticalAlign: \"top\",\n          y: 15,\n          zIndex: 2\n        },\n        dial: {\n          backgroundColor: \"#000000\",\n          baseLength: \"70%\",\n          baseWidth: 3,\n          borderColor: \"#cccccc\",\n          borderWidth: 0,\n          radius: \"80%\",\n          rearLength: \"10%\",\n          topWidth: 1\n        },\n        pivot: {\n          radius: 5,\n          borderWidth: 0,\n          borderColor: \"#cccccc\",\n          backgroundColor: \"#000000\"\n        },\n        tooltip: {\n          headerFormat: \"\"\n        },\n        showInLegend: !1\n      });\n      return b;\n    }(d);\n\n    F(a.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: c,\n      drawTracker: n.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: b,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    h.registerSeriesType(\"gauge\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/DragNodesComposition.js\", [d[\"Core/Utilities.js\"]], function (b) {\n    function c() {\n      var a = this,\n          b,\n          c,\n          h;\n      a.container && (b = d(a.container, \"mousedown\", function (b) {\n        var f = a.hoverPoint;\n        f && f.series && f.series.hasDraggableNodes && f.series.options.draggable && (f.series.onMouseDown(f, b), c = d(a.container, \"mousemove\", function (a) {\n          return f && f.series && f.series.onMouseMove(f, a);\n        }), h = d(a.container.ownerDocument, \"mouseup\", function (a) {\n          c();\n          h();\n          return f && f.series && f.series.onMouseUp(f, a);\n        }));\n      }));\n      d(a, \"destroy\", function () {\n        b();\n      });\n    }\n\n    var d = b.addEvent,\n        a = [];\n    return {\n      compose: function (b) {\n        -1 === a.indexOf(b) && (a.push(b), d(b, \"load\", c));\n      },\n      onMouseDown: function (a, b) {\n        b = this.chart.pointer.normalize(b);\n        a.fixedPosition = {\n          chartX: b.chartX,\n          chartY: b.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function (a, b) {\n        if (a.fixedPosition && a.inDragMode) {\n          var c = this.chart,\n              f = c.pointer.normalize(b);\n          b = a.fixedPosition.chartX - f.chartX;\n          f = a.fixedPosition.chartY - f.chartY;\n          var d = c.graphLayoutsLookup,\n              h = void 0,\n              w = void 0;\n          if (5 < Math.abs(b) || 5 < Math.abs(f)) h = a.fixedPosition.plotX - b, w = a.fixedPosition.plotY - f, c.isInsidePlot(h, w) && (a.plotX = h, a.plotY = w, a.hasDragged = !0, this.redrawHalo(a), d.forEach(function (a) {\n            a.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function (a, b) {\n        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function (a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n  });\n  D(d, \"Series/GraphLayoutComposition.js\", [d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    function d() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation();\n      }), this.redraw());\n    }\n\n    function a() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation(!1);\n      }), this.redraw());\n    }\n\n    function f() {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.stop();\n      });\n    }\n\n    function w() {\n      var a = !1,\n          b = function (e) {\n        e.maxIterations-- && isFinite(e.temperature) && !e.isStable() && !e.enableSimulation && (e.beforeStep && e.beforeStep(), e.step(), c = !1, a = !0);\n      };\n\n      if (this.graphLayoutsLookup) {\n        n(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (a) {\n          return a.start();\n        }); !c;) {\n          var c = !0;\n          this.graphLayoutsLookup.forEach(b);\n        }\n\n        a && this.series.forEach(function (a) {\n          a && a.layout && a.render();\n        });\n      }\n    }\n\n    var n = b.setAnimation,\n        r = c.addEvent,\n        q = [];\n    return {\n      compose: function (b) {\n        q.indexOf(b) && (q.push(b), r(b, \"afterPrint\", d), r(b, \"beforePrint\", a), r(b, \"predraw\", f), r(b, \"render\", w));\n      },\n      integrations: {},\n      layouts: {}\n    };\n  });\n  D(d, \"Series/PackedBubble/PackedBubblePoint.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"]], function (b, c, d) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    return function (f) {\n      function d() {\n        var a = null !== f && f.apply(this, arguments) || this;\n        a.degree = NaN;\n        a.mass = NaN;\n        a.radius = NaN;\n        a.options = void 0;\n        a.series = void 0;\n        a.value = null;\n        return a;\n      }\n\n      a(d, f);\n\n      d.prototype.destroy = function () {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return c.prototype.destroy.apply(this, arguments);\n      };\n\n      d.prototype.firePointEvent = function () {\n        var a = this.series.options;\n\n        if (this.isParentNode && a.parentNode) {\n          var b = a.allowPointSelect;\n          a.allowPointSelect = a.parentNode.allowPointSelect;\n          c.prototype.firePointEvent.apply(this, arguments);\n          a.allowPointSelect = b;\n        } else c.prototype.firePointEvent.apply(this, arguments);\n      };\n\n      d.prototype.select = function () {\n        var a = this.series.chart;\n        this.isParentNode ? (a.getSelectedPoints = a.getSelectedParentNodes, c.prototype.select.apply(this, arguments), a.getSelectedPoints = b.prototype.getSelectedPoints) : c.prototype.select.apply(this, arguments);\n      };\n\n      return d;\n    }(d.seriesTypes.bubble.prototype.pointClass);\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleSeriesDefaults.js\", [d[\"Core/Utilities.js\"]], function (b) {\n    var c = b.isNumber;\n    \"\";\n    return {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function () {\n          var b = this.series.chart.numberFormatter,\n              a = this.point.value;\n          return c(a) ? b(a, -1) : \"\";\n        },\n        parentNodeFormatter: function () {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: null,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1E3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/VerletIntegration.js\", [], function () {\n    return {\n      attractive: function (b, c, d) {\n        var a = b.getMass(),\n            f = -d.x * c * this.diffTemperature;\n        c = -d.y * c * this.diffTemperature;\n        b.fromNode.fixedPosition || (b.fromNode.plotX -= f * a.fromNode / b.fromNode.degree, b.fromNode.plotY -= c * a.fromNode / b.fromNode.degree);\n        b.toNode.fixedPosition || (b.toNode.plotX += f * a.toNode / b.toNode.degree, b.toNode.plotY += c * a.toNode / b.toNode.degree);\n      },\n      attractiveForceFunction: function (b, c) {\n        return (c - b) / b;\n      },\n      barycenter: function () {\n        var b = this.options.gravitationalConstant,\n            c = this.barycenter.xFactor,\n            d = this.barycenter.yFactor;\n        c = (c - (this.box.left + this.box.width) / 2) * b;\n        d = (d - (this.box.top + this.box.height) / 2) * b;\n        this.nodes.forEach(function (a) {\n          a.fixedPosition || (a.plotX -= c / a.mass / a.degree, a.plotY -= d / a.mass / a.degree);\n        });\n      },\n      getK: function (b) {\n        return Math.pow(b.box.width * b.box.height / b.nodes.length, .5);\n      },\n      integrate: function (b, c) {\n        var d = -b.options.friction,\n            a = b.options.maxSpeed,\n            f = (c.plotX + c.dispX - c.prevX) * d;\n        d *= c.plotY + c.dispY - c.prevY;\n        var w = Math.abs,\n            n = w(f) / (f || 1);\n        w = w(d) / (d || 1);\n        f = n * Math.min(a, Math.abs(f));\n        d = w * Math.min(a, Math.abs(d));\n        c.prevX = c.plotX + c.dispX;\n        c.prevY = c.plotY + c.dispY;\n        c.plotX += f;\n        c.plotY += d;\n        c.temperature = b.vectorLength({\n          x: f,\n          y: d\n        });\n      },\n      repulsive: function (b, c, d) {\n        c = c * this.diffTemperature / b.mass / b.degree;\n        b.fixedPosition || (b.plotX += d.x * c, b.plotY += d.y * c);\n      },\n      repulsiveForceFunction: function (b, c) {\n        return (c - b) / b * (c > b ? 1 : 0);\n      }\n    };\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleIntegration.js\", [d[\"Core/Globals.js\"], d[\"Series/Networkgraph/VerletIntegration.js\"]], function (b, c) {\n    return {\n      barycenter: function () {\n        for (var b = this.options.gravitationalConstant, a = this.box, c = this.nodes, d, n, r = 0; r < c.length; r++) {\n          var q = c[r];\n          this.options.splitSeries && !q.isParentNode ? (d = q.series.parentNode.plotX, n = q.series.parentNode.plotY) : (d = a.width / 2, n = a.height / 2);\n          q.fixedPosition || (q.plotX -= (q.plotX - d) * b / (q.mass * Math.sqrt(c.length)), q.plotY -= (q.plotY - n) * b / (q.mass * Math.sqrt(c.length)));\n        }\n      },\n      getK: b.noop,\n      integrate: c.integrate,\n      repulsive: function (b, a, c, d) {\n        var f = a * this.diffTemperature / b.mass / b.degree;\n        a = c.x * f;\n        c = c.y * f;\n        b.fixedPosition || (b.plotX += a, b.plotY += c);\n        d.fixedPosition || (d.plotX -= a, d.plotY -= c);\n      },\n      repulsiveForceFunction: function (b, a, c, d) {\n        return Math.min(b, (c.marker.radius + d.marker.radius) / 2);\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/EulerIntegration.js\", [], function () {\n    return {\n      attractive: function (b, c, d, a) {\n        var f = b.getMass(),\n            h = d.x / a * c;\n        c *= d.y / a;\n        b.fromNode.fixedPosition || (b.fromNode.dispX -= h * f.fromNode / b.fromNode.degree, b.fromNode.dispY -= c * f.fromNode / b.fromNode.degree);\n        b.toNode.fixedPosition || (b.toNode.dispX += h * f.toNode / b.toNode.degree, b.toNode.dispY += c * f.toNode / b.toNode.degree);\n      },\n      attractiveForceFunction: function (b, c) {\n        return b * b / c;\n      },\n      barycenter: function () {\n        var b = this.options.gravitationalConstant,\n            c = this.barycenter.xFactor,\n            d = this.barycenter.yFactor;\n        this.nodes.forEach(function (a) {\n          if (!a.fixedPosition) {\n            var f = a.getDegree();\n            f *= 1 + f / 2;\n            a.dispX += (c - a.plotX) * b * f / a.degree;\n            a.dispY += (d - a.plotY) * b * f / a.degree;\n          }\n        });\n      },\n      getK: function (b) {\n        return Math.pow(b.box.width * b.box.height / b.nodes.length, .3);\n      },\n      integrate: function (b, c) {\n        c.dispX += c.dispX * b.options.friction;\n        c.dispY += c.dispY * b.options.friction;\n        var d = c.temperature = b.vectorLength({\n          x: c.dispX,\n          y: c.dispY\n        });\n        0 !== d && (c.plotX += c.dispX / d * Math.min(Math.abs(c.dispX), b.temperature), c.plotY += c.dispY / d * Math.min(Math.abs(c.dispY), b.temperature));\n      },\n      repulsive: function (b, c, d, a) {\n        b.dispX += d.x / a * c / b.degree;\n        b.dispY += d.y / a * c / b.degree;\n      },\n      repulsiveForceFunction: function (b, c) {\n        return c * c / b;\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/QuadTreeNode.js\", [], function () {\n    return function () {\n      function b(b) {\n        this.isInternal = this.isEmpty = this.body = !1;\n        this.nodes = [];\n        this.box = b;\n        this.boxSize = Math.min(b.width, b.height);\n      }\n\n      b.prototype.divideBox = function () {\n        var c = this.box.width / 2,\n            d = this.box.height / 2;\n        this.nodes[0] = new b({\n          left: this.box.left,\n          top: this.box.top,\n          width: c,\n          height: d\n        });\n        this.nodes[1] = new b({\n          left: this.box.left + c,\n          top: this.box.top,\n          width: c,\n          height: d\n        });\n        this.nodes[2] = new b({\n          left: this.box.left + c,\n          top: this.box.top + d,\n          width: c,\n          height: d\n        });\n        this.nodes[3] = new b({\n          left: this.box.left,\n          top: this.box.top + d,\n          width: c,\n          height: d\n        });\n      };\n\n      b.prototype.getBoxPosition = function (b) {\n        var c = b.plotY < this.box.top + this.box.height / 2;\n        return b.plotX < this.box.left + this.box.width / 2 ? c ? 0 : 3 : c ? 1 : 2;\n      };\n\n      b.prototype.insert = function (c, d) {\n        this.isInternal ? this.nodes[this.getBoxPosition(c)].insert(c, d - 1) : (this.isEmpty = !1, this.body ? d ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, d - 1), this.body = !0), this.nodes[this.getBoxPosition(c)].insert(c, d - 1)) : (d = new b({\n          top: c.plotX || NaN,\n          left: c.plotY || NaN,\n          width: .1,\n          height: .1\n        }), d.body = c, d.isInternal = !1, this.nodes.push(d)) : (this.isInternal = !1, this.body = c));\n      };\n\n      b.prototype.updateMassAndCenter = function () {\n        var b = 0,\n            d = 0,\n            a = 0;\n\n        if (this.isInternal) {\n          for (var f = 0, w = this.nodes; f < w.length; f++) {\n            var n = w[f];\n            n.isEmpty || (b += n.mass, d += n.plotX * n.mass, a += n.plotY * n.mass);\n          }\n\n          d /= b;\n          a /= b;\n        } else this.body && (b = this.body.mass, d = this.body.plotX, a = this.body.plotY);\n\n        this.mass = b;\n        this.plotX = d;\n        this.plotY = a;\n      };\n\n      return b;\n    }();\n  });\n  D(d, \"Series/Networkgraph/QuadTree.js\", [d[\"Series/Networkgraph/QuadTreeNode.js\"]], function (b) {\n    return function () {\n      function c(c, a, d, w) {\n        this.box = {\n          left: c,\n          top: a,\n          width: d,\n          height: w\n        };\n        this.maxDepth = 25;\n        this.root = new b(this.box);\n        this.root.isInternal = !0;\n        this.root.isRoot = !0;\n        this.root.divideBox();\n      }\n\n      c.prototype.calculateMassAndCenter = function () {\n        this.visitNodeRecursive(null, null, function (b) {\n          b.updateMassAndCenter();\n        });\n      };\n\n      c.prototype.insertNodes = function (b) {\n        for (var a = 0; a < b.length; a++) this.root.insert(b[a], this.maxDepth);\n      };\n\n      c.prototype.visitNodeRecursive = function (b, a, c) {\n        var d;\n        b || (b = this.root);\n        b === this.root && a && (d = a(b));\n\n        if (!1 !== d) {\n          for (var f = 0, h = b.nodes; f < h.length; f++) {\n            var q = h[f];\n\n            if (q.isInternal) {\n              a && (d = a(q));\n              if (!1 === d) continue;\n              this.visitNodeRecursive(q, a, c);\n            } else q.body && a && a(q.body);\n\n            c && c(q);\n          }\n\n          b === this.root && c && c(b);\n        }\n      };\n\n      return c;\n    }();\n  });\n  D(d, \"Series/Networkgraph/ReingoldFruchtermanLayout.js\", [d[\"Series/Networkgraph/EulerIntegration.js\"], d[\"Core/Globals.js\"], d[\"Series/GraphLayoutComposition.js\"], d[\"Series/Networkgraph/QuadTree.js\"], d[\"Core/Utilities.js\"], d[\"Series/Networkgraph/VerletIntegration.js\"]], function (b, c, d, a, f, w) {\n    var h = c.win,\n        r = f.clamp,\n        q = f.defined,\n        F = f.isFunction,\n        p = f.pick;\n    return function () {\n      function c() {\n        this.attractiveForce = void 0;\n        this.box = {};\n        this.currentStep = 0;\n        this.initialRendering = !0;\n        this.integration = void 0;\n        this.links = [];\n        this.nodes = [];\n        this.repulsiveForce = this.quadTree = this.options = void 0;\n        this.series = [];\n        this.simulation = !1;\n      }\n\n      c.compose = function (a) {\n        d.compose(a);\n        d.integrations.euler = b;\n        d.integrations.verlet = w;\n        d.layouts[\"reingold-fruchterman\"] = c;\n      };\n\n      c.prototype.init = function (a) {\n        this.options = a;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = d.integrations[a.integration];\n        this.enableSimulation = a.enableSimulation;\n        this.attractiveForce = p(a.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = p(a.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = a.approximation;\n      };\n\n      c.prototype.updateSimulation = function (a) {\n        this.enableSimulation = p(a, this.options.enableSimulation);\n      };\n\n      c.prototype.start = function () {\n        var a = this.series,\n            b = this.options;\n        this.currentStep = 0;\n        this.forces = a[0] && a[0].forces || [];\n        this.chart = a[0] && a[0].chart;\n        this.initialRendering && (this.initPositions(), a.forEach(function (a) {\n          a.finishedAnimating = !0;\n          a.render();\n        }));\n        this.setK();\n        this.resetSimulation(b);\n        this.enableSimulation && this.step();\n      };\n\n      c.prototype.step = function () {\n        var a = this,\n            b = this.series;\n        this.currentStep++;\n        \"barnes-hut\" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter());\n\n        for (var c = 0, d = this.forces || []; c < d.length; c++) this[d[c] + \"Forces\"](this.temperature);\n\n        this.applyLimits();\n        this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n        this.prevSystemTemperature = this.systemTemperature;\n        this.systemTemperature = this.getSystemTemperature();\n\n        if (this.enableSimulation) {\n          for (c = 0; c < b.length; c++) d = b[c], d.chart && d.render();\n\n          this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && h.cancelAnimationFrame(this.simulation), this.simulation = h.requestAnimationFrame(function () {\n            return a.step();\n          })) : this.simulation = !1;\n        }\n      };\n\n      c.prototype.stop = function () {\n        this.simulation && h.cancelAnimationFrame(this.simulation);\n      };\n\n      c.prototype.setArea = function (a, b, c, d) {\n        this.box = {\n          left: a,\n          top: b,\n          width: c,\n          height: d\n        };\n      };\n\n      c.prototype.setK = function () {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      };\n\n      c.prototype.addElementsToCollection = function (a, b) {\n        for (var e = 0; e < a.length; e++) {\n          var c = a[e];\n          -1 === b.indexOf(c) && b.push(c);\n        }\n      };\n\n      c.prototype.removeElementFromCollection = function (a, b) {\n        a = b.indexOf(a);\n        -1 !== a && b.splice(a, 1);\n      };\n\n      c.prototype.clear = function () {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      };\n\n      c.prototype.resetSimulation = function () {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      };\n\n      c.prototype.restartSimulation = function () {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      };\n\n      c.prototype.setMaxIterations = function (a) {\n        this.maxIterations = p(a, this.options.maxIterations);\n      };\n\n      c.prototype.setTemperature = function () {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      };\n\n      c.prototype.setDiffTemperature = function () {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      };\n\n      c.prototype.setInitialRendering = function (a) {\n        this.initialRendering = a;\n      };\n\n      c.prototype.createQuadTree = function () {\n        this.quadTree = new a(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      };\n\n      c.prototype.initPositions = function () {\n        var a = this.options.initialPositions;\n\n        if (F(a)) {\n          a.call(this);\n          a = 0;\n\n          for (var b = this.nodes; a < b.length; a++) {\n            var c = b[a];\n            q(c.prevX) || (c.prevX = c.plotX);\n            q(c.prevY) || (c.prevY = c.plotY);\n            c.dispX = 0;\n            c.dispY = 0;\n          }\n        } else \"circle\" === a ? this.setCircularPositions() : this.setRandomPositions();\n      };\n\n      c.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), d = b.filter(function (a) {\n          return 0 === a.linksTo.length;\n        }), f = {}, h = this.options.initialPositionRadius, l = function (a) {\n          var b = 0;\n\n          for (a = a.linksFrom || []; b < a.length; b++) {\n            var c = a[b];\n            f[c.toNode.id] || (f[c.toNode.id] = !0, E.push(c.toNode), l(c.toNode));\n          }\n        }, E = [], v = 0; v < d.length; v++) {\n          var q = d[v];\n          E.push(q);\n          l(q);\n        }\n\n        if (E.length) for (d = 0; d < b.length; d++) v = b[d], -1 === E.indexOf(v) && E.push(v);else E = b;\n        d = 0;\n\n        for (v = E.length; d < v; ++d) b = E[d], b.plotX = b.prevX = p(b.plotX, a.width / 2 + h * Math.cos(d * c)), b.plotY = b.prevY = p(b.plotY, a.height / 2 + h * Math.sin(d * c)), b.dispX = 0, b.dispY = 0;\n      };\n\n      c.prototype.setRandomPositions = function () {\n        for (var a = this.box, b = this.nodes, c = b.length + 1, d = function (a) {\n          a = a * a / Math.PI;\n          return a -= Math.floor(a);\n        }, f, h = 0, l = b.length; h < l; ++h) f = b[h], f.plotX = f.prevX = p(f.plotX, a.width * d(h)), f.plotY = f.prevY = p(f.plotY, a.height * d(c + h)), f.dispX = 0, f.dispY = 0;\n      };\n\n      c.prototype.force = function (a) {\n        for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];\n\n        this.integration[a].apply(this, b);\n      };\n\n      c.prototype.barycenterForces = function () {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      };\n\n      c.prototype.getBarycenter = function () {\n        for (var a = 0, b = 0, c = 0, d = 0, f = this.nodes; d < f.length; d++) {\n          var h = f[d];\n          b += h.plotX * h.mass;\n          c += h.plotY * h.mass;\n          a += h.mass;\n        }\n\n        return this.barycenter = {\n          x: b,\n          y: c,\n          xFactor: b / a,\n          yFactor: c / a\n        };\n      };\n\n      c.prototype.barnesHutApproximation = function (a, b) {\n        var c = this.getDistXY(a, b),\n            e = this.vectorLength(c);\n        if (a !== b && 0 !== e) if (b.isInternal) {\n          if (b.boxSize / e < this.options.theta && 0 !== e) {\n            var d = this.repulsiveForce(e, this.k);\n            this.force(\"repulsive\", a, d * b.mass, c, e);\n            var g = !1;\n          } else g = !0;\n        } else d = this.repulsiveForce(e, this.k), this.force(\"repulsive\", a, d * b.mass, c, e);\n        return g;\n      };\n\n      c.prototype.repulsiveForces = function () {\n        var a = this;\n        if (\"barnes-hut\" === this.approximation) for (var b = function (b) {\n          c.quadTree.visitNodeRecursive(null, function (c) {\n            return a.barnesHutApproximation(b, c);\n          });\n        }, c = this, d = 0, f = this.nodes; d < f.length; d++) {\n          var h = f[d];\n          b(h);\n        } else {\n          f = d = b = void 0;\n\n          for (var l = 0, E = this.nodes; l < E.length; l++) {\n            h = E[l];\n\n            for (var v = 0, q = this.nodes; v < q.length; v++) {\n              var n = q[v];\n              h === n || h.fixedPosition || (f = this.getDistXY(h, n), d = this.vectorLength(f), 0 !== d && (b = this.repulsiveForce(d, this.k), this.force(\"repulsive\", h, b * n.mass, f, d)));\n            }\n          }\n        }\n      };\n\n      c.prototype.attractiveForces = function () {\n        for (var a, b, c, d = 0, f = this.links; d < f.length; d++) {\n          var h = f[d];\n          h.fromNode && h.toNode && (a = this.getDistXY(h.fromNode, h.toNode), b = this.vectorLength(a), 0 !== b && (c = this.attractiveForce(b, this.k), this.force(\"attractive\", h, c, a, b)));\n        }\n      };\n\n      c.prototype.applyLimits = function () {\n        for (var a = 0, b = this.nodes; a < b.length; a++) {\n          var c = b[a];\n          if (c.fixedPosition) break;\n          this.integration.integrate(this, c);\n          this.applyLimitBox(c, this.box);\n          c.dispX = 0;\n          c.dispY = 0;\n        }\n      };\n\n      c.prototype.applyLimitBox = function (a, b) {\n        var c = a.radius;\n        a.plotX = r(a.plotX, b.left + c, b.width - c);\n        a.plotY = r(a.plotY, b.top + c, b.height - c);\n      };\n\n      c.prototype.coolDown = function (a, b, c) {\n        return a - b * c;\n      };\n\n      c.prototype.isStable = function () {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      };\n\n      c.prototype.getSystemTemperature = function () {\n        for (var a = 0, b = 0, c = this.nodes; b < c.length; b++) a += c[b].temperature;\n\n        return a;\n      };\n\n      c.prototype.vectorLength = function (a) {\n        return Math.sqrt(a.x * a.x + a.y * a.y);\n      };\n\n      c.prototype.getDistR = function (a, b) {\n        a = this.getDistXY(a, b);\n        return this.vectorLength(a);\n      };\n\n      c.prototype.getDistXY = function (a, b) {\n        var c = a.plotX - b.plotX;\n        a = a.plotY - b.plotY;\n        return {\n          x: c,\n          y: a,\n          absX: Math.abs(c),\n          absY: Math.abs(a)\n        };\n      };\n\n      return c;\n    }();\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleLayout.js\", [d[\"Series/GraphLayoutComposition.js\"], d[\"Series/PackedBubble/PackedBubbleIntegration.js\"], d[\"Series/Networkgraph/ReingoldFruchtermanLayout.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    function f() {\n      var a = [];\n      this.series.forEach(function (b) {\n        b.parentNode && b.parentNode.selected && a.push(b.parentNode);\n      });\n      return a;\n    }\n\n    function h() {\n      this.allDataPoints && delete this.allDataPoints;\n    }\n\n    var n = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        r = a.addEvent,\n        q = a.pick,\n        F = [];\n\n    a = function (a) {\n      function l() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.index = NaN;\n        b.nodes = [];\n        b.options = void 0;\n        b.series = [];\n        return b;\n      }\n\n      n(l, a);\n\n      l.compose = function (a) {\n        d.compose(a);\n        b.integrations.packedbubble = c;\n        b.layouts.packedbubble = l;\n        -1 === F.indexOf(a) && (F.push(a), r(a, \"beforeRedraw\", h), a.prototype.getSelectedParentNodes = f);\n      };\n\n      l.prototype.beforeStep = function () {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      };\n\n      l.prototype.isStable = function () {\n        var a = Math.abs(this.prevSystemTemperature - this.systemTemperature);\n        return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && .00001 > a || 0 >= this.temperature;\n      };\n\n      l.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), d = this.options.initialPositionRadius, f, h, l = 0, E = 0; E < b.length; E++) {\n          var v = b[E];\n          this.options.splitSeries && !v.isParentNode ? (f = v.series.parentNode.plotX, h = v.series.parentNode.plotY) : (f = a.width / 2, h = a.height / 2);\n          v.plotX = v.prevX = q(v.plotX, f + d * Math.cos(v.index || l * c));\n          v.plotY = v.prevY = q(v.plotY, h + d * Math.sin(v.index || l * c));\n          v.dispX = 0;\n          v.dispY = 0;\n          l++;\n        }\n      };\n\n      l.prototype.repulsiveForces = function () {\n        var a = this,\n            b = a.options.bubblePadding,\n            c,\n            d,\n            f;\n        a.nodes.forEach(function (e) {\n          e.degree = e.mass;\n          e.neighbours = 0;\n          a.nodes.forEach(function (g) {\n            c = 0;\n            e === g || e.fixedPosition || !a.options.seriesInteraction && e.series !== g.series || (f = a.getDistXY(e, g), d = a.vectorLength(f) - (e.marker.radius + g.marker.radius + b), 0 > d && (e.degree += .01, e.neighbours++, c = a.repulsiveForce(-d / Math.sqrt(e.neighbours), a.k, e, g)), a.force(\"repulsive\", e, c * g.mass, f, g, d));\n          });\n        });\n      };\n\n      l.prototype.applyLimitBox = function (b, c) {\n        if (this.options.splitSeries && !b.isParentNode && this.options.parentNodeLimit) {\n          var e = this.getDistXY(b, b.series.parentNode);\n          var d = b.series.parentNodeRadius - b.marker.radius - this.vectorLength(e);\n          0 > d && d > -2 * b.marker.radius && (b.plotX -= .01 * e.x, b.plotY -= .01 * e.y);\n        }\n\n        a.prototype.applyLimitBox.call(this, b, c);\n      };\n\n      return l;\n    }(d);\n\n    return b.layouts.packedbubble = a;\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleSeries.js\", [d[\"Core/Color/Color.js\"], d[\"Series/DragNodesComposition.js\"], d[\"Series/GraphLayoutComposition.js\"], d[\"Core/Globals.js\"], d[\"Series/PackedBubble/PackedBubblePoint.js\"], d[\"Series/PackedBubble/PackedBubbleSeriesDefaults.js\"], d[\"Series/PackedBubble/PackedBubbleLayout.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a, f, w, n, r, q) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        p = b.parse;\n\n    b = a.noop;\n    var l = r.series.prototype,\n        e = r.seriesTypes.bubble,\n        g = q.addEvent,\n        k = q.clamp,\n        m = q.defined,\n        D = q.extend,\n        G = q.fireEvent,\n        L = q.isArray,\n        E = q.isNumber,\n        v = q.merge,\n        Q = q.pick;\n\n    q = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.layout = void 0;\n        b.options = void 0;\n        b.parentNodeMass = 0;\n        b.points = void 0;\n        b.xData = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.compose = function (a, b, d, f) {\n        e.compose(a, b, d, f);\n        c.compose(b);\n        n.compose(b);\n      };\n\n      b.prototype.accumulateAllPoints = function () {\n        for (var a = this.chart, b = [], c, e = 0, d = a.series; e < d.length; e++) {\n          var f = d[e];\n\n          if (f.is(\"packedbubble\") && f.visible || !a.options.chart.ignoreHiddenSeries) {\n            c = f.yData || [];\n\n            for (var g = 0; g < c.length; g++) b.push([null, null, c[g], f.index, g, {\n              id: g,\n              marker: {\n                radius: 0\n              }\n            }]);\n          }\n        }\n\n        return b;\n      };\n\n      b.prototype.addLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.options.chart,\n            e = this.chart.graphLayoutsStorage,\n            f = this.chart.graphLayoutsLookup;\n        e || (this.chart.graphLayoutsStorage = e = {}, this.chart.graphLayoutsLookup = f = []);\n        var g = e[b];\n        g || (a.enableSimulation = m(c.forExport) ? !c.forExport : a.enableSimulation, e[b] = g = new d.layouts[b](), g.init(a), f.splice(g.index, 0, g));\n        this.layout = g;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        g.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        g.addElementsToCollection([this], g.series);\n        g.addElementsToCollection(this.points, g.nodes);\n      };\n\n      b.prototype.addSeriesLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.graphLayoutsStorage,\n            e = this.chart.graphLayoutsLookup;\n        a = v(a, a.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var f = c[b + \"-series\"];\n        f || (c[b + \"-series\"] = f = new d.layouts[b](), f.init(a), e.splice(f.index, 0, f));\n        this.parentNodeLayout = f;\n        this.createParentNodes();\n      };\n\n      b.prototype.calculateParentRadius = function () {\n        var a = this.seriesBox();\n        this.parentNodeRadius = k(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      };\n\n      b.prototype.calculateZExtremes = function () {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            c = Infinity,\n            e = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            m(a) && (a > e && (e = a), a < c && (c = a));\n          });\n        });\n        a = Q(a, c);\n        b = Q(b, e);\n        return [a, b];\n      };\n\n      b.prototype.checkOverlap = function (a, b) {\n        var c = a[0] - b[0],\n            e = a[1] - b[1];\n        return -.001 > Math.sqrt(c * c + e * e) - Math.abs(a[2] + b[2]);\n      };\n\n      b.prototype.createParentNodes = function () {\n        var a = this,\n            b = this.pointClass,\n            c = this.chart,\n            e = this.parentNodeLayout,\n            d = this.layout.options,\n            f,\n            g = this.parentNode,\n            h = {\n          radius: this.parentNodeRadius,\n          lineColor: this.color,\n          fillColor: p(this.color).brighten(.4).get()\n        };\n        d.parentNodeOptions && (h = v(d.parentNodeOptions.marker || {}, h));\n        this.parentNodeMass = 0;\n        this.points.forEach(function (b) {\n          a.parentNodeMass += Math.PI * Math.pow(b.marker.radius, 2);\n        });\n        this.calculateParentRadius();\n        e.nodes.forEach(function (b) {\n          b.seriesIndex === a.index && (f = !0);\n        });\n        e.setArea(0, 0, c.plotWidth, c.plotHeight);\n        f || (g || (g = new b().init(this, {\n          mass: this.parentNodeRadius / 2,\n          marker: h,\n          dataLabels: {\n            inside: !1\n          },\n          states: {\n            normal: {\n              marker: h\n            },\n            hover: {\n              marker: h\n            }\n          },\n          dataLabelOnNull: !0,\n          degree: this.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: this.index\n        })), this.parentNode && (g.plotX = this.parentNode.plotX, g.plotY = this.parentNode.plotY), this.parentNode = g, e.addElementsToCollection([this], e.series), e.addElementsToCollection([g], e.nodes));\n      };\n\n      b.prototype.deferLayout = function () {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      };\n\n      b.prototype.destroy = function () {\n        var a = this;\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (b) {\n          b.removeElementFromCollection(a, b.series);\n        }, this);\n        this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        l.destroy.apply(this, arguments);\n      };\n\n      b.prototype.drawDataLabels = function () {\n        l.drawDataLabels.call(this, this.points);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", l.drawDataLabels.call(this, [this.parentNode]));\n      };\n\n      b.prototype.drawGraph = function () {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart,\n              b = this.layout.options.parentNodeOptions.marker;\n          b = {\n            fill: b.fillColor || p(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": Q(b.lineWidth, this.options.lineWidth)\n          };\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          var c = v({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, b);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(b.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(c);\n        }\n      };\n\n      b.prototype.drawTracker = function () {\n        var b = this.parentNode;\n        a.prototype.drawTracker.call(this);\n\n        if (b) {\n          var c = L(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          c.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        }\n      };\n\n      b.prototype.getPointRadius = function () {\n        var a = this,\n            b = this.chart,\n            c = this.options,\n            e = c.useSimulation,\n            d = Math.min(b.plotWidth, b.plotHeight),\n            f = {},\n            g = [],\n            h = b.allDataPoints || [],\n            m = h.length,\n            l,\n            v,\n            u,\n            C;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              e = /%$/.test(c[a]);\n          f[a] = e ? d * b / 100 : b * Math.sqrt(m);\n        });\n        b.minRadius = l = f.minSize / Math.sqrt(m);\n        b.maxRadius = v = f.maxSize / Math.sqrt(m);\n        var z = e ? this.calculateZExtremes() : [l, v];\n        h.forEach(function (b, c) {\n          u = e ? k(b[2], z[0], z[1]) : b[2];\n          C = a.getRadius(z[0], z[1], l, v, u);\n          0 === C && (C = null);\n          h[c][2] = C;\n          g.push(C);\n        });\n        this.radii = g;\n      };\n\n      b.prototype.init = function () {\n        l.init.apply(this, arguments);\n        this.eventsToUnbind.push(g(this, \"updatedData\", function () {\n          var a = this;\n          this.chart.series.forEach(function (b) {\n            b.type === a.type && (b.isDirty = !0);\n          }, this);\n        }));\n        return this;\n      };\n\n      b.prototype.onMouseUp = function (a) {\n        var b = a;\n\n        if (b.fixedPosition && !b.removed) {\n          var e = this.layout,\n              d = this.parentNodeLayout,\n              f,\n              g;\n          d && e.options.dragBetweenSeries && d.nodes.forEach(function (a) {\n            b && b.marker && a !== b.series.parentNode && (f = e.getDistXY(b, a), g = e.vectorLength(f) - a.marker.radius - b.marker.radius, 0 > g && (a.series.addPoint(v(b.options, {\n              plotX: b.plotX,\n              plotY: b.plotY\n            }), !1), e.removeElementFromCollection(b, e.nodes), b.remove()));\n          });\n          c.onMouseUp.apply(this, arguments);\n        }\n      };\n\n      b.prototype.placeBubbles = function (a) {\n        var b = this.checkOverlap,\n            c = this.positionBubble,\n            e = [],\n            d = 1,\n            f = 0,\n            g = 0;\n        var h = [];\n        var k;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          e.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (e.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), k = 2; k < a.length; k++) a[k][2] = a[k][2] || 1, h = c(e[d][f], e[d - 1][g], a[k]), b(h, e[d][0]) ? (e.push([]), g = 0, e[d + 1].push(c(e[d][f], e[d][0], a[k])), d++, f = 0) : 1 < d && e[d - 1][g + 1] && b(h, e[d - 1][g + 1]) ? (g++, e[d].push(c(e[d][f], e[d - 1][g], a[k])), f++) : (f++, e[d].push(h));\n          this.chart.stages = e;\n          this.chart.rawPositions = [].concat.apply([], e);\n          this.resizeRadius();\n          h = this.chart.rawPositions;\n        }\n\n        return h;\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options,\n            e = c.marker;\n        a && a.isParentNode && c.layoutAlgorithm && c.layoutAlgorithm.parentNodeOptions && (e = c.layoutAlgorithm.parentNodeOptions.marker);\n        c = e.fillOpacity;\n        a = l.pointAttribs.call(this, a, b);\n        1 !== c && (a[\"fill-opacity\"] = c);\n        return a;\n      };\n\n      b.prototype.positionBubble = function (a, b, c) {\n        var e = Math.sqrt,\n            d = Math.asin,\n            f = Math.acos,\n            g = Math.pow,\n            h = Math.abs;\n        e = e(g(a[0] - b[0], 2) + g(a[1] - b[1], 2));\n        f = f((g(e, 2) + g(c[2] + b[2], 2) - g(c[2] + a[2], 2)) / (2 * (c[2] + b[2]) * e));\n        d = d(h(a[0] - b[0]) / e);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + f + d * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + c[2]) * Math.sin(a), b[1] - (b[2] + c[2]) * Math.cos(a), c[2], c[3], c[4]];\n      };\n\n      b.prototype.render = function () {\n        var a = [];\n        l.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (b) {\n          L(b.dataLabels) && b.dataLabels.forEach(function (b) {\n            a.push(b);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      };\n\n      b.prototype.resizeRadius = function () {\n        var a = this.chart,\n            b = a.rawPositions,\n            c = Math.min,\n            e = Math.max,\n            d = a.plotLeft,\n            f = a.plotTop,\n            g = a.plotHeight,\n            h = a.plotWidth,\n            k,\n            m;\n        var l = k = Number.POSITIVE_INFINITY;\n        var u = m = Number.NEGATIVE_INFINITY;\n\n        for (var C = 0; C < b.length; C++) {\n          var z = b[C];\n          var v = z[2];\n          l = c(l, z[0] - v);\n          u = e(u, z[0] + v);\n          k = c(k, z[1] - v);\n          m = e(m, z[1] + v);\n        }\n\n        z = [u - l, m - k];\n        c = c.apply([], [(h - d) / z[0], (g - f) / z[1]]);\n\n        if (1e-10 < Math.abs(c - 1)) {\n          for (a = 0; a < b.length; a++) z = b[a], z[2] *= c;\n\n          this.placeBubbles(b);\n        } else a.diffY = g / 2 + f - k - (m - k) / 2, a.diffX = h / 2 + d - l - (u - l) / 2;\n      };\n\n      b.prototype.seriesBox = function () {\n        var a = this.chart,\n            b = Math.max,\n            c = Math.min,\n            e = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight],\n            d;\n        this.data.forEach(function (a) {\n          m(a.plotX) && m(a.plotY) && a.marker.radius && (d = a.marker.radius, e[0] = c(e[0], a.plotX - d), e[1] = b(e[1], a.plotX + d), e[2] = c(e[2], a.plotY - d), e[3] = b(e[3], a.plotY + d));\n        });\n        return E(e.width / e.height) ? e : null;\n      };\n\n      b.prototype.setVisible = function () {\n        var a = this;\n        l.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (b) {\n          a.layout.removeElementFromCollection(b, a.layout.nodes);\n        }));\n      };\n\n      b.prototype.translate = function () {\n        var a = this.chart,\n            b = this.data,\n            c = this.index,\n            e = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        m(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(), this.getPointRadius());\n        if (e) var d = a.allDataPoints;else d = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (var f = 0, g = d; f < g.length; f++) {\n          var h = g[f];\n\n          if (h[3] === c) {\n            d = b[h[4]];\n            var k = Q(h[2], void 0);\n            e || (d.plotX = h[0] - a.plotLeft + a.diffX, d.plotY = h[1] - a.plotTop + a.diffY);\n            E(k) && (d.marker = D(d.marker, {\n              radius: k,\n              width: 2 * k,\n              height: 2 * k\n            }), d.radius = k);\n          }\n        }\n\n        e && this.deferLayout();\n        G(this, \"afterTranslate\");\n      };\n\n      b.defaultOptions = v(e.defaultOptions, w);\n      return b;\n    }(e);\n\n    D(q.prototype, {\n      pointClass: f,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointArrayMap: [\"value\"],\n      pointValKey: \"value\",\n      requireSorting: !1,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      alignDataLabel: l.alignDataLabel,\n      indexateNodes: b,\n      onMouseDown: c.onMouseDown,\n      onMouseMove: c.onMouseMove,\n      redrawHalo: c.redrawHalo,\n      searchPoint: b\n    });\n    r.registerSeriesType(\"packedbubble\", q);\n    \"\";\n    return q;\n  });\n  D(d, \"Series/Polygon/PolygonSeries.js\", [d[\"Core/Globals.js\"], d[\"Core/Legend/LegendSymbol.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }();\n\n    b = b.noop;\n    var h = d.series,\n        n = d.seriesTypes,\n        r = n.area,\n        q = n.line,\n        F = n.scatter;\n    n = a.extend;\n    var p = a.merge;\n\n    a = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      f(b, a);\n\n      b.prototype.getGraphPath = function () {\n        for (var a = q.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n\n        return this.areaPath = a;\n      };\n\n      b.prototype.drawGraph = function () {\n        this.options.fillColor = this.color;\n        r.prototype.drawGraph.call(this);\n      };\n\n      b.defaultOptions = p(F.defaultOptions, {\n        marker: {\n          enabled: !1,\n          states: {\n            hover: {\n              enabled: !1\n            }\n          }\n        },\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0,\n          pointFormat: \"\"\n        },\n        trackByArea: !0\n      });\n      return b;\n    }(F);\n\n    n(a.prototype, {\n      type: \"polygon\",\n      drawLegendSymbol: c.drawRectangle,\n      drawTracker: h.prototype.drawTracker,\n      setStackedPoints: b\n    });\n    d.registerSeriesType(\"polygon\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Core/Axis/WaterfallAxis.js\", [d[\"Core/Axis/Stacking/StackItem.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var d = c.addEvent,\n        a = c.objectEach,\n        f;\n\n    (function (c) {\n      function f() {\n        var a = this.waterfall.stacks;\n        a && (a.changed = !1, delete a.alreadyChanged);\n      }\n\n      function h() {\n        var a = this.options.stackLabels;\n        a && a.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function q() {\n        for (var a = this.axes, b = this.series, c = b.length; c--;) b[c].options.stacking && (a.forEach(function (a) {\n          a.isXAxis || (a.waterfall.stacks.changed = !0);\n        }), c = 0);\n      }\n\n      function w() {\n        this.waterfall || (this.waterfall = new p(this));\n      }\n\n      var p = function () {\n        function c(a) {\n          this.axis = a;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        c.prototype.renderStackTotals = function () {\n          var c = this.axis,\n              d = c.waterfall.stacks,\n              f = c.stacking && c.stacking.stackTotalGroup,\n              h = new b(c, c.options.stackLabels || {}, !1, 0, void 0);\n          this.dummyStackItem = h;\n          f && a(d, function (c) {\n            a(c, function (a, c) {\n              h.total = a.stackTotal;\n              h.x = +c;\n              a.label && (h.label = a.label);\n              b.prototype.render.call(h, f);\n              a.label = h.label;\n              delete h.label;\n            });\n          });\n          h.total = null;\n        };\n\n        return c;\n      }();\n\n      c.Composition = p;\n\n      c.compose = function (a, b) {\n        d(a, \"init\", w);\n        d(a, \"afterBuildStacks\", f);\n        d(a, \"afterRender\", h);\n        d(b, \"beforeRedraw\", q);\n      };\n    })(f || (f = {}));\n\n    return f;\n  });\n  D(d, \"Series/Waterfall/WaterfallPoint.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Utilities.js\"]], function (b, c, d) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }(),\n        f = d.isNumber;\n\n    return function (b) {\n      function d() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(d, b);\n\n      d.prototype.getClassName = function () {\n        var a = c.prototype.getClassName.call(this);\n        this.isSum ? a += \" highcharts-sum\" : this.isIntermediateSum && (a += \" highcharts-intermediate-sum\");\n        return a;\n      };\n\n      d.prototype.isValid = function () {\n        return f(this.y) || this.isSum || !!this.isIntermediateSum;\n      };\n\n      return d;\n    }(b.prototype.pointClass);\n  });\n  D(d, \"Series/Waterfall/WaterfallSeries.js\", [d[\"Core/Axis/Axis.js\"], d[\"Core/Chart/Chart.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"], d[\"Core/Axis/WaterfallAxis.js\"], d[\"Series/Waterfall/WaterfallPoint.js\"]], function (b, c, d, a, f, w) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        r = d.seriesTypes,\n        q = r.column,\n        F = r.line,\n        p = a.arrayMax,\n        l = a.arrayMin,\n        e = a.correctFloat;\n\n    r = a.extend;\n    var g = a.isNumber,\n        k = a.merge,\n        m = a.objectEach,\n        D = a.pick;\n\n    a = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.stackedYNeg = void 0;\n        b.stackedYPos = void 0;\n        b.stackKey = void 0;\n        b.xData = void 0;\n        b.yAxis = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.prototype.generatePoints = function () {\n        q.prototype.generatePoints.apply(this);\n\n        for (var a = 0, b = this.points.length; a < b; a++) {\n          var c = this.points[a],\n              d = this.processedYData[a];\n          g(d) && (c.isIntermediateSum || c.isSum) && (c.y = e(d));\n        }\n      };\n\n      b.prototype.translate = function () {\n        var a = this.options,\n            b = this.yAxis,\n            c = D(a.minPointLength, 5),\n            e = c / 2,\n            d = a.threshold || 0;\n        a = a.stacking;\n        var f = b.waterfall.stacks[this.stackKey],\n            h = d,\n            k = d;\n        q.prototype.translate.apply(this);\n\n        for (var m = this.points, t = 0; t < m.length; t++) {\n          var l = m[t];\n          var n = this.processedYData[t];\n          var p = l.shapeArgs;\n\n          if (p && g(n)) {\n            var A = [0, n];\n            var r = l.y;\n\n            if (a) {\n              if (f) {\n                A = f[t];\n\n                if (\"overlap\" === a) {\n                  var w = A.stackState[A.stateIndex--];\n                  w = 0 <= r ? w : w - r;\n                  Object.hasOwnProperty.call(A, \"absolutePos\") && delete A.absolutePos;\n                  Object.hasOwnProperty.call(A, \"absoluteNeg\") && delete A.absoluteNeg;\n                } else 0 <= r ? (w = A.threshold + A.posTotal, A.posTotal -= r) : (w = A.threshold + A.negTotal, A.negTotal -= r, w -= r), !A.posTotal && g(A.absolutePos) && Object.hasOwnProperty.call(A, \"absolutePos\") && (A.posTotal = A.absolutePos, delete A.absolutePos), !A.negTotal && g(A.absoluteNeg) && Object.hasOwnProperty.call(A, \"absoluteNeg\") && (A.negTotal = A.absoluteNeg, delete A.absoluteNeg);\n\n                l.isSum || (A.connectorThreshold = A.threshold + A.stackTotal);\n                b.reversed ? (n = 0 <= r ? w - r : w + r, r = w) : (n = w, r = w - r);\n                l.below = n <= d;\n                p.y = b.translate(n, !1, !0, !1, !0);\n                p.height = Math.abs(p.y - b.translate(r, !1, !0, !1, !0));\n                if (r = b.waterfall.dummyStackItem) r.x = t, r.label = f[t].label, r.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[t], this.stackedYPos[t], void 0, this.xAxis);\n              }\n            } else w = Math.max(k, k + r) + A[0], p.y = b.translate(w, !1, !0, !1, !0), l.isSum ? (p.y = b.translate(A[1], !1, !0, !1, !0), p.height = Math.min(b.translate(A[0], !1, !0, !1, !0), b.len) - p.y, l.below = A[1] <= d) : l.isIntermediateSum ? (0 <= r ? (n = A[1] + h, r = h) : (n = h, r = A[1] + h), b.reversed && (n ^= r, r ^= n, n ^= r), p.y = b.translate(n, !1, !0, !1, !0), p.height = Math.abs(p.y - Math.min(b.translate(r, !1, !0, !1, !0), b.len)), h += A[1], l.below = n <= d) : (p.height = 0 < n ? b.translate(k, !1, !0, !1, !0) - p.y : b.translate(k, !1, !0, !1, !0) - b.translate(k - n, !1, !0, !1, !0), k += n, l.below = k < d), 0 > p.height && (p.y += p.height, p.height *= -1);\n\n            l.plotY = p.y = Math.round(p.y || 0) - this.borderWidth % 2 / 2;\n            p.height = Math.max(Math.round(p.height || 0), .001);\n            l.yBottom = p.y + p.height;\n            p.height <= c && !l.isNull ? (p.height = c, p.y -= e, l.plotY = p.y, l.minPointLengthOffset = 0 > l.y ? -e : e) : (l.isNull && (p.width = 0), l.minPointLengthOffset = 0);\n            r = l.plotY + (l.negative ? p.height : 0);\n            l.below && (l.plotY += p.height);\n            l.tooltipPos && (this.chart.inverted ? l.tooltipPos[0] = b.len - r : l.tooltipPos[1] = r);\n            l.isInside = this.isPointInside(l);\n          }\n        }\n      };\n\n      b.prototype.processData = function (b) {\n        var c = this.options,\n            d = this.yData,\n            f = c.data,\n            g = d.length,\n            h = c.threshold || 0,\n            k,\n            l,\n            m,\n            t,\n            n;\n\n        for (n = l = k = m = t = 0; n < g; n++) {\n          var q = d[n];\n          var p = f && f[n] ? f[n] : {};\n          \"sum\" === q || p.isSum ? d[n] = e(l) : \"intermediateSum\" === q || p.isIntermediateSum ? (d[n] = e(k), k = 0) : (l += q, k += q);\n          m = Math.min(l, m);\n          t = Math.max(l, t);\n        }\n\n        a.prototype.processData.call(this, b);\n        c.stacking || (this.dataMin = m + h, this.dataMax = t);\n      };\n\n      b.prototype.toYData = function (a) {\n        return a.isSum ? \"sum\" : a.isIntermediateSum ? \"intermediateSum\" : a.y;\n      };\n\n      b.prototype.updateParallelArrays = function (b, c) {\n        a.prototype.updateParallelArrays.call(this, b, c);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options.upColor;\n        c && !a.options.color && (a.color = 0 < a.y ? c : void 0);\n        a = q.prototype.pointAttribs.call(this, a, b);\n        delete a.dashstyle;\n        return a;\n      };\n\n      b.prototype.getGraphPath = function () {\n        return [[\"M\", 0, 0]];\n      };\n\n      b.prototype.getCrispPath = function () {\n        var a = this.data,\n            b = this.yAxis,\n            c = a.length,\n            e = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            d = Math.round(this.borderWidth) % 2 / 2,\n            f = this.xAxis.reversed,\n            g = this.yAxis.reversed,\n            h = this.options.stacking,\n            k = [],\n            l;\n\n        for (l = 1; l < c; l++) {\n          var m = a[l].shapeArgs;\n          var n = a[l - 1];\n          var q = a[l - 1].shapeArgs;\n          var p = b.waterfall.stacks[this.stackKey];\n          var r = 0 < n.y ? -q.height : 0;\n          p && q && m && (p = p[l - 1], h ? (p = p.connectorThreshold, r = Math.round(b.translate(p, !1, !0, !1, !0) + (g ? r : 0)) - e) : r = q.y + n.minPointLengthOffset + d - e, k.push([\"M\", (q.x || 0) + (f ? 0 : q.width || 0), r], [\"L\", (m.x || 0) + (f ? m.width || 0 : 0), r]));\n          q && k.length && (!h && 0 > n.y && !g || 0 < n.y && g) && ((n = k[k.length - 2]) && \"number\" === typeof n[2] && (n[2] += q.height || 0), (n = k[k.length - 1]) && \"number\" === typeof n[2] && (n[2] += q.height || 0));\n        }\n\n        return k;\n      };\n\n      b.prototype.drawGraph = function () {\n        F.prototype.drawGraph.call(this);\n        this.graph && this.graph.attr({\n          d: this.getCrispPath()\n        });\n      };\n\n      b.prototype.setStackedPoints = function () {\n        function a(a, b, c, e) {\n          if (u) {\n            if (R) for (c; c < R; c++) u.stackState[c] += e;else u.stackState[0] = a, R = u.stackState.length;\n            u.stackState.push(u.stackState[R - 1] + b);\n          }\n        }\n\n        var b = this.options,\n            c = this.yAxis.waterfall.stacks,\n            e = b.threshold || 0,\n            d = e,\n            f = d,\n            g = this.stackKey,\n            h = this.xData,\n            k = h.length,\n            l,\n            m,\n            n;\n        this.yAxis.stacking.usePercentage = !1;\n        var q = l = m = d;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var p = c.changed;\n          (n = c.alreadyChanged) && 0 > n.indexOf(g) && (p = !0);\n          c[g] || (c[g] = {});\n          if (n = c[g]) for (var r = 0; r < k; r++) {\n            var w = h[r];\n            if (!n[w] || p) n[w] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: p && n[w] ? n[w].label : void 0\n            };\n            var u = n[w];\n            var C = this.yData[r];\n            0 <= C ? u.posTotal += C : u.negTotal += C;\n            var z = b.data[r];\n            w = u.absolutePos = u.posTotal;\n            var O = u.absoluteNeg = u.negTotal;\n            u.stackTotal = w + O;\n            var R = u.stackState.length;\n            z && z.isIntermediateSum ? (a(m, l, 0, m), m = l, l = e, d ^= f, f ^= d, d ^= f) : z && z.isSum ? (a(e, q, R, 0), d = e) : (a(d, C, 0, q), z && (q += C, l += C));\n            u.stateIndex++;\n            u.threshold = d;\n            d += u.stackTotal;\n          }\n          c.changed = !1;\n          c.alreadyChanged || (c.alreadyChanged = []);\n          c.alreadyChanged.push(g);\n        }\n      };\n\n      b.prototype.getExtremes = function () {\n        var a = this.options.stacking;\n\n        if (a) {\n          var b = this.yAxis;\n          b = b.waterfall.stacks;\n          var c = this.stackedYNeg = [];\n          var e = this.stackedYPos = [];\n          \"overlap\" === a ? m(b[this.stackKey], function (a) {\n            c.push(l(a.stackState));\n            e.push(p(a.stackState));\n          }) : m(b[this.stackKey], function (a) {\n            c.push(a.negTotal + a.threshold);\n            e.push(a.posTotal + a.threshold);\n          });\n          return {\n            dataMin: l(c),\n            dataMax: p(e)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      };\n\n      b.defaultOptions = k(q.defaultOptions, {\n        dataLabels: {\n          inside: !0\n        },\n        lineWidth: 1,\n        lineColor: \"#333333\",\n        dashStyle: \"Dot\",\n        borderColor: \"#333333\",\n        states: {\n          hover: {\n            lineWidthPlus: 0\n          }\n        }\n      });\n      return b;\n    }(q);\n\n    r(a.prototype, {\n      getZonesGraphs: F.prototype.getZonesGraphs,\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: w\n    });\n    d.registerSeriesType(\"waterfall\", a);\n    f.compose(b, c);\n    \"\";\n    return a;\n  });\n  D(d, \"Core/Axis/RadialAxis.js\", [d[\"Core/Axis/AxisDefaults.js\"], d[\"Core/Defaults.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = c.defaultOptions,\n        h = d.noop,\n        n = a.addEvent,\n        r = a.correctFloat,\n        q = a.defined,\n        F = a.extend,\n        p = a.fireEvent,\n        l = a.merge,\n        e = a.pick,\n        g = a.relativeLength,\n        k = a.wrap,\n        m;\n\n    (function (a) {\n      function c() {\n        this.autoConnect = this.isCircular && \"undefined\" === typeof e(this.userMax, this.options.max) && r(this.endAngleRad - this.startAngleRad) === r(2 * Math.PI);\n        !this.isCircular && this.chart.inverted && this.max++;\n        this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n\n      function d() {\n        var a = this;\n        return function () {\n          if (a.isRadial && a.tickPositions && a.options.labels && !0 !== a.options.labels.allowOverlap) return a.tickPositions.map(function (b) {\n            return a.ticks[b] && a.ticks[b].label;\n          }).filter(function (a) {\n            return !!a;\n          });\n        };\n      }\n\n      function m() {\n        return h;\n      }\n\n      function v(a, b, c) {\n        var e = this.pane.center,\n            d = a.value;\n\n        if (this.isCircular) {\n          if (q(d)) a.point && (f = a.point.shapeArgs || {}, f.start && (d = this.chart.inverted ? this.translate(a.point.rectPlotY, !0) : a.point.x));else {\n            var f = a.chartX || 0;\n            var g = a.chartY || 0;\n            d = this.translate(Math.atan2(g - c, f - b) - this.startAngleRad, !0);\n          }\n          a = this.getPosition(d);\n          f = a.x;\n          g = a.y;\n        } else q(d) || (f = a.chartX, g = a.chartY), q(f) && q(g) && (c = e[1] + this.chart.plotTop, d = this.translate(Math.min(Math.sqrt(Math.pow(f - b, 2) + Math.pow(g - c, 2)), e[2] / 2) - e[3] / 2, !0));\n\n        return [d, f || 0, g || 0];\n      }\n\n      function w(a, b, c) {\n        a = this.pane.center;\n        var d = this.chart,\n            f = this.left || 0,\n            g = this.top || 0,\n            h = e(b, a[2] / 2 - this.offset);\n        \"undefined\" === typeof c && (c = this.horiz ? 0 : this.center && -this.center[3] / 2);\n        c && (h += c);\n        this.isCircular || \"undefined\" !== typeof b ? (b = this.chart.renderer.symbols.arc(f + a[0], g + a[1], h, h, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        }), b.xBounds = [f + a[0]], b.yBounds = [g + a[1] - h]) : (b = this.postTranslate(this.angleRad, h), b = [[\"M\", this.center[0] + d.plotLeft, this.center[1] + d.plotTop], [\"L\", b.x, b.y]]);\n        return b;\n      }\n\n      function D() {\n        this.constructor.prototype.getOffset.call(this);\n        this.chart.axisOffset[this.side] = 0;\n      }\n\n      function K(a, b, c) {\n        var d = this.chart,\n            f = function (a) {\n          if (\"string\" === typeof a) {\n            var b = parseInt(a, 10);\n            u.test(a) && (b = b * C / 100);\n            return b;\n          }\n\n          return a;\n        },\n            g = this.center,\n            h = this.startAngleRad,\n            C = g[2] / 2,\n            k = Math.min(this.offset, 0),\n            l = this.left || 0,\n            m = this.top || 0,\n            u = /%$/,\n            z = this.isCircular,\n            n = e(f(c.outerRadius), C),\n            P = f(c.innerRadius);\n\n        f = e(f(c.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) k = this.getPlotLinePath({\n          value: a\n        }).concat(this.getPlotLinePath({\n          value: b,\n          reverse: !0\n        }));else {\n          a = Math.max(a, this.min);\n          b = Math.min(b, this.max);\n          a = this.translate(a);\n          b = this.translate(b);\n          z || (n = a || 0, P = b || 0);\n          if (\"circle\" !== c.shape && z) c = h + (a || 0), h += b || 0;else {\n            c = -Math.PI / 2;\n            h = 1.5 * Math.PI;\n            var q = !0;\n          }\n          n -= k;\n          k = d.renderer.symbols.arc(l + g[0], m + g[1], n, n, {\n            start: Math.min(c, h),\n            end: Math.max(c, h),\n            innerR: e(P, n - (f - k)),\n            open: q\n          });\n          z && (z = (h + c) / 2, l = l + g[0] + g[2] / 2 * Math.cos(z), k.xBounds = z > -Math.PI / 2 && z < Math.PI / 2 ? [l, d.plotWidth] : [0, l], k.yBounds = [m + g[1] + g[2] / 2 * Math.sin(z)], k.yBounds[0] += z > -Math.PI && 0 > z || z > Math.PI ? -10 : 10);\n        }\n        return k;\n      }\n\n      function x(a) {\n        var b = this,\n            c = this.pane.center,\n            e = this.chart,\n            d = e.inverted,\n            f = a.reverse,\n            h = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n            C = h.innerRadius || \"0%\",\n            k = h.outerRadius || \"100%\",\n            l = c[0] + e.plotLeft,\n            m = c[1] + e.plotTop,\n            u = this.height,\n            z = a.isCrosshair;\n        h = c[3] / 2;\n        var n = a.value,\n            P;\n        var q = this.getPosition(n);\n        var p = q.x;\n        q = q.y;\n        z && (q = this.getCrosshairPosition(a, l, m), n = q[0], p = q[1], q = q[2]);\n        if (this.isCircular) n = Math.sqrt(Math.pow(p - l, 2) + Math.pow(q - m, 2)), f = \"string\" === typeof C ? g(C, 1) : C / n, e = \"string\" === typeof k ? g(k, 1) : k / n, c && h && (h /= n, f < h && (f = h), e < h && (e = h)), c = [[\"M\", l + f * (p - l), m - f * (m - q)], [\"L\", p - (1 - e) * (p - l), q + (1 - e) * (m - q)]];else if ((n = this.translate(n)) && (0 > n || n > u) && (n = 0), \"circle\" === this.options.gridLineInterpolation) c = this.getLinePath(0, n, h);else if (c = [], e[d ? \"yAxis\" : \"xAxis\"].forEach(function (a) {\n          a.pane === b.pane && (P = a);\n        }), P) for (l = P.tickPositions, P.autoConnect && (l = l.concat([l[0]])), f && (l = l.slice().reverse()), n && (n += h), m = 0; m < l.length; m++) h = P.getPosition(l[m], n), c.push(m ? [\"L\", h.x, h.y] : [\"M\", h.x, h.y]);\n        return c;\n      }\n\n      function B(a, b) {\n        a = this.translate(a);\n        return this.postTranslate(this.isCircular ? a : this.angleRad, e(this.isCircular ? b : 0 > a ? 0 : a, this.center[2] / 2) - this.offset);\n      }\n\n      function y() {\n        var a = this.center,\n            b = this.chart,\n            c = this.options.title;\n        return {\n          x: b.plotLeft + a[0] + (c.x || 0),\n          y: b.plotTop + a[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[c.align] * a[2] + (c.y || 0)\n        };\n      }\n\n      function H(a) {\n        a.beforeSetTickPositions = c;\n        a.createLabelCollector = d;\n        a.getCrosshairPosition = v;\n        a.getLinePath = w;\n        a.getOffset = D;\n        a.getPlotBandPath = K;\n        a.getPlotLinePath = x;\n        a.getPosition = B;\n        a.getTitlePosition = y;\n        a.postTranslate = u;\n        a.setAxisSize = z;\n        a.setAxisTranslation = O;\n        a.setOptions = R;\n      }\n\n      function t() {\n        var a = this.chart,\n            b = this.options,\n            c = this.pane,\n            d = c && c.options;\n        a.angular && this.isXAxis || !c || !a.angular && !a.polar || (a = 2 * Math.PI, c = (e(d.startAngle, 0) - 90) * Math.PI / 180, d = (e(d.endAngle, e(d.startAngle, 0) + 360) - 90) * Math.PI / 180, this.angleRad = (b.angle || 0) * Math.PI / 180, this.startAngleRad = c, this.endAngleRad = d, this.offset = b.offset || 0, b = (c % a + a) % a, d = (d % a + a) % a, b > Math.PI && (b -= a), d > Math.PI && (d -= a), this.normalizedStartAngleRad = b, this.normalizedEndAngleRad = d);\n      }\n\n      function J(a) {\n        this.isRadial && (a.align = void 0, a.preventDefault());\n      }\n\n      function N() {\n        if (this.chart && this.chart.labelCollectors) {\n          var a = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          0 <= a && this.chart.labelCollectors.splice(a, 1);\n        }\n      }\n\n      function U(a) {\n        var c = this.chart,\n            e = c.inverted,\n            d = c.angular,\n            f = c.polar,\n            g = this.isXAxis,\n            k = this.coll,\n            n = d && g;\n        a = a.userOptions.pane || 0;\n        a = this.pane = c.pane && c.pane[a];\n        var u;\n        if (\"colorAxis\" === k) this.isRadial = !1;else {\n          if (d) {\n            if (n ? (this.isHidden = !0, this.createLabelCollector = m, this.getOffset = h, this.render = this.redraw = C, this.setTitle = this.setCategories = this.setScale = h) : H(this), u = !g) this.defaultPolarOptions = Y;\n          } else f && (H(this), this.defaultPolarOptions = (u = this.horiz) ? X : l(\"xAxis\" === k ? b.defaultXAxisOptions : b.defaultYAxisOptions, Z), e && \"yAxis\" === k && (this.defaultPolarOptions.stackLabels = b.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0));\n\n          d || f ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && c.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n          a && u && (a.axis = this);\n          this.isCircular = u;\n        }\n      }\n\n      function A() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n\n      function M(a) {\n        var b = this.label;\n\n        if (b) {\n          var c = this.axis,\n              d = b.getBBox(),\n              f = c.options.labels,\n              h = (c.translate(this.pos) + c.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n              C = Math.round(h),\n              k = q(f.y) ? 0 : .3 * -d.height,\n              l = f.y,\n              m = 20,\n              u = f.align,\n              n = \"end\",\n              z = 0 > C ? C + 360 : C,\n              p = z,\n              O = 0,\n              t = 0;\n\n          if (c.isRadial) {\n            var r = c.getPosition(this.pos, c.center[2] / 2 + g(e(f.distance, -25), c.center[2] / 2, -c.center[2] / 2));\n            \"auto\" === f.rotation ? b.attr({\n              rotation: h\n            }) : q(l) || (l = c.chart.renderer.fontMetrics(b.styles && b.styles.fontSize).b - d.height / 2);\n            q(u) || (c.isCircular ? (d.width > c.len * c.tickInterval / (c.max - c.min) && (m = 0), u = h > m && h < 180 - m ? \"left\" : h > 180 + m && h < 360 - m ? \"right\" : \"center\") : u = \"center\", b.attr({\n              align: u\n            }));\n\n            if (\"auto\" === u && 2 === c.tickPositions.length && c.isCircular) {\n              90 < z && 180 > z ? z = 180 - z : 270 < z && 360 >= z && (z = 540 - z);\n              180 < p && 360 >= p && (p = 360 - p);\n              if (c.pane.options.startAngle === C || c.pane.options.startAngle === C + 360 || c.pane.options.startAngle === C - 360) n = \"start\";\n              u = -90 <= C && 90 >= C || -360 <= C && -270 >= C || 270 <= C && 360 >= C ? \"start\" === n ? \"right\" : \"left\" : \"start\" === n ? \"left\" : \"right\";\n              70 < p && 110 > p && (u = \"center\");\n              15 > z || 180 <= z && 195 > z ? O = .3 * d.height : 15 <= z && 35 >= z ? O = \"start\" === n ? 0 : .75 * d.height : 195 <= z && 215 >= z ? O = \"start\" === n ? .75 * d.height : 0 : 35 < z && 90 >= z ? O = \"start\" === n ? .25 * -d.height : d.height : 215 < z && 270 >= z && (O = \"start\" === n ? d.height : .25 * -d.height);\n              15 > p ? t = \"start\" === n ? .15 * -d.height : .15 * d.height : 165 < p && 180 >= p && (t = \"start\" === n ? .15 * d.height : .15 * -d.height);\n              b.attr({\n                align: u\n              });\n              b.translate(t, O + k);\n            }\n\n            a.pos.x = r.x + (f.x || 0);\n            a.pos.y = r.y + (l || 0);\n          }\n        }\n      }\n\n      function S(a) {\n        this.axis.getPosition && F(a.pos, this.axis.getPosition(this.pos));\n      }\n\n      function u(a, b) {\n        var c = this.chart,\n            e = this.center;\n        a = this.startAngleRad + a;\n        return {\n          x: c.plotLeft + e[0] + Math.cos(a) * b,\n          y: c.plotTop + e[1] + Math.sin(a) * b\n        };\n      }\n\n      function C() {\n        this.isDirty = !1;\n      }\n\n      function z() {\n        this.constructor.prototype.setAxisSize.call(this);\n\n        if (this.isRadial) {\n          this.pane.updateCenter(this);\n          var a = this.center = this.pane.center.slice();\n          if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n            var b = this.postTranslate(this.angleRad, a[3] / 2);\n            a[0] = b.x - this.chart.plotLeft;\n            a[1] = b.y - this.chart.plotTop;\n          }\n          this.len = this.width = this.height = (a[2] - a[3]) * e(this.sector, 1) / 2;\n        }\n      }\n\n      function O() {\n        this.constructor.prototype.setAxisTranslation.call(this);\n        this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n      }\n\n      function R(a) {\n        a = this.options = l(this.constructor.defaultOptions, this.defaultPolarOptions, f[this.coll], a);\n        a.plotBands || (a.plotBands = []);\n        p(this, \"afterSetOptions\");\n      }\n\n      function W(a, b, c, e, d, f, g) {\n        var h = this.axis;\n        h.isRadial ? (a = h.getPosition(this.pos, h.center[2] / 2 + e), b = [\"M\", b, c, \"L\", a.x, a.y]) : b = a.call(this, b, c, e, d, f, g);\n        return b;\n      }\n\n      var T = [],\n          X = {\n        gridLineWidth: 1,\n        labels: {\n          align: void 0,\n          distance: 15,\n          x: 0,\n          y: void 0,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      },\n          Y = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: void 0\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      },\n          Z = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n\n      a.compose = function (a, b) {\n        -1 === T.indexOf(a) && (T.push(a), n(a, \"afterInit\", t), n(a, \"autoLabelAlign\", J), n(a, \"destroy\", N), n(a, \"init\", U), n(a, \"initialAxisTranslation\", A));\n        -1 === T.indexOf(b) && (T.push(b), n(b, \"afterGetLabelPosition\", M), n(b, \"afterGetPosition\", S), k(b.prototype, \"getMarkPath\", W));\n        return a;\n      };\n    })(m || (m = {}));\n\n    return m;\n  });\n  D(d, \"Series/PolarComposition.js\", [d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Globals.js\"], d[\"Extensions/Pane.js\"], d[\"Core/Axis/RadialAxis.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a, f) {\n    function h(a, b, c, e) {\n      var d = e ? 1 : 0;\n      var f = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > f - 1 ? a.length - (1 + d) : f - 1;\n      var g = a[b];\n      d = a[f + 1 > a.length - 1 ? d : f + 1];\n      var C = g.plotY;\n      var k = d.plotX;\n      var l = d.plotY;\n      d = a[f].plotX;\n      f = a[f].plotY;\n      g = (1.5 * d + g.plotX) / 2.5;\n      C = (1.5 * f + C) / 2.5;\n      k = (1.5 * d + k) / 2.5;\n      var m = (1.5 * f + l) / 2.5;\n      l = Math.sqrt(Math.pow(g - d, 2) + Math.pow(C - f, 2));\n      var z = Math.sqrt(Math.pow(k - d, 2) + Math.pow(m - f, 2));\n      g = Math.atan2(C - f, g - d);\n      m = Math.PI / 2 + (g + Math.atan2(m - f, k - d)) / 2;\n      Math.abs(g - m) > Math.PI / 2 && (m -= Math.PI);\n      g = d + Math.cos(m) * l;\n      C = f + Math.sin(m) * l;\n      k = d + Math.cos(Math.PI + m) * z;\n      m = f + Math.sin(Math.PI + m) * z;\n      d = {\n        rightContX: k,\n        rightContY: m,\n        leftContX: g,\n        leftContY: C,\n        plotX: d,\n        plotY: f\n      };\n      c && (d.prevPointCont = h(a, b, !1, e));\n      return d;\n    }\n\n    function n() {\n      (this.pane || []).forEach(function (a) {\n        a.render();\n      });\n    }\n\n    function r(a) {\n      var b = a.args[0].xAxis,\n          c = a.args[0].yAxis;\n      a = a.args[0].chart;\n      b && c && (\"polygon\" === c.gridLineInterpolation ? (b.startOnTick = !0, b.endOnTick = !0) : \"polygon\" === b.gridLineInterpolation && a.inverted && (c.startOnTick = !0, c.endOnTick = !0));\n    }\n\n    function q() {\n      var a = this;\n      this.pane || (this.pane = []);\n      this.options.pane = V(this.options.pane);\n      this.options.pane.forEach(function (b) {\n        new d(b, a);\n      }, this);\n    }\n\n    function D(a) {\n      var b = a.args.marker,\n          c = this.chart.xAxis[0],\n          d = this.chart.yAxis[0],\n          e = this.chart.inverted,\n          f = e ? d : c;\n      c = e ? c : d;\n\n      if (this.chart.polar) {\n        a.preventDefault();\n        d = (b.attr ? b.attr(\"start\") : b.start) - f.startAngleRad;\n        e = b.attr ? b.attr(\"r\") : b.r;\n        var g = (b.attr ? b.attr(\"end\") : b.end) - f.startAngleRad;\n        b = b.attr ? b.attr(\"innerR\") : b.innerR;\n        a.result.x = d + f.pos;\n        a.result.width = g - d;\n        a.result.y = c.len + c.pos - b;\n        a.result.height = b - e;\n      }\n    }\n\n    function p(a) {\n      var b = this.chart;\n\n      if (b.polar && b.hoverPane && b.hoverPane.axis) {\n        a.preventDefault();\n        var c = b.hoverPane.center,\n            d = this.mouseDownX || 0,\n            e = this.mouseDownY || 0,\n            f = a.args.chartY,\n            g = a.args.chartX,\n            h = 2 * Math.PI,\n            l = b.hoverPane.axis.startAngleRad,\n            m = b.hoverPane.axis.endAngleRad,\n            n = b.inverted ? b.xAxis[0] : b.yAxis[0],\n            u = {},\n            q = \"arc\";\n        u.x = c[0] + b.plotLeft;\n        u.y = c[1] + b.plotTop;\n\n        if (this.zoomHor) {\n          var p = 0 < l ? m - l : Math.abs(l) + Math.abs(m),\n              t = Math.atan2(e - b.plotTop - c[1], d - b.plotLeft - c[0]) - l,\n              r = Math.atan2(f - b.plotTop - c[1], g - b.plotLeft - c[0]) - l;\n          u.r = c[2] / 2;\n          u.innerR = c[3] / 2;\n          0 >= t && (t += h);\n          0 >= r && (r += h);\n          r < t && (r = [t, t = r][0]);\n          p < h && l + r > m + (h - p) / 2 && (r = t, t = 0 >= l ? l : 0);\n          h = u.start = Math.max(t + l, l);\n          t = u.end = Math.min(r + l, m);\n          \"polygon\" === n.options.gridLineInterpolation && (r = b.hoverPane.axis, p = h - r.startAngleRad + r.pos, t -= h, q = n.getPlotLinePath({\n            value: n.max\n          }), h = r.toValue(p), p = r.toValue(p + t), h < r.getExtremes().min && (t = r.getExtremes(), h = t.max - (t.min - h)), p < r.getExtremes().min && (t = r.getExtremes(), p = t.max - (t.min - p)), p < h && (p = [h, h = p][0]), q = k(q, h, p, r), q.push([\"L\", c[0] + b.plotLeft, b.plotTop + c[1]]), u.d = q, q = \"path\");\n        }\n\n        this.zoomVert && (r = b.inverted ? b.xAxis[0] : b.yAxis[0], d = Math.sqrt(Math.pow(d - b.plotLeft - c[0], 2) + Math.pow(e - b.plotTop - c[1], 2)), f = Math.sqrt(Math.pow(g - b.plotLeft - c[0], 2) + Math.pow(f - b.plotTop - c[1], 2)), f < d && (d = [f, f = d][0]), f > c[2] / 2 && (f = c[2] / 2), d < c[3] / 2 && (d = c[3] / 2), this.zoomHor || (u.start = l, u.end = m), u.r = f, u.innerR = d, \"polygon\" === r.options.gridLineInterpolation && (t = r.toValue(r.len + r.pos - d), h = r.toValue(r.len + r.pos - f), q = r.getPlotLinePath({\n          value: h\n        }).concat(r.getPlotLinePath({\n          value: t,\n          reverse: !0\n        })), u.d = q, q = \"path\"));\n        this.zoomHor && this.zoomVert && \"polygon\" === n.options.gridLineInterpolation && (r = b.hoverPane.axis, h = u.start || 0, t = u.end || 0, p = h - r.startAngleRad + r.pos, t -= h, h = r.toValue(p), p = r.toValue(p + t), u.d instanceof Array && (c = u.d.slice(0, u.d.length / 2), l = u.d.slice(u.d.length / 2, u.d.length), l = K([], l, !0).reverse(), b = b.hoverPane.axis, c = k(c, h, p, b), (l = k(l, h, p, b)) && (l[0][0] = \"L\"), l = K([], l, !0).reverse(), u.d = c.concat(l), q = \"path\"));\n        a.attrs = u;\n        a.shapeType = q;\n      }\n    }\n\n    function l() {\n      var a = this.chart;\n      a.polar && (this.polar = new S(this), a.inverted && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0)));\n    }\n\n    function e() {\n      if (this.chart.polar && this.xAxis) {\n        var a = this.chart;\n        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = g : this.options.findNearestPointBy = \"xy\";\n\n        for (var b = this.points, d = b.length; d--;) this.preventPostTranslate || this.polar.toXY(b[d]), a.hasParallelCoordinates || this.yAxis.reversed || (J(b[d].y, Number.MIN_VALUE) < this.yAxis.min || b[d].x < this.xAxis.min || b[d].x > this.xAxis.max ? (b[d].isNull = !0, b[d].plotY = NaN) : b[d].isNull = b[d].isValid && !b[d].isValid());\n\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(B(this, \"afterRender\", function () {\n          if (a.polar) {\n            var b = this.yAxis.pane.center;\n            if (this.clipCircle) this.clipCircle.animate({\n              x: b[0],\n              y: b[1],\n              r: b[2] / 2,\n              innerR: b[3] / 2\n            });else {\n              var d = a.renderer,\n                  e = b[0],\n                  f = b[1],\n                  g = b[2] / 2,\n                  h = b[3] / 2;\n              b = U();\n              var k = d.createElement(\"clipPath\").attr({\n                id: b\n              }).add(d.defs);\n              d = h ? d.arc(e, f, g, h, 0, 2 * Math.PI).add(k) : d.circle(e, f, g).add(k);\n              d.id = b;\n              d.clipPath = k;\n              this.clipCircle = d;\n            }\n            this.group.clip(this.clipCircle);\n            this.setClip = c.noop;\n          }\n        })));\n      }\n    }\n\n    function g(a) {\n      var b = this.chart,\n          c = this.xAxis;\n      c = c.pane && c.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - (c && c[0] || 0) - b.plotLeft, a.chartY - (c && c[1] || 0) - b.plotTop)\n      });\n    }\n\n    function k(a, b, c, d) {\n      var e = d.tickInterval;\n      d = d.tickPositions;\n      var f = H(d, function (a) {\n        return a >= c;\n      }),\n          g = H(K([], d, !0).reverse(), function (a) {\n        return a <= b;\n      });\n      y(f) || (f = d[d.length - 1]);\n      y(g) || (g = d[0], f += e, a[0][0] = \"L\", a.unshift(a[a.length - 3]));\n      a = a.slice(d.indexOf(g), d.indexOf(f) + 1);\n      a[0][0] = \"M\";\n      return a;\n    }\n\n    function m(a, b) {\n      return H(this.pane || [], function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    }\n\n    function N(a, b, c, d, e, f) {\n      var g = this.chart,\n          h = J(d.inside, !!this.options.stacking);\n      g.polar ? (a = b.rectPlotX / Math.PI * 180, g.inverted ? (this.forceDL = g.isInsidePlot(b.plotX, b.plotY), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate(((e.start || 0) + (e.end || 0)) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {\n        x: e.x - g.plotLeft,\n        y: e.y - g.plotTop\n      }) : b.tooltipPos && (e = {\n        x: b.tooltipPos[0],\n        y: b.tooltipPos[1]\n      }), d.align = J(d.align, \"center\"), d.verticalAlign = J(d.verticalAlign, \"middle\")) : (null === d.align && (d.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\"), null === d.verticalAlign && (d.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\")), Object.getPrototypeOf(Object.getPrototypeOf(this)).alignDataLabel.call(this, b, c, d, e, f), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end ? c.hide() : c.show()) : a.call(this, b, c, d, e, f);\n    }\n\n    function G(a) {\n      var b = this.options,\n          c = b.stacking,\n          d = this.chart,\n          e = this.xAxis,\n          g = this.yAxis,\n          h = g.reversed,\n          k = g.center,\n          l = e.startAngleRad,\n          m = e.endAngleRad - l,\n          n = 0,\n          p = 0,\n          q = 0;\n      this.preventPostTranslate = !0;\n      a.call(this);\n\n      if (e.isRadial) {\n        a = this.points;\n        e = a.length;\n        var r = g.translate(g.min);\n        var u = g.translate(g.max);\n        b = b.threshold || 0;\n        d.inverted && t(b) && (n = g.translate(b), y(n) && (0 > n ? n = 0 : n > m && (n = m), this.translatedThreshold = n + l));\n\n        for (; e--;) {\n          b = a[e];\n          var v = b.barX;\n          var w = b.x;\n          var x = b.y;\n          b.shapeType = \"arc\";\n\n          if (d.inverted) {\n            b.plotY = g.translate(x);\n            c && g.stacking ? (x = g.stacking.stacks[(0 > x ? \"-\" : \"\") + this.stackKey], this.visible && x && x[w] && !b.isNull && (q = x[w].points[this.getStackIndicator(void 0, w, this.index).key], p = g.translate(q[0]), q = g.translate(q[1]), y(p) && (p = f.clamp(p, 0, m)))) : (p = n, q = b.plotY);\n            p > q && (q = [p, p = q][0]);\n            if (!h) {\n              if (p < r) p = r;else if (q > u) q = u;else {\n                if (q < r || p > u) p = q = 0;\n              }\n            } else if (q > r) q = r;else if (p < u) p = u;else if (p > r || q < u) p = q = m;\n            g.min > g.max && (p = q = h ? m : 0);\n            p += l;\n            q += l;\n            k && (b.barX = v += k[3] / 2);\n            w = Math.max(v, 0);\n            x = Math.max(v + b.pointWidth, 0);\n            b.shapeArgs = {\n              x: k && k[0],\n              y: k && k[1],\n              r: x,\n              innerR: w,\n              start: p,\n              end: q\n            };\n            b.opacity = p === q ? 0 : void 0;\n            b.plotY = (y(this.translatedThreshold) && (p < this.translatedThreshold ? p : q)) - l;\n          } else p = v + l, b.shapeArgs = this.polar.arc(b.yBottom, b.plotY, p, p + b.pointWidth);\n\n          this.polar.toXY(b);\n          d.inverted ? (v = g.postTranslate(b.rectPlotY, v + b.pointWidth / 2), b.tooltipPos = [v.x - d.plotLeft, v.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n          k && (b.ttBelow = b.plotY > k[1]);\n        }\n      }\n    }\n\n    function L(a, b) {\n      var c = this;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (var d = 0; d < b.length; d++) if (!b[d].isNull) {\n          var e = d;\n          break;\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var f = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.polar.toXY(a);\n        });\n      }\n\n      e = a.apply(this, [].slice.call(arguments, 1));\n      f && b.pop();\n      return e;\n    }\n\n    function E(a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        if (\"colorAxis\" !== a.coll) {\n          var e = a.isXAxis,\n              f = a.center,\n              g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    }\n\n    function v(a, b) {\n      this.chart.polar || a.call(this, b);\n    }\n\n    function Q(a, b) {\n      var d = this,\n          e = this.chart,\n          f = this.group,\n          g = this.markerGroup,\n          h = this.xAxis && this.xAxis.center,\n          k = e.plotLeft,\n          l = e.plotTop,\n          m = this.options.animation,\n          n,\n          p,\n          q,\n          r;\n      if (e.polar) {\n        if (d.isRadialBar) b || (d.startAngleRad = J(d.translatedThreshold, d.xAxis.startAngleRad), c.seriesTypes.pie.prototype.animate.call(d, b));else {\n          if (e.renderer.isSVG) if (m = x(m), d.is(\"column\")) {\n            if (!b) {\n              var t = h[3] / 2;\n              d.points.forEach(function (a) {\n                n = a.graphic;\n                q = (p = a.shapeArgs) && p.r;\n                r = p && p.innerR;\n                n && p && (n.attr({\n                  r: t,\n                  innerR: t\n                }), n.animate({\n                  r: q,\n                  innerR: r\n                }, d.options.animation));\n              });\n            }\n          } else b ? (a = {\n            translateX: h[0] + k,\n            translateY: h[1] + l,\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(a), g && g.attr(a)) : (a = {\n            translateX: k,\n            translateY: l,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(a, m), g && g.animate(a, m));\n        }\n      } else a.call(this, b);\n    }\n\n    function I(a, b, c, d) {\n      this.chart.polar ? d ? (a = h(b, d, !0, this.connectEnds), b = a.prevPointCont && a.prevPointCont.rightContX, c = a.prevPointCont && a.prevPointCont.rightContY, a = [\"C\", t(b) ? b : a.plotX, t(c) ? c : a.plotY, t(a.leftContX) ? a.leftContX : a.plotX, t(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, d);\n      return a;\n    }\n\n    var K = this && this.__spreadArray || function (a, b, c) {\n      if (c || 2 === arguments.length) for (var d = 0, e = b.length, f; d < e; d++) !f && d in b || (f || (f = Array.prototype.slice.call(b, 0, d)), f[d] = b[d]);\n      return a.concat(f || Array.prototype.slice.call(b));\n    },\n        x = b.animObject,\n        B = f.addEvent,\n        y = f.defined,\n        H = f.find,\n        t = f.isNumber,\n        J = f.pick,\n        V = f.splat,\n        U = f.uniqueKey,\n        A = f.wrap,\n        M = [],\n        S = function () {\n      function b(a) {\n        this.series = a;\n      }\n\n      b.compose = function (b, c, d, f, g, h, k, t, u) {\n        a.compose(b, g);\n        -1 === M.indexOf(c) && (M.push(c), B(c, \"afterDrawChartBox\", n), B(c, \"getAxes\", q), B(c, \"init\", r), A(c.prototype, \"get\", m));\n        -1 === M.indexOf(d) && (M.push(d), b = d.prototype, A(b, \"getCoordinates\", E), A(b, \"pinch\", v), B(d, \"getSelectionMarkerAttrs\", p), B(d, \"getSelectionBox\", D));\n        -1 === M.indexOf(f) && (M.push(f), B(f, \"afterInit\", l), B(f, \"afterTranslate\", e, {\n          order: 2\n        }), A(f.prototype, \"animate\", Q));\n        k && -1 === M.indexOf(k) && (M.push(k), d = k.prototype, A(d, \"alignDataLabel\", N), A(d, \"animate\", Q), A(d, \"translate\", G));\n        t && -1 === M.indexOf(t) && (M.push(t), A(t.prototype, \"getGraphPath\", L));\n        u && -1 === M.indexOf(u) && (M.push(u), t = u.prototype, A(t, \"getPointSpline\", I), h && -1 === M.indexOf(h) && (M.push(h), h.prototype.getPointSpline = t.getPointSpline));\n      };\n\n      b.prototype.arc = function (a, b, c, d) {\n        var e = this.series,\n            f = e.xAxis.center,\n            g = e.yAxis.len,\n            h = f[3] / 2;\n        b = g - b + h;\n        a = g - J(a, g) + h;\n        e.yAxis.reversed && (0 > b && (b = h), 0 > a && (a = h));\n        return {\n          x: f[0],\n          y: f[1],\n          r: b,\n          innerR: a,\n          start: c,\n          end: d\n        };\n      };\n\n      b.prototype.toXY = function (a) {\n        var b = this.series,\n            c = b.chart,\n            d = b.xAxis,\n            e = b.yAxis,\n            f = a.plotX,\n            g = c.inverted,\n            h = a.y,\n            k = a.plotY,\n            l = g ? f : e.len - k;\n        g && b && !b.isRadialBar && (a.plotY = k = t(h) ? e.translate(h) : 0);\n        a.rectPlotX = f;\n        a.rectPlotY = k;\n        e.center && (l += e.center[3] / 2);\n        t(k) && (e = g ? e.postTranslate(k, l) : d.postTranslate(f, l), a.plotX = a.polarPlotX = e.x - c.plotLeft, a.plotY = a.polarPlotY = e.y - c.plotTop);\n        b.kdByAngle ? (b = (f / Math.PI * 180 + d.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n      };\n\n      return b;\n    }();\n\n    return S;\n  });\n  D(d, \"masters/highcharts-more.src.js\", [d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Series/Bubble/BubbleSeries.js\"], d[\"Series/PackedBubble/PackedBubbleSeries.js\"], d[\"Series/PolarComposition.js\"]], function (b, c, d, a, f) {\n    d.compose(b.Axis, b.Chart, b.Legend, b.Series);\n    a.compose(b.Axis, b.Chart, b.Legend, b.Series);\n    f.compose(b.Axis, b.Chart, b.Pointer, b.Series, b.Tick, c.seriesTypes.areasplinerange, c.seriesTypes.column, c.seriesTypes.line, c.seriesTypes.spline);\n  });\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script"}