{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, NgZone, Inject, Directive, PLATFORM_ID, Input, Output, ElementRef, Self, Component, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { from, of, animationFrameScheduler, Subject, BehaviorSubject, defer, Observable } from 'rxjs';\nimport { map, publishReplay, refCount, observeOn, filter, switchMap, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\nimport { makeStateKey, TransferState } from '@angular/platform-browser';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/platform-browser';\nconst _c0 = [\"container\"];\nconst LOTTIE_OPTIONS = new InjectionToken('LottieOptions');\n\nfunction convertPlayerOrLoaderToObservable(player) {\n  const playerOrLoader = player();\n\n  if (playerOrLoader instanceof Promise) {\n    return from(playerOrLoader).pipe(map(module => module.default || module), publishReplay(1), refCount());\n  } else {\n    return of(playerOrLoader);\n  }\n}\n\nlet AnimationLoader = /*#__PURE__*/(() => {\n  class AnimationLoader {\n    constructor(ngZone, options) {\n      this.ngZone = ngZone;\n      this.options = options;\n      this.player$ = convertPlayerOrLoaderToObservable(this.options.player).pipe(observeOn(animationFrameScheduler));\n    }\n\n    loadAnimation(options) {\n      return this.player$.pipe(map(player => this.createAnimationItem(player, options)));\n    }\n\n    resolveOptions(options, container) {\n      return Object.assign({\n        container,\n        renderer: 'svg',\n        loop: true,\n        autoplay: true\n      }, options);\n    }\n\n    createAnimationItem(player, options) {\n      return this.ngZone.runOutsideAngular(() => player.loadAnimation(options));\n    }\n\n  }\n\n  AnimationLoader.ɵfac = function AnimationLoader_Factory(t) {\n    return new (t || AnimationLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(LOTTIE_OPTIONS));\n  };\n\n  AnimationLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AnimationLoader,\n    factory: AnimationLoader.ɵfac\n  });\n  /**\n   * @type {function(): !Array<(null|{\n   *   type: ?,\n   *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n   * })>}\n   * @nocollapse\n   */\n\n  return AnimationLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BaseDirective = /*#__PURE__*/(() => {\n  class BaseDirective {\n    constructor(ngZone, platformId, animationLoader) {\n      this.ngZone = ngZone;\n      this.platformId = platformId;\n      this.animationLoader = animationLoader;\n      this.options = null;\n      this.containerClass = null;\n      this.styles = null;\n      /**\n       * `animationCreated` is dispatched after calling `loadAnimation`.\n       */\n\n      this.animationCreated = this.getAnimationItem();\n      /**\n       * `complete` is dispatched after completing the last frame.\n       */\n\n      this.complete = this.awaitAnimationItemAndStartListening('complete');\n      /**\n       * `loopComplete` is dispatched after completing the frame loop.\n       */\n\n      this.loopComplete = this.awaitAnimationItemAndStartListening('loopComplete');\n      /**\n       * `enterFrame` is dispatched after entering the new frame.\n       */\n\n      this.enterFrame = this.awaitAnimationItemAndStartListening('enterFrame');\n      /**\n       * `segmentStart` is dispatched when the new segment is adjusted.\n       */\n\n      this.segmentStart = this.awaitAnimationItemAndStartListening('segmentStart');\n      /**\n       * Original event name is `config_ready`. `config_ready` is dispatched\n       * after the needed renderer is configured.\n       */\n\n      this.configReady = this.awaitAnimationItemAndStartListening('config_ready');\n      /**\n       * Original event name is `data_ready`. `data_ready` is dispatched\n       * when all parts of the animation have been loaded.\n       */\n\n      this.dataReady = this.awaitAnimationItemAndStartListening('data_ready');\n      /**\n       * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched\n       * when elements have been added to the DOM.\n       */\n\n      this.domLoaded = this.awaitAnimationItemAndStartListening('DOMLoaded');\n      /**\n       * `destroy` will be dispatched when the component gets destroyed,\n       * it's handy for releasing resources.\n       */\n\n      this.destroy = this.awaitAnimationItemAndStartListening('destroy');\n      /**\n       * `error` will be dispatched if the Lottie player could not render\n       * some frame or parse config.\n       */\n\n      this.error = this.awaitAnimationItemAndStartListening('error');\n      this.destroy$ = new Subject();\n      this.loadAnimation$ = new Subject();\n      this.animationItem$ = new BehaviorSubject(null);\n      this.setupLoadAnimationListener();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroyAnimation();\n    }\n\n    loadAnimation(changes, container) {\n      this.loadAnimation$.next([changes, container]);\n    }\n\n    getAnimationItem() {\n      return defer(() => this.animationItem$).pipe(filter(animationItem => animationItem !== null));\n    }\n\n    awaitAnimationItemAndStartListening(name) {\n      return this.getAnimationItem().pipe(switchMap(animationItem => // `fromEvent` will try to call `removeEventListener` when `unsubscribe()` is invoked.\n      // The problem is that `ngOnDestroy()` is called before Angular unsubscribes from\n      // `@Output()` properties, thus `animationItem` will be `null` already, also `lottie-web`\n      // removes event listeners when calling `destroy()`.\n      new Observable(observer => {\n        animationItem.addEventListener(name, event => {\n          this.ngZone.runOutsideAngular(() => {\n            observer.next(event);\n          });\n        });\n      })));\n    }\n\n    setupLoadAnimationListener() {\n      this.loadAnimation$.pipe(filter(([changes]) => isPlatformBrowser(this.platformId) && changes.options !== undefined), switchMap(([changes, container]) => {\n        this.destroyAnimation();\n        return this.animationLoader.loadAnimation(this.animationLoader.resolveOptions(changes.options.currentValue, container));\n      }), takeUntil(this.destroy$)).subscribe(animationItem => {\n        this.animationItem$.next(animationItem);\n      });\n    }\n\n    destroyAnimation() {\n      const animationItem = this.animationItem$.getValue(); // The `ng-lottie` component or the `lottie` directive can be destroyed\n      // before the `animationItem` is set, thus it will fail with\n      // `Cannot read property 'destroy' of null`.\n      // Potentially it can happen if the directive gets destroyed before change\n      // detection is run.\n\n      if (animationItem === null) {\n        return;\n      } // `destroy()` will remove all events listeners.\n\n\n      animationItem.destroy();\n      this.animationItem$.next(null);\n    }\n\n  }\n\n  BaseDirective.ɵfac = function BaseDirective_Factory(t) {\n    return new (t || BaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(AnimationLoader));\n  };\n\n  BaseDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseDirective,\n    selectors: [[\"\", \"lottie\", \"\"]],\n    inputs: {\n      options: \"options\",\n      containerClass: \"containerClass\",\n      styles: \"styles\"\n    },\n    outputs: {\n      animationCreated: \"animationCreated\",\n      complete: \"complete\",\n      loopComplete: \"loopComplete\",\n      enterFrame: \"enterFrame\",\n      segmentStart: \"segmentStart\",\n      configReady: \"configReady\",\n      dataReady: \"dataReady\",\n      domLoaded: \"domLoaded\",\n      destroy: \"destroy\",\n      error: \"error\"\n    }\n  });\n  /**\n   * @type {function(): !Array<(null|{\n   *   type: ?,\n   *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n   * })>}\n   * @nocollapse\n   */\n\n  return BaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieDirective = /*#__PURE__*/(() => {\n  class LottieDirective extends BaseDirective {\n    constructor(ngZone, platformId, host, animationLoader) {\n      super(ngZone, platformId, animationLoader);\n      this.host = host;\n    }\n\n    ngOnChanges(changes) {\n      super.loadAnimation(changes, this.host.nativeElement);\n    }\n\n  }\n\n  LottieDirective.ɵfac = function LottieDirective_Factory(t) {\n    return new (t || LottieDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef, 2), ɵngcc0.ɵɵdirectiveInject(AnimationLoader));\n  };\n\n  LottieDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: LottieDirective,\n    selectors: [[\"\", \"lottie\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /**\n   * @type {function(): !Array<(null|{\n   *   type: ?,\n   *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n   * })>}\n   * @nocollapse\n   */\n\n  return LottieDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieComponent = /*#__PURE__*/(() => {\n  class LottieComponent extends BaseDirective {\n    constructor(ngZone, platformId, animationLoader) {\n      super(ngZone, platformId, animationLoader);\n      this.width = null;\n      this.height = null;\n      this.container = null;\n    }\n\n    ngOnChanges(changes) {\n      super.loadAnimation(changes, this.container.nativeElement);\n    }\n\n  }\n\n  LottieComponent.ɵfac = function LottieComponent_Factory(t) {\n    return new (t || LottieComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(AnimationLoader));\n  };\n\n  LottieComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: LottieComponent,\n    selectors: [[\"ng-lottie\"]],\n    viewQuery: function LottieComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    inputs: {\n      width: \"width\",\n      height: \"height\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 6,\n    consts: [[3, \"ngStyle\", \"ngClass\"], [\"container\", \"\"]],\n    template: function LottieComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.width || \"100%\")(\"height\", ctx.height || \"100%\");\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.styles)(\"ngClass\", ctx.containerClass);\n      }\n    },\n    directives: [ɵngcc1.NgStyle, ɵngcc1.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /**\n   * @type {function(): !Array<(null|{\n   *   type: ?,\n   *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n   * })>}\n   * @nocollapse\n   */\n\n  return LottieComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieModule = /*#__PURE__*/(() => {\n  class LottieModule {\n    static forRoot(options) {\n      return {\n        ngModule: LottieModule,\n        providers: [AnimationLoader, {\n          provide: LOTTIE_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n\n  }\n\n  LottieModule.ɵfac = function LottieModule_Factory(t) {\n    return new (t || LottieModule)();\n  };\n\n  LottieModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: LottieModule\n  });\n  LottieModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return LottieModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LottieModule, {\n    declarations: function () {\n      return [BaseDirective, LottieDirective, LottieComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [BaseDirective, LottieDirective, LottieComponent];\n    }\n  });\n})();\n\nlet CacheableAnimationLoader = /*#__PURE__*/(() => {\n  class CacheableAnimationLoader extends AnimationLoader {\n    constructor() {\n      super(...arguments);\n      this.cache = new Map();\n    }\n\n    ngOnDestroy() {\n      this.cache.clear();\n    }\n\n    loadAnimation(options) {\n      return this.player$.pipe(map(player => {\n        const animationItem = this.createAnimationItem(player, this.transformOptions(options));\n        this.awaitConfigAndCache(options, animationItem);\n        return animationItem;\n      }));\n    }\n\n    awaitConfigAndCache(options, animationItem) {\n      if (this.isAnimationConfigWithPath(options)) {\n        // Don't wait for the `config_ready` event if it has been cached previously.\n        if (this.cache.has(options.path)) {\n          return;\n        }\n\n        animationItem.addEventListener('config_ready', () => {\n          // See the comments below on why we're storing the animation data as a string.\n          this.cache.set(options.path, JSON.stringify(animationItem['animationData']));\n        });\n      }\n    }\n\n    transformOptions(options) {\n      if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {\n        return Object.assign(Object.assign({}, options), {\n          path: undefined,\n          // Caretaker note: `lottie-web` cannot re-use the `animationData` object between animations, and we\n          // have to retrieve a new object each time an animation is created.\n          // https://github.com/airbnb/lottie-web#html\n          // See comments for the `animationData` property.\n          animationData: JSON.parse(this.cache.get(options.path))\n        });\n      } else {\n        return options;\n      }\n    }\n\n    isAnimationConfigWithPath(options) {\n      return typeof options.path === 'string';\n    }\n\n  }\n\n  CacheableAnimationLoader.ɵfac = /*@__PURE__*/function () {\n    let ɵCacheableAnimationLoader_BaseFactory;\n    return function CacheableAnimationLoader_Factory(t) {\n      return (ɵCacheableAnimationLoader_BaseFactory || (ɵCacheableAnimationLoader_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CacheableAnimationLoader)))(t || CacheableAnimationLoader);\n    };\n  }();\n\n  CacheableAnimationLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: CacheableAnimationLoader,\n    factory: CacheableAnimationLoader.ɵfac\n  });\n  return CacheableAnimationLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieCacheModule = /*#__PURE__*/(() => {\n  class LottieCacheModule {\n    static forRoot() {\n      return {\n        ngModule: LottieCacheModule,\n        providers: [{\n          provide: AnimationLoader,\n          useClass: CacheableAnimationLoader\n        }]\n      };\n    }\n\n  }\n\n  LottieCacheModule.ɵfac = function LottieCacheModule_Factory(t) {\n    return new (t || LottieCacheModule)();\n  };\n\n  LottieCacheModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: LottieCacheModule\n  });\n  LottieCacheModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return LottieCacheModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction transformAnimationFilenameToKey(animation) {\n  const [animationName] = animation.split('.json');\n  return `animation-${animationName}`;\n}\n\nlet LottieTransferState = /*#__PURE__*/(() => {\n  class LottieTransferState {\n    constructor(transferState) {\n      this.transferState = transferState;\n    }\n\n    get(animation) {\n      const animationKey = transformAnimationFilenameToKey(animation);\n      const stateKey = makeStateKey(animationKey);\n      return this.transferState.get(stateKey, null);\n    }\n\n  }\n\n  LottieTransferState.ɵfac = function LottieTransferState_Factory(t) {\n    return new (t || LottieTransferState)(ɵngcc0.ɵɵinject(ɵngcc2.TransferState));\n  };\n  /** @nocollapse */\n\n\n  LottieTransferState.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function LottieTransferState_Factory() {\n      return new LottieTransferState(i0.ɵɵinject(i1.TransferState));\n    },\n    token: LottieTransferState,\n    providedIn: \"root\"\n  });\n  /**\n   * @type {function(): !Array<(null|{\n   *   type: ?,\n   *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n   * })>}\n   * @nocollapse\n   */\n\n  return LottieTransferState;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The public api for consumers of ngx-lottie\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AnimationLoader, BaseDirective, LottieCacheModule, LottieComponent, LottieDirective, LottieModule, LottieTransferState, transformAnimationFilenameToKey, LOTTIE_OPTIONS as ɵb, CacheableAnimationLoader as ɵc }; //# sourceMappingURL=ngx-lottie.js.map","map":null,"metadata":{},"sourceType":"module"}