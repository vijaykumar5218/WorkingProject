{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { IonicAuth } from '@ionic-enterprise/auth';\nimport { Device, SupportedBiometricType } from '@ionic-enterprise/identity-vault';\nimport { DEFAULT_FACEID_DISABLED, VAULT_CONFIG_KEY } from './vault.service';\nimport { auth0NativeConfig, authTimeouts } from './contants/authConstants';\nimport { BehaviorSubject, Subscription } from 'rxjs';\nimport * as text from './contants/accountText.json';\nimport { REGISTERED_PARTY_IDS } from '@shared-lib/services/firebase/firebase.service';\nimport { endPoints } from './contants/endpoint';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./vault.service\";\nimport * as i3 from \"@ionic/angular\";\nimport * as i4 from \"@ionic-native/http/ngx\";\nimport * as i5 from \"../platform/platform.service\";\nexport let AuthenticationService = /*#__PURE__*/(() => {\n  class AuthenticationService extends IonicAuth {\n    constructor(router, vaultService, platform, ngZone, http, platformService, alertController) {\n      super(Object.assign(Object.assign({}, auth0NativeConfig), {\n        tokenStorageProvider: vaultService.vault\n      }));\n      this.router = router;\n      this.vaultService = vaultService;\n      this.platform = platform;\n      this.ngZone = ngZone;\n      this.http = http;\n      this.platformService = platformService;\n      this.alertController = alertController;\n      this.authText = text;\n      this.reloading = false;\n      this.endpoints = endPoints;\n      this.authenticationChange = new BehaviorSubject(false);\n      this.platformSubscription = new Subscription();\n      this.usePlatformListeners = false;\n      this.pausedTime = Number.MAX_VALUE;\n      this.authenticationChange$ = this.authenticationChange.asObservable();\n      this.registerPlatformListeners();\n      this.peristedLocalStorageItems = [VAULT_CONFIG_KEY, DEFAULT_FACEID_DISABLED, REGISTERED_PARTY_IDS];\n\n      if (this.platform.is('capacitor')) {\n        Device.setHideScreenOnBackground(true);\n      }\n    }\n\n    getBiometricsIconName() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const supported = yield Device.getAvailableHardware();\n\n        if (supported.includes(SupportedBiometricType.Fingerprint)) {\n          if (this.platform.is('ios')) {\n            return 'assets/icon/touch_ios.svg';\n          } else {\n            return 'assets/icon/touch_android.svg';\n          }\n        } else if (supported.includes(SupportedBiometricType.Face) || supported.includes(SupportedBiometricType.Iris)) {\n          if (this.platform.is('ios')) {\n            return 'assets/icon/faceid_ios.svg';\n          } else {\n            return 'assets/icon/faceid_android.svg';\n          }\n        }\n\n        return 'assets/icon/touch_android.svg';\n      });\n    }\n\n    getBiometricsLabel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const supported = yield Device.getAvailableHardware();\n\n        if (supported.includes(SupportedBiometricType.Fingerprint)) {\n          if (this.platform.is('ios')) {\n            return this.authText.touchIdIos;\n          } else {\n            return this.authText.touchIdAndroid;\n          }\n        } else if (supported.includes(SupportedBiometricType.Face) || supported.includes(SupportedBiometricType.Iris)) {\n          if (this.platform.is('ios')) {\n            return this.authText.faceIdIos;\n          } else {\n            return this.authText.faceIdAndroid;\n          }\n        }\n\n        return this.authText.biometrics;\n      });\n    }\n\n    registerPlatformListeners() {\n      this.platformService.setInitialResume(() => __awaiter(this, void 0, void 0, function* () {\n        if (!this.usePlatformListeners) {\n          return;\n        }\n\n        const currTime = new Date().getTime();\n\n        if (!this.vaultService.isFaceIDEnabled()) {\n          //Non Faceid Timeout\n          if (currTime - this.pausedTime > authTimeouts.nonFaceIDTimeout) {\n            yield this.logout(true);\n            return false;\n          }\n        } else {\n          //Faceid timeout to fix issues\n          if (currTime - this.pausedTime > authTimeouts.faceIDRefreshTimout) {\n            yield this.router.navigateByUrl('landing');\n            this.reloadWindow();\n            return false;\n          }\n\n          yield this.vaultService.unlockVault();\n          yield this.isAuthenticated();\n        }\n\n        return true;\n      }));\n      this.platformSubscription.add(this.platformService.onPause$.subscribe(() => {\n        //Use this because of bug when trying to re-register platform listeners\n        if (!this.usePlatformListeners) {\n          return;\n        }\n\n        this.pausedTime = new Date().getTime();\n      }));\n    }\n\n    attemptFaceIDLogin() {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          const hasFaceIDSession = yield this.hasFaceIDSession();\n\n          if (hasFaceIDSession) {\n            const isAuth = yield this.isAuthenticated();\n\n            if (isAuth) {\n              this.router.navigateByUrl('home');\n              this.usePlatformListeners = true;\n            }\n          }\n        } catch (ex) {\n          //If got biometric not available error, clear biometric session\n          if (ex.code == 13) {\n            this.clearStorage();\n            this.vaultService.disableFaceID();\n          }\n        }\n      });\n    }\n\n    openRegister() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.additionalLoginParameters({\n          register: 'allow'\n        });\n        yield this.login();\n      });\n    }\n\n    openLogin() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.additionalLoginParameters({});\n        yield this.login();\n      });\n    }\n\n    shouldShowBiometricsScreen() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const faceIDAvail = yield this.vaultService.isFaceIDAvailableOnDevice();\n\n        if (faceIDAvail) {\n          return !this.vaultService.defaultFaceIDDisabled();\n        }\n\n        return false;\n      });\n    }\n\n    showLoginFailureAlert() {\n      return __awaiter(this, void 0, void 0, function* () {\n        //Got issue logging in\n        const alert = yield this.alertController.create({\n          message: this.authText.loginError,\n          buttons: [this.authText.ok]\n        });\n        alert.present();\n      });\n    }\n\n    login() {\n      const _super = Object.create(null, {\n        login: {\n          get: () => super.login\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, function* () {\n        //Clear vault of any old sessions\n        try {\n          yield this.clearStorage(); //Change vault type to no face id and clear entire vault because we are loggin in with new account\n\n          yield this.vaultService.clearVault();\n          yield this.vaultService.disableFaceID();\n          yield _super.login.call(this);\n        } catch (ex) {\n          if (ex == 'Error: browser was closed') {\n            return;\n          } else if (ex.code == 5) {\n            //If there was an issue clearing a prev faceid session, retry login\n            this.vaultService.disableFaceID();\n            setTimeout(() => {\n              _super.login.call(this);\n            }, 50);\n          } else {\n            this.showLoginFailureAlert();\n          }\n        }\n      });\n    }\n\n    onAuthChange(isAuthenticated) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.ngZone.run(() => {\n          this.authenticationChange.next(isAuthenticated);\n        });\n      });\n    }\n\n    onLoginSuccess() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const isAuth = yield this.isAuthenticated();\n\n        if (!isAuth) {\n          this.showLoginFailureAlert();\n          this.clearStorage();\n          this.router.navigateByUrl('landing');\n        } else {\n          this.onAuthChange(true);\n          this.usePlatformListeners = true;\n        }\n      });\n    }\n\n    hasNonFaceIDSession() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!this.vaultService.isFaceIDEnabled()) {\n          return this.vaultService.hasStoredSession();\n        }\n\n        return false;\n      });\n    }\n\n    hasFaceIDSession() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.vaultService.isFaceIDEnabled()) {\n          return this.vaultService.hasStoredSession();\n        }\n\n        return false;\n      });\n    }\n\n    getDiscoveryURLS() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const result = yield this.http.get(auth0NativeConfig.discoveryUrl, {}, {});\n\n        if (result.data) {\n          return JSON.parse(result.data);\n        }\n\n        return null;\n      });\n    }\n\n    logoutAndRevoke() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const discovery = yield this.getDiscoveryURLS();\n\n        if (!discovery) {\n          this.clearStorage();\n          return false;\n        }\n\n        const token = yield this.getAccessToken();\n        const refToken = yield this.getRefreshToken();\n        const httpHeader = {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        };\n        this.http.setDataSerializer('utf8'); //Revoke access token\n\n        const acccessBody = 'client_id=' + auth0NativeConfig.clientID + '&token=' + token + '&token_type_hint=access_token';\n        const accessResp = yield this.http.post(discovery.revocation_endpoint, acccessBody, httpHeader); //Revoke refresh token\n\n        const refreshBody = 'client_id=' + auth0NativeConfig.clientID + '&token=' + refToken + '&token_type_hint=refresh_token';\n        const refreshResp = yield this.http.post(discovery.revocation_endpoint, refreshBody, httpHeader);\n        this.http.setDataSerializer('json');\n\n        if (accessResp.status == 200 && refreshResp.status == 200) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    logout(timeout = false) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.reloading = true;\n        this.onAuthChange(false);\n\n        if (timeout) {\n          yield this.router.navigateByUrl('logout');\n          this.clearUserSessionLocalStorage();\n          this.reloadWindow();\n          return;\n        }\n\n        this.usePlatformListeners = false;\n        yield this.router.navigateByUrl('secure-sign-out');\n\n        if (this.vaultService.isFaceIDEnabled()) {\n          yield this.vaultService.lockVault();\n        } else {\n          yield this.logoutAndRevoke();\n          yield this.clearStorage();\n        }\n\n        yield this.router.navigate(['landing'], {\n          queryParams: {\n            noAutoLogin: true\n          }\n        });\n        this.clearUserSessionLocalStorage();\n        this.reloadWindow();\n      });\n    }\n\n    clearUserSessionLocalStorage() {\n      const keepers = {};\n      this.peristedLocalStorageItems.forEach(keep => {\n        keepers[keep] = localStorage.getItem(keep);\n      });\n      localStorage.clear();\n\n      for (const key in keepers) {\n        localStorage.setItem(key, keepers[key]);\n      }\n    }\n\n    clearStorage() {\n      const _super = Object.create(null, {\n        clearStorage: {\n          get: () => super.clearStorage\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          this.http.get(this.endpoints.myvoyaLogout, {}, {});\n          this.http.clearCookies();\n        } catch (ex) {\n          console.log('Error clearing old myvoya session');\n        }\n\n        _super.clearStorage.call(this);\n      });\n    }\n\n    reloadWindow() {\n      window.location.reload();\n    }\n\n    ngOnDestroy() {\n      this.platformSubscription.unsubscribe();\n    }\n\n  }\n\n  AuthenticationService.ɵfac = function AuthenticationService_Factory(t) {\n    return new (t || AuthenticationService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.VaultService), i0.ɵɵinject(i3.Platform), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i4.HTTP), i0.ɵɵinject(i5.PlatformService), i0.ɵɵinject(i3.AlertController));\n  };\n\n  AuthenticationService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthenticationService,\n    factory: AuthenticationService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthenticationService;\n})();","map":null,"metadata":{},"sourceType":"module"}