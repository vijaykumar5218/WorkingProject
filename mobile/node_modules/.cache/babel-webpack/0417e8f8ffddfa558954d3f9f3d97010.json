{"ast":null,"code":"/*\n Highcharts JS v10.3.2 (2022-11-28)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (d) {\n  \"object\" === typeof module && module.exports ? (d[\"default\"] = d, module.exports = d) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (D) {\n    d(D);\n    d.Highcharts = D;\n    return d;\n  }) : d(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (d) {\n  function D(b, c, h, a) {\n    b.hasOwnProperty(c) || (b[c] = a.apply(null, h), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: c,\n        module: b[c]\n      }\n    })));\n  }\n\n  d = d ? d._modules : {};\n  D(d, \"Extensions/Pane.js\", [d[\"Core/Chart/Chart.js\"], d[\"Series/CenteredUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Pointer.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f) {\n    function y(g, l, e, a, H) {\n      var k = !0,\n          c = e[0],\n          v = e[1],\n          J = Math.sqrt(Math.pow(g - c, 2) + Math.pow(l - v, 2));\n      n(a) && n(H) && (g = Math.atan2(q(l - v, 8), q(g - c, 8)), H !== a && (k = a > H ? g >= a && g <= Math.PI || g <= H && g >= -Math.PI : g >= a && g <= q(H, 8)));\n      return J <= Math.ceil(e[2] / 2) && k;\n    }\n\n    var d = f.addEvent,\n        q = f.correctFloat,\n        n = f.defined,\n        E = f.extend,\n        t = f.merge,\n        p = f.pick,\n        e = f.splat;\n    b.prototype.collectionsWithUpdate.push(\"pane\");\n\n    f = function () {\n      function g(l, g) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(l, g);\n      }\n\n      g.prototype.init = function (l, g) {\n        this.chart = g;\n        this.background = [];\n        g.pane.push(this);\n        this.setOptions(l);\n      };\n\n      g.prototype.setOptions = function (l) {\n        this.options = t(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, l);\n      };\n\n      g.prototype.render = function () {\n        var l = this.options,\n            g = this.options.background,\n            a = this.chart.renderer;\n        this.group || (this.group = a.g(\"pane-group\").attr({\n          zIndex: l.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (g) for (g = e(g), l = Math.max(g.length, this.background.length || 0), a = 0; a < l; a++) g[a] && this.axis ? this.renderBackground(t(this.defaultBackgroundOptions, g[a]), a) : this.background[a] && (this.background[a] = this.background[a].destroy(), this.background.splice(a, 1));\n      };\n\n      g.prototype.renderBackground = function (g, e) {\n        var l = \"animate\",\n            k = {\n          \"class\": \"highcharts-pane \" + (g.className || \"\")\n        };\n        this.chart.styledMode || E(k, {\n          fill: g.backgroundColor,\n          stroke: g.borderColor,\n          \"stroke-width\": g.borderWidth\n        });\n        this.background[e] || (this.background[e] = this.chart.renderer.path().add(this.group), l = \"attr\");\n        this.background[e][l]({\n          d: this.axis.getPlotBandPath(g.from, g.to, g)\n        }).attr(k);\n      };\n\n      g.prototype.updateCenter = function (g) {\n        this.center = (g || this.axis || {}).center = c.getCenter.call(this);\n      };\n\n      g.prototype.update = function (g, e) {\n        t(!0, this.options, g);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (g) {\n          g.pane === this && (g.pane = null, g.update({}, e));\n        }, this);\n      };\n\n      return g;\n    }();\n\n    b.prototype.getHoverPane = function (g) {\n      var e = this,\n          k;\n      g && e.pane.forEach(function (l) {\n        y(g.chartX - e.plotLeft, g.chartY - e.plotTop, l.center) && (k = l);\n      });\n      return k;\n    };\n\n    d(b, \"afterIsInsidePlot\", function (g) {\n      if (this.polar) {\n        var e = g.x - (g.options.paneCoordinates ? this.plotLeft : 0),\n            k = g.y - (g.options.paneCoordinates ? this.plotTop : 0);\n\n        if (g.options.inverted) {\n          var a = [k, e];\n          e = a[0];\n          k = a[1];\n        }\n\n        g.isInsidePlot = this.pane.some(function (g) {\n          return y(e, k, g.center, g.axis && g.axis.normalizedStartAngleRad, g.axis && g.axis.normalizedEndAngleRad);\n        });\n      }\n    });\n    d(a, \"beforeGetHoverData\", function (g) {\n      var e = this.chart;\n      e.polar ? (e.hoverPane = e.getHoverPane(g), g.filter = function (l) {\n        return l.visible && !(!g.shared && l.directTouch) && p(l.options.enableMouseTracking, !0) && (!e.hoverPane || l.xAxis.pane === e.hoverPane);\n      }) : e.hoverPane = void 0;\n    });\n    d(a, \"afterGetHoverData\", function (g) {\n      var e = this.chart;\n      g.hoverPoint && g.hoverPoint.plotX && g.hoverPoint.plotY && e.hoverPane && !y(g.hoverPoint.plotX, g.hoverPoint.plotY, e.hoverPane.center) && (g.hoverPoint = void 0);\n    });\n    h.Pane = f;\n    return h.Pane;\n  });\n  D(d, \"Series/AreaRange/AreaRangePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var h = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function f() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n      };\n    }();\n\n    b = b.seriesTypes.area.prototype;\n    var a = b.pointClass.prototype,\n        f = c.defined,\n        d = c.isNumber;\n    return function (c) {\n      function b() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.high = void 0;\n        a.low = void 0;\n        a.options = void 0;\n        a.plotX = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      h(b, c);\n\n      b.prototype.setState = function () {\n        var c = this.state,\n            b = this.series,\n            h = b.chart.polar;\n        f(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0));\n        f(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0));\n        b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic);\n        this.graphic = this.graphics && this.graphics[1];\n        this.plotY = this.plotHigh;\n        h && d(this.plotHighX) && (this.plotX = this.plotHighX);\n        a.setState.apply(this, arguments);\n        this.state = c;\n        this.plotY = this.plotLow;\n        this.graphic = this.graphics && this.graphics[0];\n        h && d(this.plotLowX) && (this.plotX = this.plotLowX);\n        b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0);\n        a.setState.apply(this, arguments);\n      };\n\n      b.prototype.haloPath = function () {\n        var b = this.series.chart.polar,\n            c = [];\n        this.plotY = this.plotLow;\n        b && d(this.plotLowX) && (this.plotX = this.plotLowX);\n        this.isInside && (c = a.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        b && d(this.plotHighX) && (this.plotX = this.plotHighX);\n        this.isTopInside && (c = c.concat(a.haloPath.apply(this, arguments)));\n        return c;\n      };\n\n      b.prototype.isValid = function () {\n        return d(this.low) && d(this.high);\n      };\n\n      return b;\n    }(b.pointClass);\n  });\n  D(d, \"Series/AreaRange/AreaRangeSeries.js\", [d[\"Series/AreaRange/AreaRangePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var g = function (e, l) {\n        g = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (g, e) {\n          g.__proto__ = e;\n        } || function (g, e) {\n          for (var l in e) e.hasOwnProperty(l) && (g[l] = e[l]);\n        };\n\n        return g(e, l);\n      };\n\n      return function (e, l) {\n        function k() {\n          this.constructor = e;\n        }\n\n        g(e, l);\n        e.prototype = null === l ? Object.create(l) : (k.prototype = l.prototype, new k());\n      };\n    }();\n\n    c = c.noop;\n    var d = h.seriesTypes,\n        m = d.area,\n        q = d.area.prototype,\n        n = d.column.prototype;\n    d = a.addEvent;\n    var E = a.defined,\n        t = a.extend,\n        p = a.isArray,\n        e = a.isNumber,\n        g = a.pick,\n        l = a.merge,\n        k = {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    };\n\n    a = function (e) {\n      function a() {\n        var g = null !== e && e.apply(this, arguments) || this;\n        g.data = void 0;\n        g.options = void 0;\n        g.points = void 0;\n        g.lowerStateMarkerGraphic = void 0;\n        g.xAxis = void 0;\n        return g;\n      }\n\n      f(a, e);\n\n      a.prototype.toYData = function (g) {\n        return [g.low, g.high];\n      };\n\n      a.prototype.highToXY = function (g) {\n        var e = this.chart,\n            l = this.xAxis.postTranslate(g.rectPlotX || 0, this.yAxis.len - (g.plotHigh || 0));\n        g.plotHighX = l.x - e.plotLeft;\n        g.plotHigh = l.y - e.plotTop;\n        g.plotLowX = g.plotX;\n      };\n\n      a.prototype.getGraphPath = function (e) {\n        var l = [],\n            a = [],\n            k = q.getGraphPath,\n            b = this.options,\n            c = this.chart.polar,\n            w = c && !1 !== b.connectEnds,\n            B = b.connectNulls,\n            z,\n            f = b.step;\n        e = e || this.points;\n\n        for (z = e.length; z--;) {\n          var r = e[z];\n          var p = c ? {\n            plotX: r.rectPlotX,\n            plotY: r.yBottom,\n            doCurve: !1\n          } : {\n            plotX: r.plotX,\n            plotY: r.plotY,\n            doCurve: !1\n          };\n          r.isNull || w || B || e[z + 1] && !e[z + 1].isNull || a.push(p);\n          var h = {\n            polarPlotY: r.polarPlotY,\n            rectPlotX: r.rectPlotX,\n            yBottom: r.yBottom,\n            plotX: g(r.plotHighX, r.plotX),\n            plotY: r.plotHigh,\n            isNull: r.isNull\n          };\n          a.push(h);\n          l.push(h);\n          r.isNull || w || B || e[z - 1] && !e[z - 1].isNull || a.push(p);\n        }\n\n        e = k.call(this, e);\n        f && (!0 === f && (f = \"left\"), b.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[f]);\n        l = k.call(this, l);\n        a = k.call(this, a);\n        b.step = f;\n        b = [].concat(e, l);\n        !this.chart.polar && a[0] && \"M\" === a[0][0] && (a[0] = [\"L\", a[0][1], a[0][2]]);\n        this.graphPath = b;\n        this.areaPath = e.concat(a);\n        b.isArea = !0;\n        b.xMap = e.xMap;\n        this.areaPath.xMap = e.xMap;\n        return b;\n      };\n\n      a.prototype.drawDataLabels = function () {\n        var g = this.points,\n            e = g.length,\n            l = [],\n            a = this.options.dataLabels,\n            k = this.chart.inverted,\n            b,\n            w;\n\n        if (a) {\n          if (p(a)) {\n            var c = a[0] || {\n              enabled: !1\n            };\n            var z = a[1] || {\n              enabled: !1\n            };\n          } else c = t({}, a), c.x = a.xHigh, c.y = a.yHigh, z = t({}, a), z.x = a.xLow, z.y = a.yLow;\n\n          if (c.enabled || this._hasPointLabels) {\n            for (b = e; b--;) if (w = g[b]) {\n              var f = w.plotHigh;\n              f = void 0 === f ? 0 : f;\n              var r = w.plotLow;\n              r = void 0 === r ? 0 : r;\n              r = c.inside ? f < r : f > r;\n              w.y = w.high;\n              w._plotY = w.plotY;\n              w.plotY = f;\n              l[b] = w.dataLabel;\n              w.dataLabel = w.dataLabelUpper;\n              w.below = r;\n              k ? c.align || (c.align = r ? \"right\" : \"left\") : c.verticalAlign || (c.verticalAlign = r ? \"top\" : \"bottom\");\n            }\n\n            this.options.dataLabels = c;\n            q.drawDataLabels && q.drawDataLabels.apply(this, arguments);\n\n            for (b = e; b--;) if (w = g[b]) w.dataLabelUpper = w.dataLabel, w.dataLabel = l[b], delete w.dataLabels, w.y = w.low, w.plotY = w._plotY;\n          }\n\n          if (z.enabled || this._hasPointLabels) {\n            for (b = e; b--;) if (w = g[b]) l = w.plotHigh, f = void 0 === l ? 0 : l, l = w.plotLow, r = void 0 === l ? 0 : l, r = z.inside ? f < r : f > r, w.below = !r, k ? z.align || (z.align = r ? \"left\" : \"right\") : z.verticalAlign || (z.verticalAlign = r ? \"bottom\" : \"top\");\n\n            this.options.dataLabels = z;\n            q.drawDataLabels && q.drawDataLabels.apply(this, arguments);\n          }\n\n          if (c.enabled) for (b = e; b--;) if (w = g[b]) w.dataLabels = [w.dataLabelUpper, w.dataLabel].filter(function (g) {\n            return !!g;\n          });\n          this.options.dataLabels = a;\n        }\n      };\n\n      a.prototype.alignDataLabel = function () {\n        n.alignDataLabel.apply(this, arguments);\n      };\n\n      a.prototype.drawPoints = function () {\n        var e = this.points.length,\n            l;\n        q.drawPoints.apply(this, arguments);\n\n        for (l = 0; l < e;) {\n          var a = this.points[l];\n          a.graphics = a.graphics || [];\n          a.origProps = {\n            plotY: a.plotY,\n            plotX: a.plotX,\n            isInside: a.isInside,\n            negative: a.negative,\n            zone: a.zone,\n            y: a.y\n          };\n          a.graphic && (a.graphics[0] = a.graphic);\n          a.graphic = a.graphics[1];\n          a.plotY = a.plotHigh;\n          E(a.plotHighX) && (a.plotX = a.plotHighX);\n          a.y = g(a.high, a.origProps.y);\n          a.negative = a.y < (this.options.threshold || 0);\n          this.zones.length && (a.zone = a.getZone());\n          this.chart.polar || (a.isInside = a.isTopInside = \"undefined\" !== typeof a.plotY && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len);\n          l++;\n        }\n\n        q.drawPoints.apply(this, arguments);\n\n        for (l = 0; l < e;) a = this.points[l], a.graphics = a.graphics || [], a.graphic && (a.graphics[1] = a.graphic), a.graphic = a.graphics[0], a.origProps && (t(a, a.origProps), delete a.origProps), l++;\n      };\n\n      a.defaultOptions = l(m.defaultOptions, k);\n      return a;\n    }(m);\n\n    d(a, \"afterTranslate\", function () {\n      var g = this;\n      \"low,high\" === this.pointArrayMap.join(\",\") && this.points.forEach(function (a) {\n        var l = a.high,\n            k = a.plotY;\n        a.isNull ? a.plotY = void 0 : (a.plotLow = k, a.plotHigh = e(l) ? g.yAxis.translate(g.dataModify ? g.dataModify.modifyValue(l) : l, !1, !0, void 0, !0) : void 0, g.dataModify && (a.yBottom = a.plotHigh));\n      });\n    }, {\n      order: 0\n    });\n    d(a, \"afterTranslate\", function () {\n      var g = this;\n      this.chart.polar && this.points.forEach(function (e) {\n        g.highToXY(e);\n        e.plotLow = e.plotY;\n        e.tooltipPos = [((e.plotHighX || 0) + (e.plotLowX || 0)) / 2, ((e.plotHigh || 0) + (e.plotLow || 0)) / 2];\n      });\n    }, {\n      order: 3\n    });\n    t(a.prototype, {\n      deferTranslatePolar: !0,\n      pointArrayMap: [\"low\", \"high\"],\n      pointClass: b,\n      pointValKey: \"low\",\n      setStackedPoints: c\n    });\n    h.registerSeriesType(\"arearange\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [d[\"Series/AreaRange/AreaRangeSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var e in b) b.hasOwnProperty(e) && (a[e] = b[e]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        f = c.seriesTypes.spline.prototype,\n        d = h.merge;\n\n    h = h.extend;\n\n    var m = function (c) {\n      function f() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.data = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      a(f, c);\n      f.defaultOptions = d(b.defaultOptions);\n      return f;\n    }(b);\n\n    h(m.prototype, {\n      getPointSpline: f.getPointSpline\n    });\n    c.registerSeriesType(\"areasplinerange\", m);\n    \"\";\n    return m;\n  });\n  D(d, \"Series/BoxPlot/BoxPlotSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var g in e) e.hasOwnProperty(g) && (a[g] = e[g]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    c = c.noop;\n    var d = a.extend,\n        m = a.merge,\n        q = a.pick;\n\n    a = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      f(c, a);\n\n      c.prototype.pointAttribs = function () {\n        return {};\n      };\n\n      c.prototype.translate = function () {\n        var b = this.yAxis,\n            c = this.pointArrayMap;\n        a.prototype.translate.apply(this);\n        this.points.forEach(function (a) {\n          c.forEach(function (g) {\n            null !== a[g] && (a[g + \"Plot\"] = b.translate(a[g], 0, 1, 0, 1));\n          });\n          a.plotHigh = a.highPlot;\n        });\n      };\n\n      c.prototype.drawPoints = function () {\n        var a = this,\n            b = a.options,\n            e = a.chart,\n            g = e.renderer,\n            l,\n            c,\n            f,\n            h,\n            d,\n            F,\n            v = 0,\n            m,\n            I,\n            L,\n            w,\n            B = !1 !== a.doQuartiles,\n            z,\n            G = a.options.whiskerLength;\n        a.points.forEach(function (k) {\n          var r = k.graphic,\n              H = r ? \"animate\" : \"attr\",\n              J = k.shapeArgs,\n              M = {},\n              p = {},\n              y = {},\n              u = {},\n              C = k.color || a.color;\n          \"undefined\" !== typeof k.plotY && (m = Math.round(J.width), I = Math.floor(J.x), L = I + m, w = Math.round(m / 2), l = Math.floor(B ? k.q1Plot : k.lowPlot), c = Math.floor(B ? k.q3Plot : k.lowPlot), f = Math.floor(k.highPlot), h = Math.floor(k.lowPlot), r || (k.graphic = r = g.g(\"point\").add(a.group), k.stem = g.path().addClass(\"highcharts-boxplot-stem\").add(r), G && (k.whiskers = g.path().addClass(\"highcharts-boxplot-whisker\").add(r)), B && (k.box = g.path(void 0).addClass(\"highcharts-boxplot-box\").add(r)), k.medianShape = g.path(void 0).addClass(\"highcharts-boxplot-median\").add(r)), e.styledMode || (p.stroke = k.stemColor || b.stemColor || C, p[\"stroke-width\"] = q(k.stemWidth, b.stemWidth, b.lineWidth), p.dashstyle = k.stemDashStyle || b.stemDashStyle || b.dashStyle, k.stem.attr(p), G && (y.stroke = k.whiskerColor || b.whiskerColor || C, y[\"stroke-width\"] = q(k.whiskerWidth, b.whiskerWidth, b.lineWidth), y.dashstyle = k.whiskerDashStyle || b.whiskerDashStyle || b.dashStyle, k.whiskers.attr(y)), B && (M.fill = k.fillColor || b.fillColor || C, M.stroke = b.lineColor || C, M[\"stroke-width\"] = b.lineWidth || 0, M.dashstyle = k.boxDashStyle || b.boxDashStyle || b.dashStyle, k.box.attr(M)), u.stroke = k.medianColor || b.medianColor || C, u[\"stroke-width\"] = q(k.medianWidth, b.medianWidth, b.lineWidth), u.dashstyle = k.medianDashStyle || b.medianDashStyle || b.dashStyle, k.medianShape.attr(u)), F = k.stem.strokeWidth() % 2 / 2, v = I + w + F, r = [[\"M\", v, c], [\"L\", v, f], [\"M\", v, l], [\"L\", v, h]], k.stem[H]({\n            d: r\n          }), B && (F = k.box.strokeWidth() % 2 / 2, l = Math.floor(l) + F, c = Math.floor(c) + F, I += F, L += F, r = [[\"M\", I, c], [\"L\", I, l], [\"L\", L, l], [\"L\", L, c], [\"L\", I, c], [\"Z\"]], k.box[H]({\n            d: r\n          })), G && (F = k.whiskers.strokeWidth() % 2 / 2, f += F, h += F, z = /%$/.test(G) ? w * parseFloat(G) / 100 : G / 2, r = [[\"M\", v - z, f], [\"L\", v + z, f], [\"M\", v - z, h], [\"L\", v + z, h]], k.whiskers[H]({\n            d: r\n          })), d = Math.round(k.medianPlot), F = k.medianShape.strokeWidth() % 2 / 2, d += F, r = [[\"M\", I, d], [\"L\", L, d]], k.medianShape[H]({\n            d: r\n          }));\n        });\n      };\n\n      c.prototype.toYData = function (a) {\n        return [a.low, a.q1, a.median, a.q3, a.high];\n      };\n\n      c.defaultOptions = m(b.defaultOptions, {\n        threshold: null,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n        },\n        whiskerLength: \"50%\",\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        medianWidth: 2,\n        whiskerWidth: 2\n      });\n      return c;\n    }(b);\n\n    d(a.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: c,\n      setStackedPoints: c\n    });\n    h.registerSeriesType(\"boxplot\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"10px\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  });\n  D(d, \"Series/Bubble/BubbleLegendItem.js\", [d[\"Core/Color/Color.js\"], d[\"Core/FormatUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = b.parse,\n        d = h.noop,\n        m = a.arrayMax,\n        q = a.arrayMin,\n        n = a.isNumber,\n        E = a.merge,\n        t = a.pick,\n        p = a.stableSort;\n\n    b = function () {\n      function a(a, e) {\n        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = d;\n        this.init(a, e);\n      }\n\n      a.prototype.init = function (a, e) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = e.chart;\n        this.legend = e;\n      };\n\n      a.prototype.addToLegend = function (a) {\n        a.splice(this.options.legendIndex, 0, this);\n      };\n\n      a.prototype.drawLegendSymbol = function (a) {\n        var g = this.chart,\n            e = t(a.options.itemDistance, 20),\n            b = this.legendItem || {},\n            c = this.options,\n            f = c.ranges,\n            h = c.connectorDistance;\n        this.fontMetrics = g.renderer.fontMetrics(c.labels.style.fontSize);\n        f && f.length && n(f[0].value) ? (p(f, function (a, g) {\n          return g.value - a.value;\n        }), this.ranges = f, this.setOptions(), this.render(), a = this.getMaxLabelSize(), f = this.ranges[0].radius, g = 2 * f, h = h - f + a.width, h = 0 < h ? h : 0, this.maxLabel = a, this.movementX = \"left\" === c.labels.align ? h : 0, b.labelWidth = g + h + e, b.labelHeight = g + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;\n      };\n\n      a.prototype.setOptions = function () {\n        var a = this.ranges,\n            e = this.options,\n            b = this.chart.series[e.seriesIndex],\n            c = this.legend.baseline,\n            h = {\n          zIndex: e.zIndex,\n          \"stroke-width\": e.borderWidth\n        },\n            d = {\n          zIndex: e.zIndex,\n          \"stroke-width\": e.connectorWidth\n        },\n            p = {\n          align: this.legend.options.rtl || \"left\" === e.labels.align ? \"right\" : \"left\",\n          zIndex: e.zIndex\n        },\n            v = b.options.marker.fillOpacity,\n            m = this.chart.styledMode;\n        a.forEach(function (g, l) {\n          m || (h.stroke = t(g.borderColor, e.borderColor, b.color), h.fill = t(g.color, e.color, 1 !== v ? f(b.color).setOpacity(v).get(\"rgba\") : b.color), d.stroke = t(g.connectorColor, e.connectorColor, b.color));\n          a[l].radius = this.getRangeRadius(g.value);\n          a[l] = E(a[l], {\n            center: a[0].radius - a[l].radius + c\n          });\n          m || E(!0, a[l], {\n            bubbleAttribs: E(h),\n            connectorAttribs: E(d),\n            labelAttribs: p\n          });\n        }, this);\n      };\n\n      a.prototype.getRangeRadius = function (a) {\n        var e = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, e.ranges[e.ranges.length - 1].value, e.ranges[0].value, e.minSize, e.maxSize, a);\n      };\n\n      a.prototype.render = function () {\n        var a = this.legendItem || {},\n            e = this.chart.renderer,\n            b = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        a.symbol = e.g(\"bubble-legend\");\n        a.label = e.g(\"bubble-legend-item\");\n        a.symbol.translateX = 0;\n        e = a.symbol.translateY = 0;\n\n        for (var c = this.ranges; e < c.length; e++) {\n          var f = c[e];\n          f.value >= b && this.renderRange(f);\n        }\n\n        a.symbol.add(a.label);\n        a.label.add(a.group);\n        this.hideOverlappingLabels();\n      };\n\n      a.prototype.renderRange = function (a) {\n        var e = this.options,\n            g = e.labels,\n            b = this.chart,\n            c = b.series[e.seriesIndex],\n            f = b.renderer,\n            h = this.symbols;\n        b = h.labels;\n        var d = a.center,\n            p = Math.abs(a.radius),\n            I = e.connectorDistance || 0,\n            L = g.align,\n            w = e.connectorWidth,\n            B = this.ranges[0].radius || 0,\n            z = d - p - e.borderWidth / 2 + w / 2,\n            G = this.fontMetrics;\n        G = G.f / 2 - (G.h - G.f) / 2;\n        var r = f.styledMode;\n        I = this.legend.options.rtl || \"left\" === L ? -I : I;\n        \"center\" === L && (I = 0, e.connectorDistance = 0, a.labelAttribs.align = \"center\");\n        L = z + e.labels.y;\n        var m = B + I + e.labels.x;\n        h.bubbleItems.push(f.circle(B, d + ((z % 1 ? 1 : .5) - (w % 2 ? 0 : .5)), p).attr(r ? {} : a.bubbleAttribs).addClass((r ? \"highcharts-color-\" + c.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (e.className || \"\")).add(this.legendItem.symbol));\n        h.connectors.push(f.path(f.crispLine([[\"M\", B, z], [\"L\", B + I, z]], e.connectorWidth)).attr(r ? {} : a.connectorAttribs).addClass((r ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (e.connectorClassName || \"\")).add(this.legendItem.symbol));\n        a = f.text(this.formatLabel(a), m, L + G).attr(r ? {} : a.labelAttribs).css(r ? {} : g.style).addClass(\"highcharts-bubble-legend-labels \" + (e.labels.className || \"\")).add(this.legendItem.symbol);\n        b.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: m,\n          y: L + G\n        };\n      };\n\n      a.prototype.getMaxLabelSize = function () {\n        var a, e;\n        this.symbols.labels.forEach(function (g) {\n          e = g.getBBox(!0);\n          a = a ? e.width > a.width ? e : a : e;\n        });\n        return a || {};\n      };\n\n      a.prototype.formatLabel = function (a) {\n        var e = this.options,\n            g = e.labels.formatter;\n        e = e.labels.format;\n        var b = this.chart.numberFormatter;\n        return e ? c.format(e, a) : g ? g.call(a) : b(a.value, 1);\n      };\n\n      a.prototype.hideOverlappingLabels = function () {\n        var a = this.chart,\n            e = this.symbols;\n        !this.options.labels.allowOverlap && e && (a.hideOverlappingLabels(e.labels), e.labels.forEach(function (a, g) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && e.connectors[g].show() : e.connectors[g].hide();\n        }));\n      };\n\n      a.prototype.getRanges = function () {\n        var a = this.legend.bubbleLegend,\n            e = a.options.ranges,\n            b,\n            c = Number.MAX_VALUE,\n            f = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (b = a.zData.filter(n), b.length && (c = t(a.options.zMin, Math.min(c, Math.max(q(b), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), f = t(a.options.zMax, Math.max(f, m(b)))));\n        });\n        var h = c === f ? [{\n          value: f\n        }] : [{\n          value: c\n        }, {\n          value: (c + f) / 2\n        }, {\n          value: f,\n          autoRanges: !0\n        }];\n        e.length && e[0].radius && h.reverse();\n        h.forEach(function (a, g) {\n          e && e[g] && (h[g] = E(e[g], a));\n        });\n        return h;\n      };\n\n      a.prototype.predictBubbleSizes = function () {\n        var a = this.chart,\n            e = this.fontMetrics,\n            b = a.legend.options,\n            c = b.floating,\n            f = (b = \"horizontal\" === b.layout) ? a.legend.lastLineHeight : 0,\n            h = a.plotSizeX,\n            d = a.plotSizeY,\n            v = a.series[this.options.seriesIndex],\n            p = v.getPxExtremes();\n        a = Math.ceil(p.minPxSize);\n        p = Math.ceil(p.maxPxSize);\n        var I = Math.min(d, h);\n        v = v.options.maxSize;\n        if (c || !/%$/.test(v)) e = p;else if (v = parseFloat(v), e = (I + f - e.h / 2) * v / 100 / (v / 100 + 1), b && d - e >= h || !b && h - e >= d) e = p;\n        return [a, Math.ceil(e)];\n      };\n\n      a.prototype.updateRanges = function (a, e) {\n        var b = this.legend.options.bubbleLegend;\n        b.minSize = a;\n        b.maxSize = e;\n        b.ranges = this.getRanges();\n      };\n\n      a.prototype.correctSizes = function () {\n        var a = this.legend,\n            e = this.chart.series[this.options.seriesIndex].getPxExtremes();\n        1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), a.render());\n      };\n\n      return a;\n    }();\n\n    \"\";\n    return b;\n  });\n  D(d, \"Series/Bubble/BubbleLegendComposition.js\", [d[\"Series/Bubble/BubbleLegendDefaults.js\"], d[\"Series/Bubble/BubbleLegendItem.js\"], d[\"Core/Defaults.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    function f(a, b, g) {\n      var c = this.legend,\n          k = 0 <= d(this),\n          f;\n\n      if (c && c.options.enabled && c.bubbleLegend && c.options.bubbleLegend.autoRanges && k) {\n        var l = c.bubbleLegend.options;\n        k = c.bubbleLegend.predictBubbleSizes();\n        c.bubbleLegend.updateRanges(k[0], k[1]);\n        l.placed || (c.group.placed = !1, c.allItems.forEach(function (a) {\n          f = a.legendItem || {};\n          f.group && (f.group.translateY = null);\n        }));\n        c.render();\n        this.getMargins();\n        this.axes.forEach(function (a) {\n          a.visible && a.render();\n          l.placed || (a.setScale(), a.updateNames(), e(a.ticks, function (a) {\n            a.isNew = !0;\n            a.isNewLabel = !0;\n          }));\n        });\n        l.placed = !0;\n        this.getMargins();\n        a.call(this, b, g);\n        c.bubbleLegend.correctSizes();\n        E(c, m(c));\n      } else a.call(this, b, g), c && c.options.enabled && c.bubbleLegend && (c.render(), E(c, m(c)));\n    }\n\n    function d(a) {\n      a = a.series;\n\n      for (var e = 0; e < a.length;) {\n        if (a[e] && a[e].isBubble && a[e].visible && a[e].zData.length) return e;\n        e++;\n      }\n\n      return -1;\n    }\n\n    function m(a) {\n      a = a.allItems;\n      var e = [],\n          b = a.length,\n          g,\n          c = 0;\n\n      for (g = 0; g < b; g++) {\n        var f = a[g].legendItem || {};\n        var l = (a[g + 1] || {}).legendItem || {};\n        f.labelHeight && (a[g].itemHeight = f.labelHeight);\n\n        if (a[g] === a[b - 1] || f.y !== l.y) {\n          e.push({\n            height: 0\n          });\n          f = e[e.length - 1];\n\n          for (c; c <= g; c++) a[c].itemHeight > f.height && (f.height = a[c].itemHeight);\n\n          f.step = g;\n        }\n      }\n\n      return e;\n    }\n\n    function q(a) {\n      var e = this.bubbleLegend,\n          b = this.options,\n          g = b.bubbleLegend,\n          f = d(this.chart);\n      e && e.ranges && e.ranges.length && (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges), this.destroyItem(e));\n      0 <= f && b.enabled && g.enabled && (g.seriesIndex = f, this.bubbleLegend = new c(g, this), this.bubbleLegend.addToLegend(a.allItems));\n    }\n\n    function n() {\n      var a = this.chart,\n          e = this.visible,\n          b = this.chart.legend;\n      b && b.bubbleLegend && (this.visible = !e, this.ignoreSeries = e, a = 0 <= d(a), b.bubbleLegend.visible !== a && (b.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), b.bubbleLegend.visible = a), this.visible = e);\n    }\n\n    function E(a, e) {\n      var b = a.options.rtl,\n          g,\n          c,\n          f,\n          l,\n          k = 0;\n      a.allItems.forEach(function (a, w) {\n        l = a.legendItem || {};\n\n        if (l.group) {\n          g = l.group.translateX || 0;\n          c = l.y || 0;\n          if ((f = a.movementX) || b && a.ranges) f = b ? g - a.options.maxSize / 2 : g + f, l.group.attr({\n            translateX: f\n          });\n          w > e[k].step && k++;\n          l.group.attr({\n            translateY: Math.round(c + e[k].height / 2)\n          });\n          l.y = c + e[k].height / 2;\n        }\n      });\n    }\n\n    var t = h.setOptions,\n        p = a.addEvent,\n        e = a.objectEach,\n        g = a.wrap,\n        l = [];\n    return {\n      compose: function (a, e, c) {\n        -1 === l.indexOf(a) && (l.push(a), t({\n          legend: {\n            bubbleLegend: b\n          }\n        }), g(a.prototype, \"drawChartBox\", f));\n        -1 === l.indexOf(e) && (l.push(e), p(e, \"afterGetAllItems\", q));\n        -1 === l.indexOf(c) && (l.push(c), p(c, \"legendItemClick\", n));\n      }\n    };\n  });\n  D(d, \"Series/Bubble/BubblePoint.js\", [d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    h = h.extend;\n\n    c = function (c) {\n      function f() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(f, c);\n\n      f.prototype.haloPath = function (a) {\n        return b.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      };\n\n      return f;\n    }(c.seriesTypes.scatter.prototype.pointClass);\n\n    h(c.prototype, {\n      ttBelow: !1\n    });\n    return c;\n  });\n  D(d, \"Series/Bubble/BubbleSeries.js\", [d[\"Series/Bubble/BubbleLegendComposition.js\"], d[\"Series/Bubble/BubblePoint.js\"], d[\"Core/Color/Color.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f, d) {\n    function m() {\n      var a = this,\n          e = this.len,\n          b = this.chart,\n          c = this.isXAxis,\n          g = c ? \"xData\" : \"yData\",\n          f = this.min,\n          l = this.max - f,\n          k = 0,\n          h = e,\n          d = e / l,\n          p;\n      this.series.forEach(function (e) {\n        if (e.bubblePadding && (e.visible || !b.options.chart.ignoreHiddenSeries)) {\n          p = a.allowZoomOutside = !0;\n          var w = e[g];\n          c && ((e.onPoint || e).getRadii(0, 0, e), e.onPoint && (e.radii = e.onPoint.radii));\n          if (0 < l) for (var B = w.length; B--;) if (J(w[B]) && a.dataMin <= w[B] && w[B] <= a.max) {\n            var z = e.radii && e.radii[B] || 0;\n            k = Math.min((w[B] - f) * d - z, k);\n            h = Math.max((w[B] - f) * d + z, h);\n          }\n        }\n      });\n      p && 0 < l && !this.logarithmic && (h -= e, d *= (e + Math.max(0, k) - Math.min(h, e)) / e, [[\"min\", \"userMin\", k], [\"max\", \"userMax\", h]].forEach(function (e) {\n        \"undefined\" === typeof M(a.options[e[0]], a[e[1]]) && (a[e[0]] += e[2] / d);\n      }));\n    }\n\n    var y = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function c() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }(),\n        n = h.parse;\n\n    h = a.noop;\n    var E = f.series,\n        t = f.seriesTypes;\n    a = t.column.prototype;\n    var p = t.scatter;\n    t = d.addEvent;\n    var e = d.arrayMax,\n        g = d.arrayMin,\n        l = d.clamp,\n        k = d.extend,\n        J = d.isNumber,\n        H = d.merge,\n        M = d.pick,\n        F = [];\n\n    d = function (a) {\n      function c() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.maxPxSize = void 0;\n        e.minPxSize = void 0;\n        e.options = void 0;\n        e.points = void 0;\n        e.radii = void 0;\n        e.yData = void 0;\n        e.zData = void 0;\n        return e;\n      }\n\n      y(c, a);\n\n      c.compose = function (a, e, c, g) {\n        b.compose(e, c, g);\n        -1 === F.indexOf(a) && (F.push(a), a.prototype.beforePadding = m);\n      };\n\n      c.prototype.animate = function (a) {\n        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {\n          var e = a.graphic;\n          e && e.width && (this.hasRendered || e.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), e.animate(this.markerAttribs(a), this.options.animation));\n        }, this);\n      };\n\n      c.prototype.getRadii = function () {\n        var a = this,\n            e = this.zData,\n            b = this.yData,\n            c = [],\n            g = this.chart.bubbleZExtremes;\n        var f = this.getPxExtremes();\n        var l = f.minPxSize,\n            k = f.maxPxSize;\n\n        if (!g) {\n          var h = Number.MAX_VALUE,\n              d = -Number.MAX_VALUE,\n              p;\n          this.chart.series.forEach(function (e) {\n            e.bubblePadding && (e.visible || !a.chart.options.chart.ignoreHiddenSeries) && (e = (e.onPoint || e).getZExtremes()) && (h = Math.min(h || e.zMin, e.zMin), d = Math.max(d || e.zMax, e.zMax), p = !0);\n          });\n          p ? (g = {\n            zMin: h,\n            zMax: d\n          }, this.chart.bubbleZExtremes = g) : g = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n\n        var m = 0;\n\n        for (f = e.length; m < f; m++) {\n          var v = e[m];\n          c.push(this.getRadius(g.zMin, g.zMax, l, k, v, b && b[m]));\n        }\n\n        this.radii = c;\n      };\n\n      c.prototype.getRadius = function (a, e, b, c, g, f) {\n        var w = this.options,\n            l = \"width\" !== w.sizeBy,\n            k = w.zThreshold,\n            h = e - a,\n            d = .5;\n        if (null === f || null === g) return null;\n\n        if (J(g)) {\n          w.sizeByAbsoluteValue && (g = Math.abs(g - k), h = Math.max(e - k, Math.abs(a - k)), a = 0);\n          if (g < a) return b / 2 - 1;\n          0 < h && (d = (g - a) / h);\n        }\n\n        l && 0 <= d && (d = Math.sqrt(d));\n        return Math.ceil(b + d * (c - b)) / 2;\n      };\n\n      c.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      c.prototype.pointAttribs = function (a, e) {\n        var b = this.options.marker.fillOpacity;\n        a = E.prototype.pointAttribs.call(this, a, e);\n        1 !== b && (a.fill = n(a.fill).setOpacity(b).get(\"rgba\"));\n        return a;\n      };\n\n      c.prototype.translate = function () {\n        a.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n\n      c.prototype.translateBubble = function () {\n        for (var a = this.data, e = this.radii, b = this.getPxExtremes().minPxSize, c = a.length; c--;) {\n          var g = a[c],\n              f = e ? e[c] : 0;\n          J(f) && f >= b / 2 ? (g.marker = k(g.marker, {\n            radius: f,\n            width: 2 * f,\n            height: 2 * f\n          }), g.dlBox = {\n            x: g.plotX - f,\n            y: g.plotY - f,\n            width: 2 * f,\n            height: 2 * f\n          }) : (g.shapeArgs = g.plotY = g.dlBox = void 0, g.isInside = !1);\n        }\n      };\n\n      c.prototype.getPxExtremes = function () {\n        var a = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n            e = function (e) {\n          if (\"string\" === typeof e) {\n            var b = /%$/.test(e);\n            e = parseInt(e, 10);\n          }\n\n          return b ? a * e / 100 : e;\n        },\n            b = e(M(this.options.minSize, 8));\n\n        e = Math.max(e(M(this.options.maxSize, \"20%\")), b);\n        return {\n          minPxSize: b,\n          maxPxSize: e\n        };\n      };\n\n      c.prototype.getZExtremes = function () {\n        var a = this.options,\n            b = (this.zData || []).filter(J);\n\n        if (b.length) {\n          var c = M(a.zMin, l(g(b), !1 === a.displayNegative ? a.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));\n          a = M(a.zMax, e(b));\n          if (J(c) && J(a)) return {\n            zMin: c,\n            zMax: a\n          };\n        }\n      };\n\n      c.defaultOptions = H(p.defaultOptions, {\n        dataLabels: {\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n                e = this.point.z;\n            return J(e) ? a(e, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        animationLimit: 250,\n        marker: {\n          lineColor: null,\n          lineWidth: 1,\n          fillOpacity: .5,\n          radius: null,\n          states: {\n            hover: {\n              radiusPlus: 0\n            }\n          },\n          symbol: \"circle\"\n        },\n        minSize: 8,\n        maxSize: \"20%\",\n        softThreshold: !1,\n        states: {\n          hover: {\n            halo: {\n              size: 5\n            }\n          }\n        },\n        tooltip: {\n          pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: \"z\"\n      });\n      return c;\n    }(p);\n\n    k(d.prototype, {\n      alignDataLabel: a.alignDataLabel,\n      applyZones: h,\n      bubblePadding: !0,\n      buildKDTree: h,\n      directTouch: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: c,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    });\n    t(d, \"updatedData\", function (a) {\n      delete a.target.chart.bubbleZExtremes;\n    });\n    t(d, \"remove\", function (a) {\n      delete a.target.chart.bubbleZExtremes;\n    });\n    f.registerSeriesType(\"bubble\", d);\n    \"\";\n    \"\";\n    return d;\n  });\n  D(d, \"Series/ColumnRange/ColumnRangePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        a = b.seriesTypes;\n\n    b = a.column.prototype.pointClass.prototype;\n    var f = c.extend,\n        d = c.isNumber;\n\n    c = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.prototype.isValid = function () {\n        return d(this.low);\n      };\n\n      return b;\n    }(a.arearange.prototype.pointClass);\n\n    f(c.prototype, {\n      setState: b.setState\n    });\n    return c;\n  });\n  D(d, \"Series/ColumnRange/ColumnRangeSeries.js\", [d[\"Series/ColumnRange/ColumnRangePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function c() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    c = c.noop;\n    var h = d.seriesTypes,\n        m = h.arearange,\n        q = h.column,\n        n = h.column.prototype,\n        E = a.clamp;\n    h = a.extend;\n    var t = a.isNumber,\n        p = a.merge,\n        e = a.pick,\n        g = {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    };\n\n    a = function (a) {\n      function b() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      f(b, a);\n\n      b.prototype.setOptions = function () {\n        p(!0, arguments[0], {\n          stacking: void 0\n        });\n        return m.prototype.setOptions.apply(this, arguments);\n      };\n\n      b.prototype.translate = function () {\n        var a = this,\n            b = this.yAxis,\n            c = this.xAxis,\n            g = c.startAngleRad,\n            f = this.chart,\n            l = this.xAxis.isRadial,\n            d = Math.max(f.chartWidth, f.chartHeight) + 999,\n            h,\n            w,\n            k,\n            p;\n        n.translate.apply(this);\n        this.points.forEach(function (B) {\n          var r = B.shapeArgs || {},\n              z = a.options.minPointLength,\n              m = B.plotY,\n              G = b.translate(B.high, 0, 1, 0, 1);\n          t(G) && t(m) && (B.plotHigh = E(G, -d, d), B.plotLow = E(m, -d, d), p = B.plotHigh, h = e(B.rectPlotY, B.plotY) - B.plotHigh, Math.abs(h) < z ? (w = z - h, h += w, p -= w / 2) : 0 > h && (h *= -1, p -= h), l && a.polar ? (k = B.barX + g, B.shapeType = \"arc\", B.shapeArgs = a.polar.arc(p + h, p, k, k + B.pointWidth)) : (r.height = h, r.y = p, z = r.x, z = void 0 === z ? 0 : z, r = r.width, r = void 0 === r ? 0 : r, B.tooltipPos = f.inverted ? [b.len + b.pos - f.plotLeft - p - h / 2, c.len + c.pos - f.plotTop - z - r / 2, h] : [c.left - f.plotLeft + z + r / 2, b.pos - f.plotTop + p + h / 2, h]));\n        });\n      };\n\n      b.prototype.pointAttribs = function () {\n        return n.pointAttribs.apply(this, arguments);\n      };\n\n      b.prototype.translate3dPoints = function () {\n        return n.translate3dPoints.apply(this, arguments);\n      };\n\n      b.prototype.translate3dShapes = function () {\n        return n.translate3dShapes.apply(this, arguments);\n      };\n\n      b.defaultOptions = p(q.defaultOptions, m.defaultOptions, g);\n      return b;\n    }(m);\n\n    h(a.prototype, {\n      directTouch: !0,\n      pointClass: b,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      adjustForMissingColumns: n.adjustForMissingColumns,\n      animate: n.animate,\n      crispCol: n.crispCol,\n      drawGraph: c,\n      drawPoints: n.drawPoints,\n      getSymbol: c,\n      drawTracker: n.drawTracker,\n      getColumnMetrics: n.getColumnMetrics\n    });\n    d.registerSeriesType(\"columnrange\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        f = b.prototype,\n        d = h.clamp,\n        m = h.merge,\n        q = h.pick;\n\n    h = function (c) {\n      function h() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      a(h, c);\n\n      h.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            c = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        c = a.borderWidth = q(e.borderWidth, c ? 0 : 1);\n        var l = a.yAxis,\n            h = e.threshold,\n            m = a.translatedThreshold = l.getThreshold(h),\n            y = q(e.minPointLength, 5),\n            n = a.getColumnMetrics(),\n            F = n.width,\n            v = a.barW = Math.max(F, 1 + 2 * c),\n            E = a.pointXOffset = n.offset;\n        b.inverted && (m -= .5);\n        e.pointPadding && (v = Math.ceil(v));\n        f.translate.apply(a);\n        a.points.forEach(function (c) {\n          var g = q(c.yBottom, m),\n              f = 999 + Math.abs(g),\n              k = d(c.plotY, -f, l.len + f);\n          f = c.plotX + E;\n          var z = v / 2,\n              p = Math.min(k, g);\n          g = Math.max(k, g) - p;\n          var r;\n          c.barX = f;\n          c.pointWidth = F;\n          c.tooltipPos = b.inverted ? [l.len + l.pos - b.plotLeft - k, a.xAxis.len - f - z, g] : [f + z, k + l.pos - b.plotTop, g];\n          k = h + (c.total || c.y);\n          \"percent\" === e.stacking && (k = h + (0 > c.y) ? -100 : 100);\n          k = l.toPixels(k, !0);\n          var K = (r = b.plotHeight - k - (b.plotHeight - m)) ? z * (p - k) / r : 0;\n          var n = r ? z * (p + g - k) / r : 0;\n          r = f - K + z;\n          K = f + K + z;\n          var H = f + n + z;\n          n = f - n + z;\n          var A = p - y;\n          var t = p + g;\n          0 > c.y && (A = p, t = p + g + y);\n          b.inverted && (H = l.width - p, r = k - (l.width - m), K = z * (k - H) / r, n = z * (k - (H - g)) / r, r = f + z + K, K = r - 2 * K, H = f - n + z, n = f + n + z, A = p, t = p + g - y, 0 > c.y && (t = p + g + y));\n          c.shapeType = \"path\";\n          c.shapeArgs = {\n            x: r,\n            y: A,\n            width: K - r,\n            height: g,\n            d: [[\"M\", r, A], [\"L\", K, A], [\"L\", H, t], [\"L\", n, t], [\"Z\"]]\n          };\n        });\n      };\n\n      h.defaultOptions = m(b.defaultOptions, {});\n      return h;\n    }(b);\n\n    c.registerSeriesType(\"columnpyramid\", h);\n    \"\";\n    return h;\n  });\n  D(d, \"Series/ErrorBar/ErrorBarSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n      },\n      whiskerWidth: null\n    };\n  });\n  D(d, \"Series/ErrorBar/ErrorBarSeries.js\", [d[\"Series/BoxPlot/BoxPlotSeries.js\"], d[\"Series/Column/ColumnSeries.js\"], d[\"Series/ErrorBar/ErrorBarSeriesDefaults.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a, f) {\n    var d = this && this.__extends || function () {\n      var a = function (b, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(b, e);\n      };\n\n      return function (b, e) {\n        function c() {\n          this.constructor = b;\n        }\n\n        a(b, e);\n        b.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());\n      };\n    }(),\n        m = a.seriesTypes.arearange,\n        q = f.addEvent,\n        n = f.merge;\n\n    f = f.extend;\n\n    var E = function (a) {\n      function f() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.options = void 0;\n        e.points = void 0;\n        return e;\n      }\n\n      d(f, a);\n\n      f.prototype.getColumnMetrics = function () {\n        return this.linkedParent && this.linkedParent.columnMetrics || c.prototype.getColumnMetrics.call(this);\n      };\n\n      f.prototype.drawDataLabels = function () {\n        var a = this.pointValKey;\n        m && (m.prototype.drawDataLabels.call(this), this.data.forEach(function (e) {\n          e.y = e[a];\n        }));\n      };\n\n      f.prototype.toYData = function (a) {\n        return [a.low, a.high];\n      };\n\n      f.defaultOptions = n(b.defaultOptions, h);\n      return f;\n    }(b);\n\n    q(E, \"afterTranslate\", function () {\n      this.points.forEach(function (a) {\n        a.plotLow = a.plotY;\n      });\n    }, {\n      order: 0\n    });\n    f(E.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    });\n    a.registerSeriesType(\"errorbar\", E);\n    return E;\n  });\n  D(d, \"Series/Gauge/GaugePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"]], function (b) {\n    var c = this && this.__extends || function () {\n      var b = function (a, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return b(a, c);\n      };\n\n      return function (a, c) {\n        function f() {\n          this.constructor = a;\n        }\n\n        b(a, c);\n        a.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    return function (b) {\n      function a() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        a.shapeArgs = void 0;\n        return a;\n      }\n\n      c(a, b);\n\n      a.prototype.setState = function (a) {\n        this.state = a;\n      };\n\n      return a;\n    }(b.series.prototype.pointClass);\n  });\n  D(d, \"Series/Gauge/GaugeSeries.js\", [d[\"Series/Gauge/GaugePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, h, a) {\n    var f = this && this.__extends || function () {\n      var a = function (e, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var b in e) e.hasOwnProperty(b) && (a[b] = e[b]);\n        };\n\n        return a(e, b);\n      };\n\n      return function (e, b) {\n        function c() {\n          this.constructor = e;\n        }\n\n        a(e, b);\n        e.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }();\n\n    c = c.noop;\n    var d = h.series,\n        m = h.seriesTypes.column,\n        q = a.clamp,\n        n = a.isNumber,\n        E = a.extend,\n        t = a.merge,\n        p = a.pick,\n        e = a.pInt;\n\n    a = function (a) {\n      function b() {\n        var e = null !== a && a.apply(this, arguments) || this;\n        e.data = void 0;\n        e.points = void 0;\n        e.options = void 0;\n        e.yAxis = void 0;\n        return e;\n      }\n\n      f(b, a);\n\n      b.prototype.translate = function () {\n        var a = this.yAxis,\n            b = this.options,\n            c = a.center;\n        this.generatePoints();\n        this.points.forEach(function (g) {\n          var f = t(b.dial, g.dial),\n              h = e(f.radius) * c[2] / 200,\n              d = e(f.baseLength) * h / 100,\n              l = e(f.rearLength) * h / 100,\n              k = f.baseWidth,\n              w = f.topWidth,\n              B = b.overshoot,\n              z = a.startAngleRad + a.translate(g.y, void 0, void 0, void 0, !0);\n          if (n(B) || !1 === b.wrap) B = n(B) ? B / 180 * Math.PI : 0, z = q(z, a.startAngleRad - B, a.endAngleRad + B);\n          z = 180 * z / Math.PI;\n          g.shapeType = \"path\";\n          g.shapeArgs = {\n            d: f.path || [[\"M\", -l, -k / 2], [\"L\", d, -k / 2], [\"L\", h, -w / 2], [\"L\", h, w / 2], [\"L\", d, k / 2], [\"L\", -l, k / 2], [\"Z\"]],\n            translateX: c[0],\n            translateY: c[1],\n            rotation: z\n          };\n          g.plotX = c[0];\n          g.plotY = c[1];\n        });\n      };\n\n      b.prototype.drawPoints = function () {\n        var a = this,\n            e = a.chart,\n            b = a.yAxis.center,\n            c = a.pivot,\n            g = a.options,\n            f = g.pivot,\n            h = e.renderer;\n        a.points.forEach(function (b) {\n          var c = b.graphic,\n              f = b.shapeArgs,\n              d = f.d,\n              l = t(g.dial, b.dial);\n          c ? (c.animate(f), f.d = d) : b.graphic = h[b.shapeType](f).attr({\n            rotation: f.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!e.styledMode) b.graphic[c ? \"animate\" : \"attr\"]({\n            stroke: l.borderColor,\n            \"stroke-width\": l.borderWidth,\n            fill: l.backgroundColor\n          });\n        });\n        c ? c.animate({\n          translateX: b[0],\n          translateY: b[1]\n        }) : f && (a.pivot = h.circle(0, 0, f.radius).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(b[0], b[1]).add(a.group), e.styledMode || a.pivot.attr({\n          fill: f.backgroundColor,\n          stroke: f.borderColor,\n          \"stroke-width\": f.borderWidth\n        }));\n      };\n\n      b.prototype.animate = function (a) {\n        var e = this;\n        a || e.points.forEach(function (a) {\n          var b = a.graphic;\n          b && (b.attr({\n            rotation: 180 * e.yAxis.startAngleRad / Math.PI\n          }), b.animate({\n            rotation: a.shapeArgs.rotation\n          }, e.options.animation));\n        });\n      };\n\n      b.prototype.render = function () {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"inherit\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        d.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      };\n\n      b.prototype.setData = function (a, e) {\n        d.prototype.setData.call(this, a, !1);\n        this.processData();\n        this.generatePoints();\n        p(e, !0) && this.chart.redraw();\n      };\n\n      b.prototype.hasData = function () {\n        return !!this.points.length;\n      };\n\n      b.defaultOptions = t(d.defaultOptions, {\n        dataLabels: {\n          borderColor: \"#cccccc\",\n          borderRadius: 3,\n          borderWidth: 1,\n          crop: !1,\n          defer: !1,\n          enabled: !0,\n          verticalAlign: \"top\",\n          y: 15,\n          zIndex: 2\n        },\n        dial: {\n          backgroundColor: \"#000000\",\n          baseLength: \"70%\",\n          baseWidth: 3,\n          borderColor: \"#cccccc\",\n          borderWidth: 0,\n          radius: \"80%\",\n          rearLength: \"10%\",\n          topWidth: 1\n        },\n        pivot: {\n          radius: 5,\n          borderWidth: 0,\n          borderColor: \"#cccccc\",\n          backgroundColor: \"#000000\"\n        },\n        tooltip: {\n          headerFormat: \"\"\n        },\n        showInLegend: !1\n      });\n      return b;\n    }(d);\n\n    E(a.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: c,\n      drawTracker: m.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: b,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    h.registerSeriesType(\"gauge\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Series/DragNodesComposition.js\", [d[\"Core/Utilities.js\"]], function (b) {\n    function c() {\n      var a = this,\n          b,\n          c,\n          d;\n      a.container && (b = h(a.container, \"mousedown\", function (b) {\n        var f = a.hoverPoint;\n        f && f.series && f.series.hasDraggableNodes && f.series.options.draggable && (f.series.onMouseDown(f, b), c = h(a.container, \"mousemove\", function (a) {\n          return f && f.series && f.series.onMouseMove(f, a);\n        }), d = h(a.container.ownerDocument, \"mouseup\", function (a) {\n          c();\n          d();\n          return f && f.series && f.series.onMouseUp(f, a);\n        }));\n      }));\n      h(a, \"destroy\", function () {\n        b();\n      });\n    }\n\n    var h = b.addEvent,\n        a = [];\n    return {\n      compose: function (b) {\n        -1 === a.indexOf(b) && (a.push(b), h(b, \"load\", c));\n      },\n      onMouseDown: function (a, b) {\n        b = this.chart.pointer.normalize(b);\n        a.fixedPosition = {\n          chartX: b.chartX,\n          chartY: b.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function (a, b) {\n        if (a.fixedPosition && a.inDragMode) {\n          var c = this.chart,\n              f = c.pointer.normalize(b);\n          b = a.fixedPosition.chartX - f.chartX;\n          f = a.fixedPosition.chartY - f.chartY;\n          var h = c.graphLayoutsLookup,\n              d = void 0,\n              y = void 0;\n          if (5 < Math.abs(b) || 5 < Math.abs(f)) d = a.fixedPosition.plotX - b, y = a.fixedPosition.plotY - f, c.isInsidePlot(d, y) && (a.plotX = d, a.plotY = y, a.hasDragged = !0, this.redrawHalo(a), h.forEach(function (a) {\n            a.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function (a, b) {\n        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function (a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n  });\n  D(d, \"Series/GraphLayoutComposition.js\", [d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    function d() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation();\n      }), this.redraw());\n    }\n\n    function a() {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation(!1);\n      }), this.redraw());\n    }\n\n    function f() {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.stop();\n      });\n    }\n\n    function y() {\n      var a = !1,\n          b = function (e) {\n        e.maxIterations-- && isFinite(e.temperature) && !e.isStable() && !e.enableSimulation && (e.beforeStep && e.beforeStep(), e.step(), c = !1, a = !0);\n      };\n\n      if (this.graphLayoutsLookup) {\n        m(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (a) {\n          return a.start();\n        }); !c;) {\n          var c = !0;\n          this.graphLayoutsLookup.forEach(b);\n        }\n\n        a && this.series.forEach(function (a) {\n          a && a.layout && a.render();\n        });\n      }\n    }\n\n    var m = b.setAnimation,\n        q = c.addEvent,\n        n = [];\n    return {\n      compose: function (b) {\n        n.indexOf(b) && (n.push(b), q(b, \"afterPrint\", d), q(b, \"beforePrint\", a), q(b, \"predraw\", f), q(b, \"render\", y));\n      },\n      integrations: {},\n      layouts: {}\n    };\n  });\n  D(d, \"Series/PackedBubble/PackedBubblePoint.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"]], function (b, c, d) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }();\n\n    return function (f) {\n      function d() {\n        var a = null !== f && f.apply(this, arguments) || this;\n        a.degree = NaN;\n        a.mass = NaN;\n        a.radius = NaN;\n        a.options = void 0;\n        a.series = void 0;\n        a.value = null;\n        return a;\n      }\n\n      a(d, f);\n\n      d.prototype.destroy = function () {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return c.prototype.destroy.apply(this, arguments);\n      };\n\n      d.prototype.firePointEvent = function () {\n        var a = this.series.options;\n\n        if (this.isParentNode && a.parentNode) {\n          var b = a.allowPointSelect;\n          a.allowPointSelect = a.parentNode.allowPointSelect;\n          c.prototype.firePointEvent.apply(this, arguments);\n          a.allowPointSelect = b;\n        } else c.prototype.firePointEvent.apply(this, arguments);\n      };\n\n      d.prototype.select = function () {\n        var a = this.series.chart;\n        this.isParentNode ? (a.getSelectedPoints = a.getSelectedParentNodes, c.prototype.select.apply(this, arguments), a.getSelectedPoints = b.prototype.getSelectedPoints) : c.prototype.select.apply(this, arguments);\n      };\n\n      return d;\n    }(d.seriesTypes.bubble.prototype.pointClass);\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleSeriesDefaults.js\", [d[\"Core/Utilities.js\"]], function (b) {\n    var c = b.isNumber;\n    \"\";\n    return {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function () {\n          var b = this.series.chart.numberFormatter,\n              a = this.point.value;\n          return c(a) ? b(a, -1) : \"\";\n        },\n        parentNodeFormatter: function () {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: null,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1E3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/VerletIntegration.js\", [], function () {\n    return {\n      attractive: function (b, c, d) {\n        var a = b.getMass(),\n            f = -d.x * c * this.diffTemperature;\n        c = -d.y * c * this.diffTemperature;\n        b.fromNode.fixedPosition || (b.fromNode.plotX -= f * a.fromNode / b.fromNode.degree, b.fromNode.plotY -= c * a.fromNode / b.fromNode.degree);\n        b.toNode.fixedPosition || (b.toNode.plotX += f * a.toNode / b.toNode.degree, b.toNode.plotY += c * a.toNode / b.toNode.degree);\n      },\n      attractiveForceFunction: function (b, c) {\n        return (c - b) / b;\n      },\n      barycenter: function () {\n        var b = this.options.gravitationalConstant,\n            c = this.barycenter.xFactor,\n            d = this.barycenter.yFactor;\n        c = (c - (this.box.left + this.box.width) / 2) * b;\n        d = (d - (this.box.top + this.box.height) / 2) * b;\n        this.nodes.forEach(function (a) {\n          a.fixedPosition || (a.plotX -= c / a.mass / a.degree, a.plotY -= d / a.mass / a.degree);\n        });\n      },\n      getK: function (b) {\n        return Math.pow(b.box.width * b.box.height / b.nodes.length, .5);\n      },\n      integrate: function (b, c) {\n        var d = -b.options.friction,\n            a = b.options.maxSpeed,\n            f = (c.plotX + c.dispX - c.prevX) * d;\n        d *= c.plotY + c.dispY - c.prevY;\n        var y = Math.abs,\n            m = y(f) / (f || 1);\n        y = y(d) / (d || 1);\n        f = m * Math.min(a, Math.abs(f));\n        d = y * Math.min(a, Math.abs(d));\n        c.prevX = c.plotX + c.dispX;\n        c.prevY = c.plotY + c.dispY;\n        c.plotX += f;\n        c.plotY += d;\n        c.temperature = b.vectorLength({\n          x: f,\n          y: d\n        });\n      },\n      repulsive: function (b, c, d) {\n        c = c * this.diffTemperature / b.mass / b.degree;\n        b.fixedPosition || (b.plotX += d.x * c, b.plotY += d.y * c);\n      },\n      repulsiveForceFunction: function (b, c) {\n        return (c - b) / b * (c > b ? 1 : 0);\n      }\n    };\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleIntegration.js\", [d[\"Core/Globals.js\"], d[\"Series/Networkgraph/VerletIntegration.js\"]], function (b, c) {\n    return {\n      barycenter: function () {\n        for (var b = this.options.gravitationalConstant, a = this.box, c = this.nodes, d, m, q = 0; q < c.length; q++) {\n          var n = c[q];\n          this.options.splitSeries && !n.isParentNode ? (d = n.series.parentNode.plotX, m = n.series.parentNode.plotY) : (d = a.width / 2, m = a.height / 2);\n          n.fixedPosition || (n.plotX -= (n.plotX - d) * b / (n.mass * Math.sqrt(c.length)), n.plotY -= (n.plotY - m) * b / (n.mass * Math.sqrt(c.length)));\n        }\n      },\n      getK: b.noop,\n      integrate: c.integrate,\n      repulsive: function (b, a, c, d) {\n        var f = a * this.diffTemperature / b.mass / b.degree;\n        a = c.x * f;\n        c = c.y * f;\n        b.fixedPosition || (b.plotX += a, b.plotY += c);\n        d.fixedPosition || (d.plotX -= a, d.plotY -= c);\n      },\n      repulsiveForceFunction: function (b, a, c, d) {\n        return Math.min(b, (c.marker.radius + d.marker.radius) / 2);\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/EulerIntegration.js\", [], function () {\n    return {\n      attractive: function (b, c, d, a) {\n        var f = b.getMass(),\n            h = d.x / a * c;\n        c *= d.y / a;\n        b.fromNode.fixedPosition || (b.fromNode.dispX -= h * f.fromNode / b.fromNode.degree, b.fromNode.dispY -= c * f.fromNode / b.fromNode.degree);\n        b.toNode.fixedPosition || (b.toNode.dispX += h * f.toNode / b.toNode.degree, b.toNode.dispY += c * f.toNode / b.toNode.degree);\n      },\n      attractiveForceFunction: function (b, c) {\n        return b * b / c;\n      },\n      barycenter: function () {\n        var b = this.options.gravitationalConstant,\n            c = this.barycenter.xFactor,\n            d = this.barycenter.yFactor;\n        this.nodes.forEach(function (a) {\n          if (!a.fixedPosition) {\n            var f = a.getDegree();\n            f *= 1 + f / 2;\n            a.dispX += (c - a.plotX) * b * f / a.degree;\n            a.dispY += (d - a.plotY) * b * f / a.degree;\n          }\n        });\n      },\n      getK: function (b) {\n        return Math.pow(b.box.width * b.box.height / b.nodes.length, .3);\n      },\n      integrate: function (b, c) {\n        c.dispX += c.dispX * b.options.friction;\n        c.dispY += c.dispY * b.options.friction;\n        var d = c.temperature = b.vectorLength({\n          x: c.dispX,\n          y: c.dispY\n        });\n        0 !== d && (c.plotX += c.dispX / d * Math.min(Math.abs(c.dispX), b.temperature), c.plotY += c.dispY / d * Math.min(Math.abs(c.dispY), b.temperature));\n      },\n      repulsive: function (b, c, d, a) {\n        b.dispX += d.x / a * c / b.degree;\n        b.dispY += d.y / a * c / b.degree;\n      },\n      repulsiveForceFunction: function (b, c) {\n        return c * c / b;\n      }\n    };\n  });\n  D(d, \"Series/Networkgraph/QuadTreeNode.js\", [], function () {\n    return function () {\n      function b(b) {\n        this.isInternal = this.isEmpty = this.body = !1;\n        this.nodes = [];\n        this.box = b;\n        this.boxSize = Math.min(b.width, b.height);\n      }\n\n      b.prototype.divideBox = function () {\n        var c = this.box.width / 2,\n            d = this.box.height / 2;\n        this.nodes[0] = new b({\n          left: this.box.left,\n          top: this.box.top,\n          width: c,\n          height: d\n        });\n        this.nodes[1] = new b({\n          left: this.box.left + c,\n          top: this.box.top,\n          width: c,\n          height: d\n        });\n        this.nodes[2] = new b({\n          left: this.box.left + c,\n          top: this.box.top + d,\n          width: c,\n          height: d\n        });\n        this.nodes[3] = new b({\n          left: this.box.left,\n          top: this.box.top + d,\n          width: c,\n          height: d\n        });\n      };\n\n      b.prototype.getBoxPosition = function (b) {\n        var c = b.plotY < this.box.top + this.box.height / 2;\n        return b.plotX < this.box.left + this.box.width / 2 ? c ? 0 : 3 : c ? 1 : 2;\n      };\n\n      b.prototype.insert = function (c, d) {\n        this.isInternal ? this.nodes[this.getBoxPosition(c)].insert(c, d - 1) : (this.isEmpty = !1, this.body ? d ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, d - 1), this.body = !0), this.nodes[this.getBoxPosition(c)].insert(c, d - 1)) : (d = new b({\n          top: c.plotX || NaN,\n          left: c.plotY || NaN,\n          width: .1,\n          height: .1\n        }), d.body = c, d.isInternal = !1, this.nodes.push(d)) : (this.isInternal = !1, this.body = c));\n      };\n\n      b.prototype.updateMassAndCenter = function () {\n        var b = 0,\n            d = 0,\n            a = 0;\n\n        if (this.isInternal) {\n          for (var f = 0, y = this.nodes; f < y.length; f++) {\n            var m = y[f];\n            m.isEmpty || (b += m.mass, d += m.plotX * m.mass, a += m.plotY * m.mass);\n          }\n\n          d /= b;\n          a /= b;\n        } else this.body && (b = this.body.mass, d = this.body.plotX, a = this.body.plotY);\n\n        this.mass = b;\n        this.plotX = d;\n        this.plotY = a;\n      };\n\n      return b;\n    }();\n  });\n  D(d, \"Series/Networkgraph/QuadTree.js\", [d[\"Series/Networkgraph/QuadTreeNode.js\"]], function (b) {\n    return function () {\n      function c(c, a, d, y) {\n        this.box = {\n          left: c,\n          top: a,\n          width: d,\n          height: y\n        };\n        this.maxDepth = 25;\n        this.root = new b(this.box);\n        this.root.isInternal = !0;\n        this.root.isRoot = !0;\n        this.root.divideBox();\n      }\n\n      c.prototype.calculateMassAndCenter = function () {\n        this.visitNodeRecursive(null, null, function (b) {\n          b.updateMassAndCenter();\n        });\n      };\n\n      c.prototype.insertNodes = function (b) {\n        for (var a = 0; a < b.length; a++) this.root.insert(b[a], this.maxDepth);\n      };\n\n      c.prototype.visitNodeRecursive = function (b, a, c) {\n        var d;\n        b || (b = this.root);\n        b === this.root && a && (d = a(b));\n\n        if (!1 !== d) {\n          for (var f = 0, h = b.nodes; f < h.length; f++) {\n            var n = h[f];\n\n            if (n.isInternal) {\n              a && (d = a(n));\n              if (!1 === d) continue;\n              this.visitNodeRecursive(n, a, c);\n            } else n.body && a && a(n.body);\n\n            c && c(n);\n          }\n\n          b === this.root && c && c(b);\n        }\n      };\n\n      return c;\n    }();\n  });\n  D(d, \"Series/Networkgraph/ReingoldFruchtermanLayout.js\", [d[\"Series/Networkgraph/EulerIntegration.js\"], d[\"Core/Globals.js\"], d[\"Series/GraphLayoutComposition.js\"], d[\"Series/Networkgraph/QuadTree.js\"], d[\"Core/Utilities.js\"], d[\"Series/Networkgraph/VerletIntegration.js\"]], function (b, c, d, a, f, y) {\n    var h = c.win,\n        q = f.clamp,\n        n = f.defined,\n        E = f.isFunction,\n        t = f.pick;\n    return function () {\n      function c() {\n        this.attractiveForce = void 0;\n        this.box = {};\n        this.currentStep = 0;\n        this.initialRendering = !0;\n        this.integration = void 0;\n        this.links = [];\n        this.nodes = [];\n        this.repulsiveForce = this.quadTree = this.options = void 0;\n        this.series = [];\n        this.simulation = !1;\n      }\n\n      c.compose = function (a) {\n        d.compose(a);\n        d.integrations.euler = b;\n        d.integrations.verlet = y;\n        d.layouts[\"reingold-fruchterman\"] = c;\n      };\n\n      c.prototype.init = function (a) {\n        this.options = a;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = d.integrations[a.integration];\n        this.enableSimulation = a.enableSimulation;\n        this.attractiveForce = t(a.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = t(a.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = a.approximation;\n      };\n\n      c.prototype.updateSimulation = function (a) {\n        this.enableSimulation = t(a, this.options.enableSimulation);\n      };\n\n      c.prototype.start = function () {\n        var a = this.series,\n            b = this.options;\n        this.currentStep = 0;\n        this.forces = a[0] && a[0].forces || [];\n        this.chart = a[0] && a[0].chart;\n        this.initialRendering && (this.initPositions(), a.forEach(function (a) {\n          a.finishedAnimating = !0;\n          a.render();\n        }));\n        this.setK();\n        this.resetSimulation(b);\n        this.enableSimulation && this.step();\n      };\n\n      c.prototype.step = function () {\n        var a = this,\n            b = this.series;\n        this.currentStep++;\n        \"barnes-hut\" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter());\n\n        for (var c = 0, d = this.forces || []; c < d.length; c++) this[d[c] + \"Forces\"](this.temperature);\n\n        this.applyLimits();\n        this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n        this.prevSystemTemperature = this.systemTemperature;\n        this.systemTemperature = this.getSystemTemperature();\n\n        if (this.enableSimulation) {\n          for (c = 0; c < b.length; c++) d = b[c], d.chart && d.render();\n\n          this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && h.cancelAnimationFrame(this.simulation), this.simulation = h.requestAnimationFrame(function () {\n            return a.step();\n          })) : this.simulation = !1;\n        }\n      };\n\n      c.prototype.stop = function () {\n        this.simulation && h.cancelAnimationFrame(this.simulation);\n      };\n\n      c.prototype.setArea = function (a, b, c, d) {\n        this.box = {\n          left: a,\n          top: b,\n          width: c,\n          height: d\n        };\n      };\n\n      c.prototype.setK = function () {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      };\n\n      c.prototype.addElementsToCollection = function (a, b) {\n        for (var e = 0; e < a.length; e++) {\n          var c = a[e];\n          -1 === b.indexOf(c) && b.push(c);\n        }\n      };\n\n      c.prototype.removeElementFromCollection = function (a, b) {\n        a = b.indexOf(a);\n        -1 !== a && b.splice(a, 1);\n      };\n\n      c.prototype.clear = function () {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      };\n\n      c.prototype.resetSimulation = function () {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      };\n\n      c.prototype.restartSimulation = function () {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      };\n\n      c.prototype.setMaxIterations = function (a) {\n        this.maxIterations = t(a, this.options.maxIterations);\n      };\n\n      c.prototype.setTemperature = function () {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      };\n\n      c.prototype.setDiffTemperature = function () {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      };\n\n      c.prototype.setInitialRendering = function (a) {\n        this.initialRendering = a;\n      };\n\n      c.prototype.createQuadTree = function () {\n        this.quadTree = new a(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      };\n\n      c.prototype.initPositions = function () {\n        var a = this.options.initialPositions;\n\n        if (E(a)) {\n          a.call(this);\n          a = 0;\n\n          for (var b = this.nodes; a < b.length; a++) {\n            var c = b[a];\n            n(c.prevX) || (c.prevX = c.plotX);\n            n(c.prevY) || (c.prevY = c.plotY);\n            c.dispX = 0;\n            c.dispY = 0;\n          }\n        } else \"circle\" === a ? this.setCircularPositions() : this.setRandomPositions();\n      };\n\n      c.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), d = b.filter(function (a) {\n          return 0 === a.linksTo.length;\n        }), f = {}, h = this.options.initialPositionRadius, p = function (a) {\n          var b = 0;\n\n          for (a = a.linksFrom || []; b < a.length; b++) {\n            var c = a[b];\n            f[c.toNode.id] || (f[c.toNode.id] = !0, n.push(c.toNode), p(c.toNode));\n          }\n        }, n = [], v = 0; v < d.length; v++) {\n          var m = d[v];\n          n.push(m);\n          p(m);\n        }\n\n        if (n.length) for (d = 0; d < b.length; d++) v = b[d], -1 === n.indexOf(v) && n.push(v);else n = b;\n        d = 0;\n\n        for (v = n.length; d < v; ++d) b = n[d], b.plotX = b.prevX = t(b.plotX, a.width / 2 + h * Math.cos(d * c)), b.plotY = b.prevY = t(b.plotY, a.height / 2 + h * Math.sin(d * c)), b.dispX = 0, b.dispY = 0;\n      };\n\n      c.prototype.setRandomPositions = function () {\n        for (var a = this.box, b = this.nodes, c = b.length + 1, d = function (a) {\n          a = a * a / Math.PI;\n          return a -= Math.floor(a);\n        }, f, h = 0, p = b.length; h < p; ++h) f = b[h], f.plotX = f.prevX = t(f.plotX, a.width * d(h)), f.plotY = f.prevY = t(f.plotY, a.height * d(c + h)), f.dispX = 0, f.dispY = 0;\n      };\n\n      c.prototype.force = function (a) {\n        for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];\n\n        this.integration[a].apply(this, b);\n      };\n\n      c.prototype.barycenterForces = function () {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      };\n\n      c.prototype.getBarycenter = function () {\n        for (var a = 0, b = 0, c = 0, d = 0, f = this.nodes; d < f.length; d++) {\n          var h = f[d];\n          b += h.plotX * h.mass;\n          c += h.plotY * h.mass;\n          a += h.mass;\n        }\n\n        return this.barycenter = {\n          x: b,\n          y: c,\n          xFactor: b / a,\n          yFactor: c / a\n        };\n      };\n\n      c.prototype.barnesHutApproximation = function (a, b) {\n        var c = this.getDistXY(a, b),\n            e = this.vectorLength(c);\n        if (a !== b && 0 !== e) if (b.isInternal) {\n          if (b.boxSize / e < this.options.theta && 0 !== e) {\n            var d = this.repulsiveForce(e, this.k);\n            this.force(\"repulsive\", a, d * b.mass, c, e);\n            var g = !1;\n          } else g = !0;\n        } else d = this.repulsiveForce(e, this.k), this.force(\"repulsive\", a, d * b.mass, c, e);\n        return g;\n      };\n\n      c.prototype.repulsiveForces = function () {\n        var a = this;\n        if (\"barnes-hut\" === this.approximation) for (var b = function (b) {\n          c.quadTree.visitNodeRecursive(null, function (c) {\n            return a.barnesHutApproximation(b, c);\n          });\n        }, c = this, d = 0, f = this.nodes; d < f.length; d++) {\n          var h = f[d];\n          b(h);\n        } else {\n          f = d = b = void 0;\n\n          for (var p = 0, n = this.nodes; p < n.length; p++) {\n            h = n[p];\n\n            for (var v = 0, m = this.nodes; v < m.length; v++) {\n              var q = m[v];\n              h === q || h.fixedPosition || (f = this.getDistXY(h, q), d = this.vectorLength(f), 0 !== d && (b = this.repulsiveForce(d, this.k), this.force(\"repulsive\", h, b * q.mass, f, d)));\n            }\n          }\n        }\n      };\n\n      c.prototype.attractiveForces = function () {\n        for (var a, b, c, d = 0, f = this.links; d < f.length; d++) {\n          var h = f[d];\n          h.fromNode && h.toNode && (a = this.getDistXY(h.fromNode, h.toNode), b = this.vectorLength(a), 0 !== b && (c = this.attractiveForce(b, this.k), this.force(\"attractive\", h, c, a, b)));\n        }\n      };\n\n      c.prototype.applyLimits = function () {\n        for (var a = 0, b = this.nodes; a < b.length; a++) {\n          var c = b[a];\n          if (c.fixedPosition) break;\n          this.integration.integrate(this, c);\n          this.applyLimitBox(c, this.box);\n          c.dispX = 0;\n          c.dispY = 0;\n        }\n      };\n\n      c.prototype.applyLimitBox = function (a, b) {\n        var c = a.radius;\n        a.plotX = q(a.plotX, b.left + c, b.width - c);\n        a.plotY = q(a.plotY, b.top + c, b.height - c);\n      };\n\n      c.prototype.coolDown = function (a, b, c) {\n        return a - b * c;\n      };\n\n      c.prototype.isStable = function () {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      };\n\n      c.prototype.getSystemTemperature = function () {\n        for (var a = 0, b = 0, c = this.nodes; b < c.length; b++) a += c[b].temperature;\n\n        return a;\n      };\n\n      c.prototype.vectorLength = function (a) {\n        return Math.sqrt(a.x * a.x + a.y * a.y);\n      };\n\n      c.prototype.getDistR = function (a, b) {\n        a = this.getDistXY(a, b);\n        return this.vectorLength(a);\n      };\n\n      c.prototype.getDistXY = function (a, b) {\n        var c = a.plotX - b.plotX;\n        a = a.plotY - b.plotY;\n        return {\n          x: c,\n          y: a,\n          absX: Math.abs(c),\n          absY: Math.abs(a)\n        };\n      };\n\n      return c;\n    }();\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleLayout.js\", [d[\"Series/GraphLayoutComposition.js\"], d[\"Series/PackedBubble/PackedBubbleIntegration.js\"], d[\"Series/Networkgraph/ReingoldFruchtermanLayout.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    function f() {\n      var a = [];\n      this.series.forEach(function (b) {\n        b.parentNode && b.parentNode.selected && a.push(b.parentNode);\n      });\n      return a;\n    }\n\n    function h() {\n      this.allDataPoints && delete this.allDataPoints;\n    }\n\n    var m = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        q = a.addEvent,\n        n = a.pick,\n        E = [];\n\n    a = function (a) {\n      function p() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.index = NaN;\n        b.nodes = [];\n        b.options = void 0;\n        b.series = [];\n        return b;\n      }\n\n      m(p, a);\n\n      p.compose = function (a) {\n        d.compose(a);\n        b.integrations.packedbubble = c;\n        b.layouts.packedbubble = p;\n        -1 === E.indexOf(a) && (E.push(a), q(a, \"beforeRedraw\", h), a.prototype.getSelectedParentNodes = f);\n      };\n\n      p.prototype.beforeStep = function () {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      };\n\n      p.prototype.isStable = function () {\n        var a = Math.abs(this.prevSystemTemperature - this.systemTemperature);\n        return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && .00001 > a || 0 >= this.temperature;\n      };\n\n      p.prototype.setCircularPositions = function () {\n        for (var a = this.box, b = this.nodes, c = 2 * Math.PI / (b.length + 1), d = this.options.initialPositionRadius, f, h, p = 0, m = 0; m < b.length; m++) {\n          var v = b[m];\n          this.options.splitSeries && !v.isParentNode ? (f = v.series.parentNode.plotX, h = v.series.parentNode.plotY) : (f = a.width / 2, h = a.height / 2);\n          v.plotX = v.prevX = n(v.plotX, f + d * Math.cos(v.index || p * c));\n          v.plotY = v.prevY = n(v.plotY, h + d * Math.sin(v.index || p * c));\n          v.dispX = 0;\n          v.dispY = 0;\n          p++;\n        }\n      };\n\n      p.prototype.repulsiveForces = function () {\n        var a = this,\n            b = a.options.bubblePadding,\n            c,\n            d,\n            f;\n        a.nodes.forEach(function (e) {\n          e.degree = e.mass;\n          e.neighbours = 0;\n          a.nodes.forEach(function (g) {\n            c = 0;\n            e === g || e.fixedPosition || !a.options.seriesInteraction && e.series !== g.series || (f = a.getDistXY(e, g), d = a.vectorLength(f) - (e.marker.radius + g.marker.radius + b), 0 > d && (e.degree += .01, e.neighbours++, c = a.repulsiveForce(-d / Math.sqrt(e.neighbours), a.k, e, g)), a.force(\"repulsive\", e, c * g.mass, f, g, d));\n          });\n        });\n      };\n\n      p.prototype.applyLimitBox = function (b, c) {\n        if (this.options.splitSeries && !b.isParentNode && this.options.parentNodeLimit) {\n          var e = this.getDistXY(b, b.series.parentNode);\n          var d = b.series.parentNodeRadius - b.marker.radius - this.vectorLength(e);\n          0 > d && d > -2 * b.marker.radius && (b.plotX -= .01 * e.x, b.plotY -= .01 * e.y);\n        }\n\n        a.prototype.applyLimitBox.call(this, b, c);\n      };\n\n      return p;\n    }(d);\n\n    return b.layouts.packedbubble = a;\n  });\n  D(d, \"Series/PackedBubble/PackedBubbleSeries.js\", [d[\"Core/Color/Color.js\"], d[\"Series/DragNodesComposition.js\"], d[\"Series/GraphLayoutComposition.js\"], d[\"Core/Globals.js\"], d[\"Series/PackedBubble/PackedBubblePoint.js\"], d[\"Series/PackedBubble/PackedBubbleSeriesDefaults.js\"], d[\"Series/PackedBubble/PackedBubbleLayout.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a, f, y, m, q, n) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        t = b.parse;\n\n    b = a.noop;\n    var p = q.series.prototype,\n        e = q.seriesTypes.bubble,\n        g = n.addEvent,\n        l = n.clamp,\n        k = n.defined,\n        D = n.extend,\n        H = n.fireEvent,\n        M = n.isArray,\n        F = n.isNumber,\n        v = n.merge,\n        Q = n.pick;\n\n    n = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.layout = void 0;\n        b.options = void 0;\n        b.parentNodeMass = 0;\n        b.points = void 0;\n        b.xData = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.compose = function (a, b, d, f) {\n        e.compose(a, b, d, f);\n        c.compose(b);\n        m.compose(b);\n      };\n\n      b.prototype.accumulateAllPoints = function () {\n        for (var a = this.chart, b = [], c, e = 0, d = a.series; e < d.length; e++) {\n          var f = d[e];\n\n          if (f.is(\"packedbubble\") && f.visible || !a.options.chart.ignoreHiddenSeries) {\n            c = f.yData || [];\n\n            for (var g = 0; g < c.length; g++) b.push([null, null, c[g], f.index, g, {\n              id: g,\n              marker: {\n                radius: 0\n              }\n            }]);\n          }\n        }\n\n        return b;\n      };\n\n      b.prototype.addLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.options.chart,\n            e = this.chart.graphLayoutsStorage,\n            f = this.chart.graphLayoutsLookup;\n        e || (this.chart.graphLayoutsStorage = e = {}, this.chart.graphLayoutsLookup = f = []);\n        var g = e[b];\n        g || (a.enableSimulation = k(c.forExport) ? !c.forExport : a.enableSimulation, e[b] = g = new d.layouts[b](), g.init(a), f.splice(g.index, 0, g));\n        this.layout = g;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        g.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        g.addElementsToCollection([this], g.series);\n        g.addElementsToCollection(this.points, g.nodes);\n      };\n\n      b.prototype.addSeriesLayout = function () {\n        var a = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},\n            b = a.type || \"packedbubble\",\n            c = this.chart.graphLayoutsStorage,\n            e = this.chart.graphLayoutsLookup;\n        a = v(a, a.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var f = c[b + \"-series\"];\n        f || (c[b + \"-series\"] = f = new d.layouts[b](), f.init(a), e.splice(f.index, 0, f));\n        this.parentNodeLayout = f;\n        this.createParentNodes();\n      };\n\n      b.prototype.calculateParentRadius = function () {\n        var a = this.seriesBox();\n        this.parentNodeRadius = l(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      };\n\n      b.prototype.calculateZExtremes = function () {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            c = Infinity,\n            e = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            k(a) && (a > e && (e = a), a < c && (c = a));\n          });\n        });\n        a = Q(a, c);\n        b = Q(b, e);\n        return [a, b];\n      };\n\n      b.prototype.checkOverlap = function (a, b) {\n        var c = a[0] - b[0],\n            e = a[1] - b[1];\n        return -.001 > Math.sqrt(c * c + e * e) - Math.abs(a[2] + b[2]);\n      };\n\n      b.prototype.createParentNodes = function () {\n        var a = this,\n            b = this.pointClass,\n            c = this.chart,\n            e = this.parentNodeLayout,\n            d = this.layout.options,\n            f,\n            g = this.parentNode,\n            h = {\n          radius: this.parentNodeRadius,\n          lineColor: this.color,\n          fillColor: t(this.color).brighten(.4).get()\n        };\n        d.parentNodeOptions && (h = v(d.parentNodeOptions.marker || {}, h));\n        this.parentNodeMass = 0;\n        this.points.forEach(function (b) {\n          a.parentNodeMass += Math.PI * Math.pow(b.marker.radius, 2);\n        });\n        this.calculateParentRadius();\n        e.nodes.forEach(function (b) {\n          b.seriesIndex === a.index && (f = !0);\n        });\n        e.setArea(0, 0, c.plotWidth, c.plotHeight);\n        f || (g || (g = new b().init(this, {\n          mass: this.parentNodeRadius / 2,\n          marker: h,\n          dataLabels: {\n            inside: !1\n          },\n          states: {\n            normal: {\n              marker: h\n            },\n            hover: {\n              marker: h\n            }\n          },\n          dataLabelOnNull: !0,\n          degree: this.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: this.index\n        })), this.parentNode && (g.plotX = this.parentNode.plotX, g.plotY = this.parentNode.plotY), this.parentNode = g, e.addElementsToCollection([this], e.series), e.addElementsToCollection([g], e.nodes));\n      };\n\n      b.prototype.deferLayout = function () {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      };\n\n      b.prototype.destroy = function () {\n        var a = this;\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (b) {\n          b.removeElementFromCollection(a, b.series);\n        }, this);\n        this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        p.destroy.apply(this, arguments);\n      };\n\n      b.prototype.drawDataLabels = function () {\n        p.drawDataLabels.call(this, this.points);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", p.drawDataLabels.call(this, [this.parentNode]));\n      };\n\n      b.prototype.drawGraph = function () {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart,\n              b = this.layout.options.parentNodeOptions.marker;\n          b = {\n            fill: b.fillColor || t(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": Q(b.lineWidth, this.options.lineWidth)\n          };\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          var c = v({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, b);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(b.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(c);\n        }\n      };\n\n      b.prototype.drawTracker = function () {\n        var b = this.parentNode;\n        a.prototype.drawTracker.call(this);\n\n        if (b) {\n          var c = M(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          c.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        }\n      };\n\n      b.prototype.getPointRadius = function () {\n        var a = this,\n            b = this.chart,\n            c = this.options,\n            e = c.useSimulation,\n            d = Math.min(b.plotWidth, b.plotHeight),\n            f = {},\n            g = [],\n            h = b.allDataPoints || [],\n            k = h.length,\n            p,\n            n,\n            u,\n            C;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              e = /%$/.test(c[a]);\n          f[a] = e ? d * b / 100 : b * Math.sqrt(k);\n        });\n        b.minRadius = p = f.minSize / Math.sqrt(k);\n        b.maxRadius = n = f.maxSize / Math.sqrt(k);\n        var x = e ? this.calculateZExtremes() : [p, n];\n        h.forEach(function (b, c) {\n          u = e ? l(b[2], x[0], x[1]) : b[2];\n          C = a.getRadius(x[0], x[1], p, n, u);\n          0 === C && (C = null);\n          h[c][2] = C;\n          g.push(C);\n        });\n        this.radii = g;\n      };\n\n      b.prototype.init = function () {\n        p.init.apply(this, arguments);\n        this.eventsToUnbind.push(g(this, \"updatedData\", function () {\n          var a = this;\n          this.chart.series.forEach(function (b) {\n            b.type === a.type && (b.isDirty = !0);\n          }, this);\n        }));\n        return this;\n      };\n\n      b.prototype.onMouseUp = function (a) {\n        var b = a;\n\n        if (b.fixedPosition && !b.removed) {\n          var e = this.layout,\n              d = this.parentNodeLayout,\n              f,\n              g;\n          d && e.options.dragBetweenSeries && d.nodes.forEach(function (a) {\n            b && b.marker && a !== b.series.parentNode && (f = e.getDistXY(b, a), g = e.vectorLength(f) - a.marker.radius - b.marker.radius, 0 > g && (a.series.addPoint(v(b.options, {\n              plotX: b.plotX,\n              plotY: b.plotY\n            }), !1), e.removeElementFromCollection(b, e.nodes), b.remove()));\n          });\n          c.onMouseUp.apply(this, arguments);\n        }\n      };\n\n      b.prototype.placeBubbles = function (a) {\n        var b = this.checkOverlap,\n            c = this.positionBubble,\n            e = [],\n            d = 1,\n            f = 0,\n            g = 0;\n        var h = [];\n        var l;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          e.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (e.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), l = 2; l < a.length; l++) a[l][2] = a[l][2] || 1, h = c(e[d][f], e[d - 1][g], a[l]), b(h, e[d][0]) ? (e.push([]), g = 0, e[d + 1].push(c(e[d][f], e[d][0], a[l])), d++, f = 0) : 1 < d && e[d - 1][g + 1] && b(h, e[d - 1][g + 1]) ? (g++, e[d].push(c(e[d][f], e[d - 1][g], a[l])), f++) : (f++, e[d].push(h));\n          this.chart.stages = e;\n          this.chart.rawPositions = [].concat.apply([], e);\n          this.resizeRadius();\n          h = this.chart.rawPositions;\n        }\n\n        return h;\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options,\n            e = c.marker;\n        a && a.isParentNode && c.layoutAlgorithm && c.layoutAlgorithm.parentNodeOptions && (e = c.layoutAlgorithm.parentNodeOptions.marker);\n        c = e.fillOpacity;\n        a = p.pointAttribs.call(this, a, b);\n        1 !== c && (a[\"fill-opacity\"] = c);\n        return a;\n      };\n\n      b.prototype.positionBubble = function (a, b, c) {\n        var e = Math.sqrt,\n            d = Math.asin,\n            f = Math.acos,\n            g = Math.pow,\n            h = Math.abs;\n        e = e(g(a[0] - b[0], 2) + g(a[1] - b[1], 2));\n        f = f((g(e, 2) + g(c[2] + b[2], 2) - g(c[2] + a[2], 2)) / (2 * (c[2] + b[2]) * e));\n        d = d(h(a[0] - b[0]) / e);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + f + d * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + c[2]) * Math.sin(a), b[1] - (b[2] + c[2]) * Math.cos(a), c[2], c[3], c[4]];\n      };\n\n      b.prototype.render = function () {\n        var a = [];\n        p.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (b) {\n          M(b.dataLabels) && b.dataLabels.forEach(function (b) {\n            a.push(b);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      };\n\n      b.prototype.resizeRadius = function () {\n        var a = this.chart,\n            b = a.rawPositions,\n            c = Math.min,\n            e = Math.max,\n            d = a.plotLeft,\n            f = a.plotTop,\n            g = a.plotHeight,\n            h = a.plotWidth,\n            l,\n            k;\n        var p = l = Number.POSITIVE_INFINITY;\n        var u = k = Number.NEGATIVE_INFINITY;\n\n        for (var C = 0; C < b.length; C++) {\n          var x = b[C];\n          var n = x[2];\n          p = c(p, x[0] - n);\n          u = e(u, x[0] + n);\n          l = c(l, x[1] - n);\n          k = e(k, x[1] + n);\n        }\n\n        x = [u - p, k - l];\n        c = c.apply([], [(h - d) / x[0], (g - f) / x[1]]);\n\n        if (1e-10 < Math.abs(c - 1)) {\n          for (a = 0; a < b.length; a++) x = b[a], x[2] *= c;\n\n          this.placeBubbles(b);\n        } else a.diffY = g / 2 + f - l - (k - l) / 2, a.diffX = h / 2 + d - p - (u - p) / 2;\n      };\n\n      b.prototype.seriesBox = function () {\n        var a = this.chart,\n            b = Math.max,\n            c = Math.min,\n            e = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight],\n            d;\n        this.data.forEach(function (a) {\n          k(a.plotX) && k(a.plotY) && a.marker.radius && (d = a.marker.radius, e[0] = c(e[0], a.plotX - d), e[1] = b(e[1], a.plotX + d), e[2] = c(e[2], a.plotY - d), e[3] = b(e[3], a.plotY + d));\n        });\n        return F(e.width / e.height) ? e : null;\n      };\n\n      b.prototype.setVisible = function () {\n        var a = this;\n        p.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (b) {\n          a.layout.removeElementFromCollection(b, a.layout.nodes);\n        }));\n      };\n\n      b.prototype.translate = function () {\n        var a = this.chart,\n            b = this.data,\n            c = this.index,\n            e = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        k(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(), this.getPointRadius());\n        if (e) var d = a.allDataPoints;else d = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (var f = 0, g = d; f < g.length; f++) {\n          var h = g[f];\n\n          if (h[3] === c) {\n            d = b[h[4]];\n            var l = Q(h[2], void 0);\n            e || (d.plotX = h[0] - a.plotLeft + a.diffX, d.plotY = h[1] - a.plotTop + a.diffY);\n            F(l) && (d.marker = D(d.marker, {\n              radius: l,\n              width: 2 * l,\n              height: 2 * l\n            }), d.radius = l);\n          }\n        }\n\n        e && this.deferLayout();\n        H(this, \"afterTranslate\");\n      };\n\n      b.defaultOptions = v(e.defaultOptions, y);\n      return b;\n    }(e);\n\n    D(n.prototype, {\n      pointClass: f,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointArrayMap: [\"value\"],\n      pointValKey: \"value\",\n      requireSorting: !1,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      alignDataLabel: p.alignDataLabel,\n      indexateNodes: b,\n      onMouseDown: c.onMouseDown,\n      onMouseMove: c.onMouseMove,\n      redrawHalo: c.redrawHalo,\n      searchPoint: b\n    });\n    q.registerSeriesType(\"packedbubble\", n);\n    \"\";\n    return n;\n  });\n  D(d, \"Series/Polygon/PolygonSeries.js\", [d[\"Core/Globals.js\"], d[\"Core/Legend/LegendSymbol.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }();\n\n    b = b.noop;\n    var h = d.series,\n        m = d.seriesTypes,\n        q = m.area,\n        n = m.line,\n        E = m.scatter;\n    m = a.extend;\n    var t = a.merge;\n\n    a = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      f(b, a);\n\n      b.prototype.getGraphPath = function () {\n        for (var a = n.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n\n        return this.areaPath = a;\n      };\n\n      b.prototype.drawGraph = function () {\n        this.options.fillColor = this.color;\n        q.prototype.drawGraph.call(this);\n      };\n\n      b.defaultOptions = t(E.defaultOptions, {\n        marker: {\n          enabled: !1,\n          states: {\n            hover: {\n              enabled: !1\n            }\n          }\n        },\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0,\n          pointFormat: \"\"\n        },\n        trackByArea: !0\n      });\n      return b;\n    }(E);\n\n    m(a.prototype, {\n      type: \"polygon\",\n      drawLegendSymbol: c.drawRectangle,\n      drawTracker: h.prototype.drawTracker,\n      setStackedPoints: b\n    });\n    d.registerSeriesType(\"polygon\", a);\n    \"\";\n    return a;\n  });\n  D(d, \"Core/Axis/WaterfallAxis.js\", [d[\"Core/Axis/Stacking/StackItem.js\"], d[\"Core/Utilities.js\"]], function (b, c) {\n    var d = c.addEvent,\n        a = c.objectEach,\n        f;\n\n    (function (c) {\n      function f() {\n        var a = this.waterfall.stacks;\n        a && (a.changed = !1, delete a.alreadyChanged);\n      }\n\n      function h() {\n        var a = this.options.stackLabels;\n        a && a.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function n() {\n        for (var a = this.axes, b = this.series, c = b.length; c--;) b[c].options.stacking && (a.forEach(function (a) {\n          a.isXAxis || (a.waterfall.stacks.changed = !0);\n        }), c = 0);\n      }\n\n      function y() {\n        this.waterfall || (this.waterfall = new t(this));\n      }\n\n      var t = function () {\n        function c(a) {\n          this.axis = a;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        c.prototype.renderStackTotals = function () {\n          var c = this.axis,\n              d = c.waterfall.stacks,\n              f = c.stacking && c.stacking.stackTotalGroup,\n              h = new b(c, c.options.stackLabels || {}, !1, 0, void 0);\n          this.dummyStackItem = h;\n          f && a(d, function (c) {\n            a(c, function (a, c) {\n              h.total = a.stackTotal;\n              h.x = +c;\n              a.label && (h.label = a.label);\n              b.prototype.render.call(h, f);\n              a.label = h.label;\n              delete h.label;\n            });\n          });\n          h.total = null;\n        };\n\n        return c;\n      }();\n\n      c.Composition = t;\n\n      c.compose = function (a, b) {\n        d(a, \"init\", y);\n        d(a, \"afterBuildStacks\", f);\n        d(a, \"afterRender\", h);\n        d(b, \"beforeRedraw\", n);\n      };\n    })(f || (f = {}));\n\n    return f;\n  });\n  D(d, \"Series/Waterfall/WaterfallPoint.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Utilities.js\"]], function (b, c, d) {\n    var a = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }(),\n        f = d.isNumber;\n\n    return function (b) {\n      function d() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(d, b);\n\n      d.prototype.getClassName = function () {\n        var a = c.prototype.getClassName.call(this);\n        this.isSum ? a += \" highcharts-sum\" : this.isIntermediateSum && (a += \" highcharts-intermediate-sum\");\n        return a;\n      };\n\n      d.prototype.isValid = function () {\n        return f(this.y) || this.isSum || !!this.isIntermediateSum;\n      };\n\n      return d;\n    }(b.prototype.pointClass);\n  });\n  D(d, \"Series/Waterfall/WaterfallSeries.js\", [d[\"Core/Axis/Axis.js\"], d[\"Core/Chart/Chart.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"], d[\"Core/Axis/WaterfallAxis.js\"], d[\"Series/Waterfall/WaterfallPoint.js\"]], function (b, c, d, a, f, y) {\n    var h = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }(),\n        q = d.seriesTypes,\n        n = q.column,\n        D = q.line,\n        t = a.arrayMax,\n        p = a.arrayMin,\n        e = a.correctFloat;\n\n    q = a.extend;\n    var g = a.isNumber,\n        l = a.merge,\n        k = a.objectEach,\n        J = a.pick;\n\n    a = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.stackedYNeg = void 0;\n        b.stackedYPos = void 0;\n        b.stackKey = void 0;\n        b.xData = void 0;\n        b.yAxis = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      h(b, a);\n\n      b.prototype.generatePoints = function () {\n        n.prototype.generatePoints.apply(this);\n\n        for (var a = 0, b = this.points.length; a < b; a++) {\n          var c = this.points[a],\n              d = this.processedYData[a];\n          g(d) && (c.isIntermediateSum || c.isSum) && (c.y = e(d));\n        }\n      };\n\n      b.prototype.translate = function () {\n        var a = this.options,\n            b = this.yAxis,\n            c = J(a.minPointLength, 5),\n            e = c / 2,\n            d = a.threshold || 0;\n        a = a.stacking;\n        var f = b.waterfall.stacks[this.stackKey],\n            h = d,\n            l = d;\n        n.prototype.translate.apply(this);\n\n        for (var k = this.points, r = 0; r < k.length; r++) {\n          var p = k[r];\n          var m = this.processedYData[r];\n          var q = p.shapeArgs;\n\n          if (q && g(m)) {\n            var A = [0, m];\n            var t = p.y;\n\n            if (a) {\n              if (f) {\n                A = f[r];\n\n                if (\"overlap\" === a) {\n                  var y = A.stackState[A.stateIndex--];\n                  y = 0 <= t ? y : y - t;\n                  Object.hasOwnProperty.call(A, \"absolutePos\") && delete A.absolutePos;\n                  Object.hasOwnProperty.call(A, \"absoluteNeg\") && delete A.absoluteNeg;\n                } else 0 <= t ? (y = A.threshold + A.posTotal, A.posTotal -= t) : (y = A.threshold + A.negTotal, A.negTotal -= t, y -= t), !A.posTotal && g(A.absolutePos) && Object.hasOwnProperty.call(A, \"absolutePos\") && (A.posTotal = A.absolutePos, delete A.absolutePos), !A.negTotal && g(A.absoluteNeg) && Object.hasOwnProperty.call(A, \"absoluteNeg\") && (A.negTotal = A.absoluteNeg, delete A.absoluteNeg);\n\n                p.isSum || (A.connectorThreshold = A.threshold + A.stackTotal);\n                b.reversed ? (m = 0 <= t ? y - t : y + t, t = y) : (m = y, t = y - t);\n                p.below = m <= d;\n                q.y = b.translate(m, !1, !0, !1, !0);\n                q.height = Math.abs(q.y - b.translate(t, !1, !0, !1, !0));\n                if (t = b.waterfall.dummyStackItem) t.x = r, t.label = f[r].label, t.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[r], this.stackedYPos[r]);\n              }\n            } else y = Math.max(l, l + t) + A[0], q.y = b.translate(y, !1, !0, !1, !0), p.isSum ? (q.y = b.translate(A[1], !1, !0, !1, !0), q.height = Math.min(b.translate(A[0], !1, !0, !1, !0), b.len) - q.y, p.below = A[1] <= d) : p.isIntermediateSum ? (0 <= t ? (m = A[1] + h, t = h) : (m = h, t = A[1] + h), b.reversed && (m ^= t, t ^= m, m ^= t), q.y = b.translate(m, !1, !0, !1, !0), q.height = Math.abs(q.y - Math.min(b.translate(t, !1, !0, !1, !0), b.len)), h += A[1], p.below = m <= d) : (q.height = 0 < m ? b.translate(l, !1, !0, !1, !0) - q.y : b.translate(l, !1, !0, !1, !0) - b.translate(l - m, !1, !0, !1, !0), l += m, p.below = l < d), 0 > q.height && (q.y += q.height, q.height *= -1);\n\n            p.plotY = q.y = Math.round(q.y || 0) - this.borderWidth % 2 / 2;\n            q.height = Math.max(Math.round(q.height || 0), .001);\n            p.yBottom = q.y + q.height;\n            q.height <= c && !p.isNull ? (q.height = c, q.y -= e, p.plotY = q.y, p.minPointLengthOffset = 0 > p.y ? -e : e) : (p.isNull && (q.width = 0), p.minPointLengthOffset = 0);\n            t = p.plotY + (p.negative ? q.height : 0);\n            p.below && (p.plotY += q.height);\n            p.tooltipPos && (this.chart.inverted ? p.tooltipPos[0] = b.len - t : p.tooltipPos[1] = t);\n            p.isInside = this.isPointInside(p);\n          }\n        }\n      };\n\n      b.prototype.processData = function (b) {\n        var c = this.options,\n            d = this.yData,\n            f = c.data,\n            g = d.length,\n            h = c.threshold || 0,\n            l,\n            k,\n            p,\n            n,\n            m;\n\n        for (m = k = l = p = n = 0; m < g; m++) {\n          var q = d[m];\n          var t = f && f[m] ? f[m] : {};\n          \"sum\" === q || t.isSum ? d[m] = e(k) : \"intermediateSum\" === q || t.isIntermediateSum ? (d[m] = e(l), l = 0) : (k += q, l += q);\n          p = Math.min(k, p);\n          n = Math.max(k, n);\n        }\n\n        a.prototype.processData.call(this, b);\n        c.stacking || (this.dataMin = p + h, this.dataMax = n);\n      };\n\n      b.prototype.toYData = function (a) {\n        return a.isSum ? \"sum\" : a.isIntermediateSum ? \"intermediateSum\" : a.y;\n      };\n\n      b.prototype.updateParallelArrays = function (b, c) {\n        a.prototype.updateParallelArrays.call(this, b, c);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      };\n\n      b.prototype.pointAttribs = function (a, b) {\n        var c = this.options.upColor;\n        c && !a.options.color && (a.color = 0 < a.y ? c : void 0);\n        a = n.prototype.pointAttribs.call(this, a, b);\n        delete a.dashstyle;\n        return a;\n      };\n\n      b.prototype.getGraphPath = function () {\n        return [[\"M\", 0, 0]];\n      };\n\n      b.prototype.getCrispPath = function () {\n        var a = this.data,\n            b = this.yAxis,\n            c = a.length,\n            e = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            d = Math.round(this.borderWidth) % 2 / 2,\n            f = this.xAxis.reversed,\n            g = this.yAxis.reversed,\n            h = this.options.stacking,\n            l = [],\n            k;\n\n        for (k = 1; k < c; k++) {\n          var p = a[k].shapeArgs;\n          var n = a[k - 1];\n          var m = a[k - 1].shapeArgs;\n          var q = b.waterfall.stacks[this.stackKey];\n          var t = 0 < n.y ? -m.height : 0;\n          q && m && p && (q = q[k - 1], h ? (q = q.connectorThreshold, t = Math.round(b.translate(q, !1, !0, !1, !0) + (g ? t : 0)) - e) : t = m.y + n.minPointLengthOffset + d - e, l.push([\"M\", (m.x || 0) + (f ? 0 : m.width || 0), t], [\"L\", (p.x || 0) + (f ? p.width || 0 : 0), t]));\n          m && l.length && (!h && 0 > n.y && !g || 0 < n.y && g) && ((n = l[l.length - 2]) && \"number\" === typeof n[2] && (n[2] += m.height || 0), (n = l[l.length - 1]) && \"number\" === typeof n[2] && (n[2] += m.height || 0));\n        }\n\n        return l;\n      };\n\n      b.prototype.drawGraph = function () {\n        D.prototype.drawGraph.call(this);\n        this.graph && this.graph.attr({\n          d: this.getCrispPath()\n        });\n      };\n\n      b.prototype.setStackedPoints = function () {\n        function a(a, b, c, e) {\n          if (u) {\n            if (R) for (c; c < R; c++) u.stackState[c] += e;else u.stackState[0] = a, R = u.stackState.length;\n            u.stackState.push(u.stackState[R - 1] + b);\n          }\n        }\n\n        var b = this.options,\n            c = this.yAxis.waterfall.stacks,\n            e = b.threshold || 0,\n            d = e,\n            f = d,\n            g = this.stackKey,\n            h = this.xData,\n            l = h.length,\n            k,\n            p,\n            n;\n        this.yAxis.stacking.usePercentage = !1;\n        var m = k = p = d;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var q = c.changed;\n          (n = c.alreadyChanged) && 0 > n.indexOf(g) && (q = !0);\n          c[g] || (c[g] = {});\n          if (n = c[g]) for (var t = 0; t < l; t++) {\n            var y = h[t];\n            if (!n[y] || q) n[y] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: q && n[y] ? n[y].label : void 0\n            };\n            var u = n[y];\n            var C = this.yData[t];\n            0 <= C ? u.posTotal += C : u.negTotal += C;\n            var x = b.data[t];\n            y = u.absolutePos = u.posTotal;\n            var P = u.absoluteNeg = u.negTotal;\n            u.stackTotal = y + P;\n            var R = u.stackState.length;\n            x && x.isIntermediateSum ? (a(p, k, 0, p), p = k, k = e, d ^= f, f ^= d, d ^= f) : x && x.isSum ? (a(e, m, R, 0), d = e) : (a(d, C, 0, m), x && (m += C, k += C));\n            u.stateIndex++;\n            u.threshold = d;\n            d += u.stackTotal;\n          }\n          c.changed = !1;\n          c.alreadyChanged || (c.alreadyChanged = []);\n          c.alreadyChanged.push(g);\n        }\n      };\n\n      b.prototype.getExtremes = function () {\n        var a = this.options.stacking;\n\n        if (a) {\n          var b = this.yAxis;\n          b = b.waterfall.stacks;\n          var c = this.stackedYNeg = [];\n          var e = this.stackedYPos = [];\n          \"overlap\" === a ? k(b[this.stackKey], function (a) {\n            c.push(p(a.stackState));\n            e.push(t(a.stackState));\n          }) : k(b[this.stackKey], function (a) {\n            c.push(a.negTotal + a.threshold);\n            e.push(a.posTotal + a.threshold);\n          });\n          return {\n            dataMin: p(c),\n            dataMax: t(e)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      };\n\n      b.defaultOptions = l(n.defaultOptions, {\n        dataLabels: {\n          inside: !0\n        },\n        lineWidth: 1,\n        lineColor: \"#333333\",\n        dashStyle: \"Dot\",\n        borderColor: \"#333333\",\n        states: {\n          hover: {\n            lineWidthPlus: 0\n          }\n        }\n      });\n      return b;\n    }(n);\n\n    q(a.prototype, {\n      getZonesGraphs: D.prototype.getZonesGraphs,\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: y\n    });\n    d.registerSeriesType(\"waterfall\", a);\n    f.compose(b, c);\n    \"\";\n    return a;\n  });\n  D(d, \"Core/Axis/RadialAxis.js\", [d[\"Core/Axis/AxisDefaults.js\"], d[\"Core/Defaults.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a) {\n    var f = c.defaultOptions,\n        h = d.noop,\n        m = a.addEvent,\n        q = a.correctFloat,\n        n = a.defined,\n        D = a.extend,\n        t = a.fireEvent,\n        p = a.merge,\n        e = a.pick,\n        g = a.relativeLength,\n        l = a.wrap,\n        k;\n\n    (function (a) {\n      function c() {\n        this.autoConnect = this.isCircular && \"undefined\" === typeof e(this.userMax, this.options.max) && q(this.endAngleRad - this.startAngleRad) === q(2 * Math.PI);\n        !this.isCircular && this.chart.inverted && this.max++;\n        this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n\n      function d() {\n        var a = this;\n        return function () {\n          if (a.isRadial && a.tickPositions && a.options.labels && !0 !== a.options.labels.allowOverlap) return a.tickPositions.map(function (b) {\n            return a.ticks[b] && a.ticks[b].label;\n          }).filter(function (a) {\n            return !!a;\n          });\n        };\n      }\n\n      function k() {\n        return h;\n      }\n\n      function v(a, b, c) {\n        var e = this.pane.center,\n            d = a.value;\n\n        if (this.isCircular) {\n          if (n(d)) a.point && (f = a.point.shapeArgs || {}, f.start && (d = this.chart.inverted ? this.translate(a.point.rectPlotY, !0) : a.point.x));else {\n            var f = a.chartX || 0;\n            var g = a.chartY || 0;\n            d = this.translate(Math.atan2(g - c, f - b) - this.startAngleRad, !0);\n          }\n          a = this.getPosition(d);\n          f = a.x;\n          g = a.y;\n        } else n(d) || (f = a.chartX, g = a.chartY), n(f) && n(g) && (c = e[1] + this.chart.plotTop, d = this.translate(Math.min(Math.sqrt(Math.pow(f - b, 2) + Math.pow(g - c, 2)), e[2] / 2) - e[3] / 2, !0));\n\n        return [d, f || 0, g || 0];\n      }\n\n      function y(a, b, c) {\n        a = this.pane.center;\n        var d = this.chart,\n            f = this.left || 0,\n            g = this.top || 0,\n            h = e(b, a[2] / 2 - this.offset);\n        \"undefined\" === typeof c && (c = this.horiz ? 0 : this.center && -this.center[3] / 2);\n        c && (h += c);\n        this.isCircular || \"undefined\" !== typeof b ? (b = this.chart.renderer.symbols.arc(f + a[0], g + a[1], h, h, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        }), b.xBounds = [f + a[0]], b.yBounds = [g + a[1] - h]) : (b = this.postTranslate(this.angleRad, h), b = [[\"M\", this.center[0] + d.plotLeft, this.center[1] + d.plotTop], [\"L\", b.x, b.y]]);\n        return b;\n      }\n\n      function E() {\n        this.constructor.prototype.getOffset.call(this);\n        this.chart.axisOffset[this.side] = 0;\n      }\n\n      function L(a, b, c) {\n        var d = this.chart,\n            f = function (a) {\n          if (\"string\" === typeof a) {\n            var b = parseInt(a, 10);\n            n.test(a) && (b = b * C / 100);\n            return b;\n          }\n\n          return a;\n        },\n            g = this.center,\n            h = this.startAngleRad,\n            C = g[2] / 2,\n            l = Math.min(this.offset, 0),\n            k = this.left || 0,\n            p = this.top || 0,\n            n = /%$/,\n            u = this.isCircular,\n            x = e(f(c.outerRadius), C),\n            m = f(c.innerRadius);\n\n        f = e(f(c.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) l = this.getPlotLinePath({\n          value: a\n        }).concat(this.getPlotLinePath({\n          value: b,\n          reverse: !0\n        }));else {\n          a = Math.max(a, this.min);\n          b = Math.min(b, this.max);\n          a = this.translate(a);\n          b = this.translate(b);\n          u || (x = a || 0, m = b || 0);\n          if (\"circle\" !== c.shape && u) c = h + (a || 0), h += b || 0;else {\n            c = -Math.PI / 2;\n            h = 1.5 * Math.PI;\n            var O = !0;\n          }\n          x -= l;\n          l = d.renderer.symbols.arc(k + g[0], p + g[1], x, x, {\n            start: Math.min(c, h),\n            end: Math.max(c, h),\n            innerR: e(m, x - (f - l)),\n            open: O\n          });\n          u && (u = (h + c) / 2, k = k + g[0] + g[2] / 2 * Math.cos(u), l.xBounds = u > -Math.PI / 2 && u < Math.PI / 2 ? [k, d.plotWidth] : [0, k], l.yBounds = [p + g[1] + g[2] / 2 * Math.sin(u)], l.yBounds[0] += u > -Math.PI && 0 > u || u > Math.PI ? -10 : 10);\n        }\n        return l;\n      }\n\n      function w(a) {\n        var b = this,\n            c = this.pane.center,\n            e = this.chart,\n            d = e.inverted,\n            f = a.reverse,\n            h = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n            C = h.innerRadius || \"0%\",\n            l = h.outerRadius || \"100%\",\n            k = c[0] + e.plotLeft,\n            u = c[1] + e.plotTop,\n            p = this.height,\n            n = a.isCrosshair;\n        h = c[3] / 2;\n        var x = a.value,\n            m;\n        var O = this.getPosition(x);\n        var q = O.x;\n        O = O.y;\n        n && (O = this.getCrosshairPosition(a, k, u), x = O[0], q = O[1], O = O[2]);\n        if (this.isCircular) x = Math.sqrt(Math.pow(q - k, 2) + Math.pow(O - u, 2)), f = \"string\" === typeof C ? g(C, 1) : C / x, e = \"string\" === typeof l ? g(l, 1) : l / x, c && h && (h /= x, f < h && (f = h), e < h && (e = h)), c = [[\"M\", k + f * (q - k), u - f * (u - O)], [\"L\", q - (1 - e) * (q - k), O + (1 - e) * (u - O)]];else if ((x = this.translate(x)) && (0 > x || x > p) && (x = 0), \"circle\" === this.options.gridLineInterpolation) c = this.getLinePath(0, x, h);else if (c = [], e[d ? \"yAxis\" : \"xAxis\"].forEach(function (a) {\n          a.pane === b.pane && (m = a);\n        }), m) for (k = m.tickPositions, m.autoConnect && (k = k.concat([k[0]])), f && (k = k.slice().reverse()), x && (x += h), u = 0; u < k.length; u++) h = m.getPosition(k[u], x), c.push(u ? [\"L\", h.x, h.y] : [\"M\", h.x, h.y]);\n        return c;\n      }\n\n      function B(a, b) {\n        a = this.translate(a);\n        return this.postTranslate(this.isCircular ? a : this.angleRad, e(this.isCircular ? b : 0 > a ? 0 : a, this.center[2] / 2) - this.offset);\n      }\n\n      function z() {\n        var a = this.center,\n            b = this.chart,\n            c = this.options.title;\n        return {\n          x: b.plotLeft + a[0] + (c.x || 0),\n          y: b.plotTop + a[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[c.align] * a[2] + (c.y || 0)\n        };\n      }\n\n      function G(a) {\n        a.beforeSetTickPositions = c;\n        a.createLabelCollector = d;\n        a.getCrosshairPosition = v;\n        a.getLinePath = y;\n        a.getOffset = E;\n        a.getPlotBandPath = L;\n        a.getPlotLinePath = w;\n        a.getPosition = B;\n        a.getTitlePosition = z;\n        a.postTranslate = u;\n        a.setAxisSize = x;\n        a.setAxisTranslation = P;\n        a.setOptions = R;\n      }\n\n      function r() {\n        var a = this.chart,\n            b = this.options,\n            c = this.pane,\n            d = c && c.options;\n        a.angular && this.isXAxis || !c || !a.angular && !a.polar || (a = 2 * Math.PI, c = (e(d.startAngle, 0) - 90) * Math.PI / 180, d = (e(d.endAngle, e(d.startAngle, 0) + 360) - 90) * Math.PI / 180, this.angleRad = (b.angle || 0) * Math.PI / 180, this.startAngleRad = c, this.endAngleRad = d, this.offset = b.offset || 0, b = (c % a + a) % a, d = (d % a + a) % a, b > Math.PI && (b -= a), d > Math.PI && (d -= a), this.normalizedStartAngleRad = b, this.normalizedEndAngleRad = d);\n      }\n\n      function K(a) {\n        this.isRadial && (a.align = void 0, a.preventDefault());\n      }\n\n      function J() {\n        if (this.chart && this.chart.labelCollectors) {\n          var a = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          0 <= a && this.chart.labelCollectors.splice(a, 1);\n        }\n      }\n\n      function U(a) {\n        var c = this.chart,\n            e = c.inverted,\n            d = c.angular,\n            f = c.polar,\n            g = this.isXAxis,\n            l = this.coll,\n            u = d && g;\n        a = a.userOptions.pane || 0;\n        a = this.pane = c.pane && c.pane[a];\n        var x;\n        if (\"colorAxis\" === l) this.isRadial = !1;else {\n          if (d) {\n            if (u ? (this.isHidden = !0, this.createLabelCollector = k, this.getOffset = h, this.render = this.redraw = C, this.setTitle = this.setCategories = this.setScale = h) : G(this), x = !g) this.defaultPolarOptions = Y;\n          } else f && (G(this), this.defaultPolarOptions = (x = this.horiz) ? X : p(\"xAxis\" === l ? b.defaultXAxisOptions : b.defaultYAxisOptions, Z), e && \"yAxis\" === l && (this.defaultPolarOptions.stackLabels = b.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0));\n\n          d || f ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && c.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n          a && x && (a.axis = this);\n          this.isCircular = x;\n        }\n      }\n\n      function A() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n\n      function N(a) {\n        var b = this.label;\n\n        if (b) {\n          var c = this.axis,\n              d = b.getBBox(),\n              f = c.options.labels,\n              h = (c.translate(this.pos) + c.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n              C = Math.round(h),\n              l = n(f.y) ? 0 : .3 * -d.height,\n              k = f.y,\n              u = 20,\n              x = f.align,\n              p = \"end\",\n              m = 0 > C ? C + 360 : C,\n              q = m,\n              P = 0,\n              t = 0;\n\n          if (c.isRadial) {\n            var r = c.getPosition(this.pos, c.center[2] / 2 + g(e(f.distance, -25), c.center[2] / 2, -c.center[2] / 2));\n            \"auto\" === f.rotation ? b.attr({\n              rotation: h\n            }) : n(k) || (k = c.chart.renderer.fontMetrics(b.styles && b.styles.fontSize).b - d.height / 2);\n            n(x) || (c.isCircular ? (d.width > c.len * c.tickInterval / (c.max - c.min) && (u = 0), x = h > u && h < 180 - u ? \"left\" : h > 180 + u && h < 360 - u ? \"right\" : \"center\") : x = \"center\", b.attr({\n              align: x\n            }));\n\n            if (\"auto\" === x && 2 === c.tickPositions.length && c.isCircular) {\n              90 < m && 180 > m ? m = 180 - m : 270 < m && 360 >= m && (m = 540 - m);\n              180 < q && 360 >= q && (q = 360 - q);\n              if (c.pane.options.startAngle === C || c.pane.options.startAngle === C + 360 || c.pane.options.startAngle === C - 360) p = \"start\";\n              x = -90 <= C && 90 >= C || -360 <= C && -270 >= C || 270 <= C && 360 >= C ? \"start\" === p ? \"right\" : \"left\" : \"start\" === p ? \"left\" : \"right\";\n              70 < q && 110 > q && (x = \"center\");\n              15 > m || 180 <= m && 195 > m ? P = .3 * d.height : 15 <= m && 35 >= m ? P = \"start\" === p ? 0 : .75 * d.height : 195 <= m && 215 >= m ? P = \"start\" === p ? .75 * d.height : 0 : 35 < m && 90 >= m ? P = \"start\" === p ? .25 * -d.height : d.height : 215 < m && 270 >= m && (P = \"start\" === p ? d.height : .25 * -d.height);\n              15 > q ? t = \"start\" === p ? .15 * -d.height : .15 * d.height : 165 < q && 180 >= q && (t = \"start\" === p ? .15 * d.height : .15 * -d.height);\n              b.attr({\n                align: x\n              });\n              b.translate(t, P + l);\n            }\n\n            a.pos.x = r.x + (f.x || 0);\n            a.pos.y = r.y + (k || 0);\n          }\n        }\n      }\n\n      function S(a) {\n        this.axis.getPosition && D(a.pos, this.axis.getPosition(this.pos));\n      }\n\n      function u(a, b) {\n        var c = this.chart,\n            e = this.center;\n        a = this.startAngleRad + a;\n        return {\n          x: c.plotLeft + e[0] + Math.cos(a) * b,\n          y: c.plotTop + e[1] + Math.sin(a) * b\n        };\n      }\n\n      function C() {\n        this.isDirty = !1;\n      }\n\n      function x() {\n        this.constructor.prototype.setAxisSize.call(this);\n\n        if (this.isRadial) {\n          this.pane.updateCenter(this);\n          var a = this.center = this.pane.center.slice();\n          if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n            var b = this.postTranslate(this.angleRad, a[3] / 2);\n            a[0] = b.x - this.chart.plotLeft;\n            a[1] = b.y - this.chart.plotTop;\n          }\n          this.len = this.width = this.height = (a[2] - a[3]) * e(this.sector, 1) / 2;\n        }\n      }\n\n      function P() {\n        this.constructor.prototype.setAxisTranslation.call(this);\n        this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n      }\n\n      function R(a) {\n        a = this.options = p(this.constructor.defaultOptions, this.defaultPolarOptions, f[this.coll], a);\n        a.plotBands || (a.plotBands = []);\n        t(this, \"afterSetOptions\");\n      }\n\n      function W(a, b, c, e, d, f, g) {\n        var h = this.axis;\n        h.isRadial ? (a = h.getPosition(this.pos, h.center[2] / 2 + e), b = [\"M\", b, c, \"L\", a.x, a.y]) : b = a.call(this, b, c, e, d, f, g);\n        return b;\n      }\n\n      var T = [],\n          X = {\n        gridLineWidth: 1,\n        labels: {\n          align: void 0,\n          distance: 15,\n          x: 0,\n          y: void 0,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      },\n          Y = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: void 0\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      },\n          Z = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n\n      a.compose = function (a, b) {\n        -1 === T.indexOf(a) && (T.push(a), m(a, \"afterInit\", r), m(a, \"autoLabelAlign\", K), m(a, \"destroy\", J), m(a, \"init\", U), m(a, \"initialAxisTranslation\", A));\n        -1 === T.indexOf(b) && (T.push(b), m(b, \"afterGetLabelPosition\", N), m(b, \"afterGetPosition\", S), l(b.prototype, \"getMarkPath\", W));\n        return a;\n      };\n    })(k || (k = {}));\n\n    return k;\n  });\n  D(d, \"Series/PolarComposition.js\", [d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Globals.js\"], d[\"Extensions/Pane.js\"], d[\"Core/Axis/RadialAxis.js\"], d[\"Core/Utilities.js\"]], function (b, c, d, a, f) {\n    function h(a, b, c, e) {\n      var d = e ? 1 : 0;\n      var f = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > f - 1 ? a.length - (1 + d) : f - 1;\n      var g = a[b];\n      d = a[f + 1 > a.length - 1 ? d : f + 1];\n      var C = g.plotY;\n      var l = d.plotX;\n      var k = d.plotY;\n      d = a[f].plotX;\n      f = a[f].plotY;\n      g = (1.5 * d + g.plotX) / 2.5;\n      C = (1.5 * f + C) / 2.5;\n      l = (1.5 * d + l) / 2.5;\n      var x = (1.5 * f + k) / 2.5;\n      k = Math.sqrt(Math.pow(g - d, 2) + Math.pow(C - f, 2));\n      var u = Math.sqrt(Math.pow(l - d, 2) + Math.pow(x - f, 2));\n      g = Math.atan2(C - f, g - d);\n      x = Math.PI / 2 + (g + Math.atan2(x - f, l - d)) / 2;\n      Math.abs(g - x) > Math.PI / 2 && (x -= Math.PI);\n      g = d + Math.cos(x) * k;\n      C = f + Math.sin(x) * k;\n      l = d + Math.cos(Math.PI + x) * u;\n      x = f + Math.sin(Math.PI + x) * u;\n      d = {\n        rightContX: l,\n        rightContY: x,\n        leftContX: g,\n        leftContY: C,\n        plotX: d,\n        plotY: f\n      };\n      c && (d.prevPointCont = h(a, b, !1, e));\n      return d;\n    }\n\n    function m() {\n      (this.pane || []).forEach(function (a) {\n        a.render();\n      });\n    }\n\n    function q(a) {\n      var b = a.args[0].xAxis,\n          c = a.args[0].yAxis;\n      a = a.args[0].chart;\n      b && c && (\"polygon\" === c.gridLineInterpolation ? (b.startOnTick = !0, b.endOnTick = !0) : \"polygon\" === b.gridLineInterpolation && a.inverted && (c.startOnTick = !0, c.endOnTick = !0));\n    }\n\n    function n() {\n      var a = this;\n      this.pane || (this.pane = []);\n      this.options.pane = V(this.options.pane);\n      this.options.pane.forEach(function (b) {\n        new d(b, a);\n      }, this);\n    }\n\n    function D(a) {\n      var b = a.args.marker,\n          c = this.chart.xAxis[0],\n          d = this.chart.yAxis[0],\n          e = this.chart.inverted,\n          f = e ? d : c;\n      c = e ? c : d;\n\n      if (this.chart.polar) {\n        a.preventDefault();\n        d = (b.attr ? b.attr(\"start\") : b.start) - f.startAngleRad;\n        e = b.attr ? b.attr(\"r\") : b.r;\n        var g = (b.attr ? b.attr(\"end\") : b.end) - f.startAngleRad;\n        b = b.attr ? b.attr(\"innerR\") : b.innerR;\n        a.result.x = d + f.pos;\n        a.result.width = g - d;\n        a.result.y = c.len + c.pos - b;\n        a.result.height = b - e;\n      }\n    }\n\n    function t(a) {\n      var b = this.chart;\n\n      if (b.polar && b.hoverPane && b.hoverPane.axis) {\n        a.preventDefault();\n        var c = b.hoverPane.center,\n            d = this.mouseDownX || 0,\n            e = this.mouseDownY || 0,\n            f = a.args.chartY,\n            g = a.args.chartX,\n            h = 2 * Math.PI,\n            k = b.hoverPane.axis.startAngleRad,\n            p = b.hoverPane.axis.endAngleRad,\n            m = b.inverted ? b.xAxis[0] : b.yAxis[0],\n            n = {},\n            u = \"arc\";\n        n.x = c[0] + b.plotLeft;\n        n.y = c[1] + b.plotTop;\n\n        if (this.zoomHor) {\n          var q = 0 < k ? p - k : Math.abs(k) + Math.abs(p),\n              t = Math.atan2(e - b.plotTop - c[1], d - b.plotLeft - c[0]) - k,\n              r = Math.atan2(f - b.plotTop - c[1], g - b.plotLeft - c[0]) - k;\n          n.r = c[2] / 2;\n          n.innerR = c[3] / 2;\n          0 >= t && (t += h);\n          0 >= r && (r += h);\n          r < t && (r = [t, t = r][0]);\n          q < h && k + r > p + (h - q) / 2 && (r = t, t = 0 >= k ? k : 0);\n          h = n.start = Math.max(t + k, k);\n          t = n.end = Math.min(r + k, p);\n          \"polygon\" === m.options.gridLineInterpolation && (r = b.hoverPane.axis, q = h - r.startAngleRad + r.pos, t -= h, u = m.getPlotLinePath({\n            value: m.max\n          }), h = r.toValue(q), q = r.toValue(q + t), h < r.getExtremes().min && (t = r.getExtremes(), h = t.max - (t.min - h)), q < r.getExtremes().min && (t = r.getExtremes(), q = t.max - (t.min - q)), q < h && (q = [h, h = q][0]), u = l(u, h, q, r), u.push([\"L\", c[0] + b.plotLeft, b.plotTop + c[1]]), n.d = u, u = \"path\");\n        }\n\n        this.zoomVert && (r = b.inverted ? b.xAxis[0] : b.yAxis[0], d = Math.sqrt(Math.pow(d - b.plotLeft - c[0], 2) + Math.pow(e - b.plotTop - c[1], 2)), f = Math.sqrt(Math.pow(g - b.plotLeft - c[0], 2) + Math.pow(f - b.plotTop - c[1], 2)), f < d && (d = [f, f = d][0]), f > c[2] / 2 && (f = c[2] / 2), d < c[3] / 2 && (d = c[3] / 2), this.zoomHor || (n.start = k, n.end = p), n.r = f, n.innerR = d, \"polygon\" === r.options.gridLineInterpolation && (t = r.toValue(r.len + r.pos - d), h = r.toValue(r.len + r.pos - f), u = r.getPlotLinePath({\n          value: h\n        }).concat(r.getPlotLinePath({\n          value: t,\n          reverse: !0\n        })), n.d = u, u = \"path\"));\n        this.zoomHor && this.zoomVert && \"polygon\" === m.options.gridLineInterpolation && (r = b.hoverPane.axis, h = n.start || 0, t = n.end || 0, q = h - r.startAngleRad + r.pos, t -= h, h = r.toValue(q), q = r.toValue(q + t), n.d instanceof Array && (c = n.d.slice(0, n.d.length / 2), k = n.d.slice(n.d.length / 2, n.d.length), k = L([], k, !0).reverse(), b = b.hoverPane.axis, c = l(c, h, q, b), (k = l(k, h, q, b)) && (k[0][0] = \"L\"), k = L([], k, !0).reverse(), n.d = c.concat(k), u = \"path\"));\n        a.attrs = n;\n        a.shapeType = u;\n      }\n    }\n\n    function p() {\n      var a = this.chart;\n      a.polar && (this.polar = new S(this), a.inverted && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0)));\n    }\n\n    function e() {\n      if (this.chart.polar && this.xAxis) {\n        var a = this.chart;\n        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = g : this.options.findNearestPointBy = \"xy\";\n\n        for (var b = this.points, d = b.length; d--;) this.preventPostTranslate || this.polar.toXY(b[d]), a.hasParallelCoordinates || this.yAxis.reversed || (K(b[d].y, Number.MIN_VALUE) < this.yAxis.min || b[d].x < this.xAxis.min || b[d].x > this.xAxis.max ? (b[d].isNull = !0, b[d].plotY = NaN) : b[d].isNull = b[d].isValid && !b[d].isValid());\n\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(B(this, \"afterRender\", function () {\n          if (a.polar) {\n            var b = this.yAxis.pane.center;\n            if (this.clipCircle) this.clipCircle.animate({\n              x: b[0],\n              y: b[1],\n              r: b[2] / 2,\n              innerR: b[3] / 2\n            });else {\n              var d = a.renderer,\n                  e = b[0],\n                  f = b[1],\n                  g = b[2] / 2,\n                  h = b[3] / 2;\n              b = U();\n              var k = d.createElement(\"clipPath\").attr({\n                id: b\n              }).add(d.defs);\n              d = h ? d.arc(e, f, g, h, 0, 2 * Math.PI).add(k) : d.circle(e, f, g).add(k);\n              d.id = b;\n              d.clipPath = k;\n              this.clipCircle = d;\n            }\n            this.group.clip(this.clipCircle);\n            this.setClip = c.noop;\n          }\n        })));\n      }\n    }\n\n    function g(a) {\n      var b = this.chart,\n          c = this.xAxis;\n      c = c.pane && c.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - (c && c[0] || 0) - b.plotLeft, a.chartY - (c && c[1] || 0) - b.plotTop)\n      });\n    }\n\n    function l(a, b, c, d) {\n      var e = d.tickInterval;\n      d = d.tickPositions;\n      var f = G(d, function (a) {\n        return a >= c;\n      }),\n          g = G(L([], d, !0).reverse(), function (a) {\n        return a <= b;\n      });\n      z(f) || (f = d[d.length - 1]);\n      z(g) || (g = d[0], f += e, a[0][0] = \"L\", a.unshift(a[a.length - 3]));\n      a = a.slice(d.indexOf(g), d.indexOf(f) + 1);\n      a[0][0] = \"M\";\n      return a;\n    }\n\n    function k(a, b) {\n      return G(this.pane || [], function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    }\n\n    function J(a, b, c, d, e, f) {\n      var g = this.chart,\n          h = K(d.inside, !!this.options.stacking);\n      g.polar ? (a = b.rectPlotX / Math.PI * 180, g.inverted ? (this.forceDL = g.isInsidePlot(b.plotX, b.plotY), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate(((e.start || 0) + (e.end || 0)) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {\n        x: e.x - g.plotLeft,\n        y: e.y - g.plotTop\n      }) : b.tooltipPos && (e = {\n        x: b.tooltipPos[0],\n        y: b.tooltipPos[1]\n      }), d.align = K(d.align, \"center\"), d.verticalAlign = K(d.verticalAlign, \"middle\")) : (null === d.align && (d.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\"), null === d.verticalAlign && (d.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\")), Object.getPrototypeOf(Object.getPrototypeOf(this)).alignDataLabel.call(this, b, c, d, e, f), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end ? c.hide() : c.show()) : a.call(this, b, c, d, e, f);\n    }\n\n    function H(a) {\n      var b = this.options,\n          c = b.stacking,\n          d = this.chart,\n          e = this.xAxis,\n          g = this.yAxis,\n          h = g.reversed,\n          k = g.center,\n          l = e.startAngleRad,\n          n = e.endAngleRad - l,\n          p = 0,\n          m = 0,\n          q = 0;\n      this.preventPostTranslate = !0;\n      a.call(this);\n\n      if (e.isRadial) {\n        a = this.points;\n        e = a.length;\n        var t = g.translate(g.min);\n        var u = g.translate(g.max);\n        b = b.threshold || 0;\n        d.inverted && r(b) && (p = g.translate(b), z(p) && (0 > p ? p = 0 : p > n && (p = n), this.translatedThreshold = p + l));\n\n        for (; e--;) {\n          b = a[e];\n          var v = b.barX;\n          var y = b.x;\n          var w = b.y;\n          b.shapeType = \"arc\";\n\n          if (d.inverted) {\n            b.plotY = g.translate(w);\n            c && g.stacking ? (w = g.stacking.stacks[(0 > w ? \"-\" : \"\") + this.stackKey], this.visible && w && w[y] && !b.isNull && (q = w[y].points[this.getStackIndicator(void 0, y, this.index).key], m = g.translate(q[0]), q = g.translate(q[1]), z(m) && (m = f.clamp(m, 0, n)))) : (m = p, q = b.plotY);\n            m > q && (q = [m, m = q][0]);\n            if (!h) {\n              if (m < t) m = t;else if (q > u) q = u;else {\n                if (q < t || m > u) m = q = 0;\n              }\n            } else if (q > t) q = t;else if (m < u) m = u;else if (m > t || q < u) m = q = n;\n            g.min > g.max && (m = q = h ? n : 0);\n            m += l;\n            q += l;\n            k && (b.barX = v += k[3] / 2);\n            y = Math.max(v, 0);\n            w = Math.max(v + b.pointWidth, 0);\n            b.shapeArgs = {\n              x: k && k[0],\n              y: k && k[1],\n              r: w,\n              innerR: y,\n              start: m,\n              end: q\n            };\n            b.opacity = m === q ? 0 : void 0;\n            b.plotY = (z(this.translatedThreshold) && (m < this.translatedThreshold ? m : q)) - l;\n          } else m = v + l, b.shapeArgs = this.polar.arc(b.yBottom, b.plotY, m, m + b.pointWidth);\n\n          this.polar.toXY(b);\n          d.inverted ? (v = g.postTranslate(b.rectPlotY, v + b.pointWidth / 2), b.tooltipPos = [v.x - d.plotLeft, v.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n          k && (b.ttBelow = b.plotY > k[1]);\n        }\n      }\n    }\n\n    function M(a, b) {\n      var c = this;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (var d = 0; d < b.length; d++) if (!b[d].isNull) {\n          var e = d;\n          break;\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var f = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.polar.toXY(a);\n        });\n      }\n\n      e = a.apply(this, [].slice.call(arguments, 1));\n      f && b.pop();\n      return e;\n    }\n\n    function F(a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        if (\"colorAxis\" !== a.coll) {\n          var e = a.isXAxis,\n              f = a.center,\n              g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    }\n\n    function v(a, b) {\n      this.chart.polar || a.call(this, b);\n    }\n\n    function Q(a, b) {\n      var d = this,\n          e = this.chart,\n          f = this.group,\n          g = this.markerGroup,\n          h = this.xAxis && this.xAxis.center,\n          k = e.plotLeft,\n          l = e.plotTop,\n          m = this.options.animation,\n          p,\n          n,\n          q,\n          t;\n      if (e.polar) {\n        if (d.isRadialBar) b || (d.startAngleRad = K(d.translatedThreshold, d.xAxis.startAngleRad), c.seriesTypes.pie.prototype.animate.call(d, b));else {\n          if (e.renderer.isSVG) if (m = w(m), d.is(\"column\")) {\n            if (!b) {\n              var r = h[3] / 2;\n              d.points.forEach(function (a) {\n                p = a.graphic;\n                q = (n = a.shapeArgs) && n.r;\n                t = n && n.innerR;\n                p && n && (p.attr({\n                  r: r,\n                  innerR: r\n                }), p.animate({\n                  r: q,\n                  innerR: t\n                }, d.options.animation));\n              });\n            }\n          } else b ? (a = {\n            translateX: h[0] + k,\n            translateY: h[1] + l,\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(a), g && g.attr(a)) : (a = {\n            translateX: k,\n            translateY: l,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(a, m), g && g.animate(a, m));\n        }\n      } else a.call(this, b);\n    }\n\n    function I(a, b, c, d) {\n      this.chart.polar ? d ? (a = h(b, d, !0, this.connectEnds), b = a.prevPointCont && a.prevPointCont.rightContX, c = a.prevPointCont && a.prevPointCont.rightContY, a = [\"C\", r(b) ? b : a.plotX, r(c) ? c : a.plotY, r(a.leftContX) ? a.leftContX : a.plotX, r(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, d);\n      return a;\n    }\n\n    var L = this && this.__spreadArray || function (a, b, c) {\n      if (c || 2 === arguments.length) for (var d = 0, e = b.length, f; d < e; d++) !f && d in b || (f || (f = Array.prototype.slice.call(b, 0, d)), f[d] = b[d]);\n      return a.concat(f || Array.prototype.slice.call(b));\n    },\n        w = b.animObject,\n        B = f.addEvent,\n        z = f.defined,\n        G = f.find,\n        r = f.isNumber,\n        K = f.pick,\n        V = f.splat,\n        U = f.uniqueKey,\n        A = f.wrap,\n        N = [],\n        S = function () {\n      function b(a) {\n        this.series = a;\n      }\n\n      b.compose = function (b, c, d, f, g, h, l, r, u) {\n        a.compose(b, g);\n        -1 === N.indexOf(c) && (N.push(c), B(c, \"afterDrawChartBox\", m), B(c, \"getAxes\", n), B(c, \"init\", q), A(c.prototype, \"get\", k));\n        -1 === N.indexOf(d) && (N.push(d), b = d.prototype, A(b, \"getCoordinates\", F), A(b, \"pinch\", v), B(d, \"getSelectionMarkerAttrs\", t), B(d, \"getSelectionBox\", D));\n        -1 === N.indexOf(f) && (N.push(f), B(f, \"afterInit\", p), B(f, \"afterTranslate\", e, {\n          order: 2\n        }), A(f.prototype, \"animate\", Q));\n        l && -1 === N.indexOf(l) && (N.push(l), d = l.prototype, A(d, \"alignDataLabel\", J), A(d, \"animate\", Q), A(d, \"translate\", H));\n        r && -1 === N.indexOf(r) && (N.push(r), A(r.prototype, \"getGraphPath\", M));\n        u && -1 === N.indexOf(u) && (N.push(u), r = u.prototype, A(r, \"getPointSpline\", I), h && -1 === N.indexOf(h) && (N.push(h), h.prototype.getPointSpline = r.getPointSpline));\n      };\n\n      b.prototype.arc = function (a, b, c, d) {\n        var e = this.series,\n            f = e.xAxis.center,\n            g = e.yAxis.len,\n            h = f[3] / 2;\n        b = g - b + h;\n        a = g - K(a, g) + h;\n        e.yAxis.reversed && (0 > b && (b = h), 0 > a && (a = h));\n        return {\n          x: f[0],\n          y: f[1],\n          r: b,\n          innerR: a,\n          start: c,\n          end: d\n        };\n      };\n\n      b.prototype.toXY = function (a) {\n        var b = this.series,\n            c = b.chart,\n            d = b.xAxis,\n            e = b.yAxis,\n            f = a.plotX,\n            g = c.inverted,\n            h = a.y,\n            k = a.plotY,\n            l = g ? f : e.len - k;\n        g && b && !b.isRadialBar && (a.plotY = k = r(h) ? e.translate(h) : 0);\n        a.rectPlotX = f;\n        a.rectPlotY = k;\n        e.center && (l += e.center[3] / 2);\n        r(k) && (e = g ? e.postTranslate(k, l) : d.postTranslate(f, l), a.plotX = a.polarPlotX = e.x - c.plotLeft, a.plotY = a.polarPlotY = e.y - c.plotTop);\n        b.kdByAngle ? (b = (f / Math.PI * 180 + d.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n      };\n\n      return b;\n    }();\n\n    return S;\n  });\n  D(d, \"masters/highcharts-more.src.js\", [d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Series/Bubble/BubbleSeries.js\"], d[\"Series/PackedBubble/PackedBubbleSeries.js\"], d[\"Series/PolarComposition.js\"]], function (b, c, d, a, f) {\n    d.compose(b.Axis, b.Chart, b.Legend, b.Series);\n    a.compose(b.Axis, b.Chart, b.Legend, b.Series);\n    f.compose(b.Axis, b.Chart, b.Pointer, b.Series, b.Tick, c.seriesTypes.areasplinerange, c.seriesTypes.column, c.seriesTypes.line, c.seriesTypes.spline);\n  });\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script"}