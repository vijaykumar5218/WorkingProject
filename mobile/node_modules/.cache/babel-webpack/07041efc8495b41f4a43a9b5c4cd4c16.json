{"ast":null,"code":"define(['./AccountAccum', './IRSConstants', './AccumCommon', './AccountTypes', './LimitUtilities', './util/DoubleScratchPad', './util/CalcUtilities', './MinMaxLimit', './ErrorUtilities', './AccumCensus', './ReplacementIncome'], function (AccountAccum, IRSConstants, AccumCommon, AccountTypes, LimitUtilities, DoubleScratchPad, CalcUtilities, MinMaxLimit, ErrorUtilities, AccumCensus, ReplacementIncome) {\n  //  Constructor  ------------------------------------\n  var BaseAccumulator = function () {\n    //  Private var declarations ------------------------------------\n    var _accountList = null;\n    var _accumCommon = null; // of type 'AccumCommon'\n\n    var _censusList = null;\n\n    var _holder = DoubleScratchPad.newInstance();\n\n    var _aggregateFrequency = 1; //  Privileged Method Declarations ------------------------------------\n\n    this.init = function (ac, al) {\n      _accountList = al;\n      _accumCommon = ac;\n      reset();\n    };\n\n    this.getCensusList = function () {\n      return _censusList;\n    };\n\n    this.getAccountAccumList = function () {\n      return _accountList;\n    }; //  Private Method Declarations ------------------------------------\n\n\n    function reset() {\n      // aggregate frequency starting point (at least > 0)\n      _aggregateFrequency = 1; // _accumCommon.getFrequency() ;\n      // empty-out census list\n\n      _censusList = []; // prepare for sort\n\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i]; // algorithm for setting primacy: evaluate accounts/money sources and figure out which are least susceptible to\n        // limit or change (setPriority() prep for sort)\n        // TODO:  make this more sophisticated\n\n        aa.setPriority(aa.getPlanIndex() + aa.getType() * 10);\n      } // sort to put in descending order of primacy\n\n\n      _accountList.sort(function (a, b) {\n        if (a.getPriority() > b.getPriority()) {\n          return 1;\n        } else if (a.getPriority() < b.getPriority()) {\n          return -1;\n        } else {\n          return 0;\n        }\n      }); // set one-time, start-up configurations\n\n\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i]; // set/reset aggregate frequency with each account\n\n        _aggregateFrequency = CalcUtilities.getAggregateModes(_aggregateFrequency, aa.getModes()); // assuming a single rate of return for all money sources, establish rate for each account.\n\n        aa.setRateOfReturn(_accumCommon.getRateOfReturn());\n\n        switch (aa.getType()) {\n          case AccountTypes.TYPE_NOGROWTH:\n            //case AccountTypes.TYPE_PENSION_LUMP_SUM :  // this looks like it was included in error: not in Java version\n            aa.setRateOfReturn(0.0);\n            break;\n\n          default:\n            break;\n        } // consistent rate of increase for all contribs.\n\n\n        aa.setRateOfIncrease(_accumCommon.getRateOfIncrease()); // NB For these, only the contribution dollar AMOUNTs (AccountTypes.CONTRIB_ANNUAL and AccountTypes.CONTRIB_MODAL)\n        // will be constrained to NO rate of increase (0%); contribution RATEs (AccountTypes.CONTRIB_RATE),\n        // however, will be governed by the salary reference, which increases with the rate of increase.\n\n        switch (aa.getType()) {\n          case AccountTypes.TYPE_MANDATORY_EE: // see NB above\n\n          case AccountTypes.TYPE_MANDATORY_ER:\n          case AccountTypes.TYPE_RECURRING_ER:\n          case AccountTypes.TYPE_NOINCREASE:\n          case AccountTypes.TYPE_NOGROWTH:\n          case AccountTypes.TYPE_PENSION_LUMP_SUM:\n          case AccountTypes.TYPE_EXISTINGLOAN:\n          case AccountTypes.TYPE_NEWLOAN:\n            aa.setRateOfIncrease(0.0);\n            break;\n\n          default:\n            break;\n        } // set withholding rate for each account (this is for build-up in taxable accounts and for reference in tax-deferred accounts)\n\n\n        aa.setRateOfWithholding(_accumCommon.getRateOfWithholding()); // set immediate for recurring employer contrib\n\n        if (AccountTypes.TYPE_RECURRING_ER == aa.getType()) {\n          aa.setImmediateOrDue(true);\n        }\n      }\n    }\n\n    this.align = function () {\n      // for (AccountAccum aa : _accountList) {\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i]; // reset account objects (zero-out principle, earnings for all buckets)\n\n        aa.reset();\n      } // through years\n\n\n      for (var n = 0; n < _accumCommon.getFull(); n++) {\n        // (1) get salary according to increase rate and apply compensation limit\n        var annualSalaryRef = _accumCommon.getAnnualSalary() * Math.pow(1.0 + _accumCommon.getRateOfIncrease(), n);\n        var annualSalary401a17Ref = Math.min(annualSalaryRef, IRSConstants.getLimit(IRSConstants._401a17)); // (2) establish contribs\n        //resolveSalaryTo401a17Limits( accountList, annualSalaryRef, annualSalary401a17Ref ) ;\n\n        for (var i = 0; i < _accountList.length; i++) {\n          var aa = _accountList[i]; // apply right annual salary ref\n\n          aa.setIterationEeAnnualSalary(LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), true) ? annualSalary401a17Ref : annualSalaryRef);\n          aa.setIterationErAnnualSalary(LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), false) ? annualSalary401a17Ref : annualSalaryRef); // set ee contrib\n\n          aa.setIterationEeContribAmount(n);\n        } // (3) enforce money source non-IRS limits\n\n\n        BaseAccumulator.resolveContribsToNonIRSLimits(_accountList); // (4) enforce global non-IRS limits\n\n        var mmlimits = _accumCommon.getMinMaxLimitList();\n\n        for (var i = 0; i < mmlimits.length; i++) {\n          var mml = mmlimits[i];\n\n          if (mml.getMinValue() > 0 || mml.getMaxValue() > 0) {\n            BaseAccumulator.resolveContribsToGlobalNonIRSLimit(mml, _accountList, annualSalary401a17Ref);\n          }\n        } // (5) enforce to IRS 402g1, 457e15, 414v, and 415c1A limits - \"single\" or idividual pass\n\n\n        BaseAccumulator.resolveContribsToIRSLimits(_accountList); // (6) enforce collaboratively to IRS 402g1, 457e15, and 414v limits\n\n        BaseAccumulator.resolveContribsTo_402g1_457e15_414vLimits(_accountList); // (7) establish er match contrib\n\n        _holder.zero();\n\n        for (var i = 0; i < _accountList.length; i++) {\n          var aa = _accountList[i];\n\n          if (aa.isEmployerMatch()) {\n            aa.setIterationErContribAmount(_holder.get(aa.getEmployerMatchId()));\n\n            _holder.touch(aa.getEmployerMatchId(), aa.getIterationEeContribAmount() * aa.getModes());\n          }\n        } // (8) enforce 415c1A limits\n\n\n        BaseAccumulator.resolveContribsTo_415c1ALimits(_accountList); // (9) enforce salary as limit\n\n        BaseAccumulator.resolveContribsToSalaryAsLimit(_accountList, annualSalaryRef); // (10) ?? if n==0 do fractional years at beginning\n        // (11) accum the year via aggregate frequency\n\n        var translatedMode = -1;\n\n        for (var nn = 0; nn < _aggregateFrequency; nn++) {\n          _holder.zero();\n\n          for (var i = 0; i < _accountList.length; i++) {\n            var aa = _accountList[i]; // only if an active mode\n\n            translatedMode = CalcUtilities.translateMode(_aggregateFrequency, aa.getModes(), nn);\n\n            if (translatedMode > -1) {\n              var alreadyMatchedContribs = 0.0;\n\n              if (aa.isEmployerMatch() && aa.isEmployerMatchPeriodicityModal()) {\n                alreadyMatchedContribs = _holder.get(aa.getEmployerMatchId());\n\n                _holder.touch(aa.getEmployerMatchId(), aa.getIterationEeContribAmount() * aa.getModes());\n              }\n\n              aa.align(translatedMode, alreadyMatchedContribs);\n            }\n          }\n        } // (12) ?? n < _accumCommon.getFull() do fractional years at end\n        // (13) census capture\n\n\n        if (n == 0 || n == _accumCommon.getFull() - 1) {\n          // first or last year\n          var ac = new AccumCensus();\n          ac.setPeriodRef(n);\n          ac.setSalary(annualSalaryRef);\n          ac.setSalary401a17(annualSalary401a17Ref);\n          ac.setEEContribs(BaseAccumulator.getAnnualEEContribs(_accountList, ReplacementIncome.LifeStyleTypes));\n\n          _censusList.push(ac);\n        }\n      }\n    };\n\n    this.validate = function () {\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i]; // reset account objects (zero-out principle, earnings for all buckets)\n\n        aa.reset();\n      } // (1) get salary according to increase rate and apply compensation limit\n\n\n      var annualSalaryRef = _accumCommon.getAnnualSalary() * Math.pow(1.0 + _accumCommon.getRateOfIncrease(), 0);\n      var annualSalary401a17Ref = Math.min(annualSalaryRef, IRSConstants.getLimit(IRSConstants._401a17)); // (2) establish contribs\n      //resolveSalaryTo401a17Limits( accountList, annualSalaryRef, annualSalary401a17Ref ) ;\n\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i]; // apply right annual salary ref\n\n        aa.setIterationEeAnnualSalary(LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), true) ? annualSalary401a17Ref : annualSalaryRef);\n        aa.setIterationErAnnualSalary(LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), false) ? annualSalary401a17Ref : annualSalaryRef); // set ee contrib\n\n        aa.setIterationEeContribAmount(0);\n      } // (3) enforce money source non-IRS limits\n\n\n      BaseAccumulator.resolveContribsToNonIRSLimits(_accountList); // (4) enforce global non-IRS limits\n\n      var mmlimits = _accumCommon.getMinMaxLimitList();\n\n      for (var i = 0; i < mmlimits.length; i++) {\n        var mml = mmlimits[i];\n\n        if (mml.getMinValue() > 0 || mml.getMaxValue() > 0) {\n          BaseAccumulator.resolveContribsToGlobalNonIRSLimit(mml, _accountList, annualSalary401a17Ref);\n        }\n      } // (5) enforce to IRS 402g1, 457e15, 414v, and 415c1A limits - \"single\" or individual pass\n\n\n      BaseAccumulator.resolveContribsToIRSLimits(_accountList); // (6) enforce collaboratively to IRS 402g1, 457e15, and 414v limits\n\n      BaseAccumulator.resolveContribsTo_402g1_457e15_414vLimits(_accountList); // (7) establish er match contrib\n\n      _holder.zero();\n\n      for (var i = 0; i < _accountList.length; i++) {\n        var aa = _accountList[i];\n\n        if (aa.isEmployerMatch()) {\n          aa.setIterationErContribAmount(_holder.get(aa.getEmployerMatchId()));\n\n          _holder.touch(aa.getEmployerMatchId(), aa.getIterationEeContribAmount() * aa.getModes());\n        }\n      } // (8) enforce 415c1A limits\n\n\n      BaseAccumulator.resolveContribsTo_415c1ALimits(_accountList); // (9) enforce salary as limit\n\n      BaseAccumulator.resolveContribsToSalaryAsLimit(_accountList, annualSalaryRef);\n    };\n  }; //  Static Method Declarations ------------------------------------\n\n\n  BaseAccumulator.resolveContribsTo_402g1_457e15_414vLimits = function (accountList) {\n    var index = -1;\n    var limits = [IRSConstants.getLimit(IRSConstants._402g1), IRSConstants.getLimit(IRSConstants._457e15), IRSConstants.getLimit(IRSConstants._414v), IRSConstants.getLimit(IRSConstants._414v), 0, 0]; //\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = -1;\n      index = LimitUtilities.getIndexForGrouped_402g1_457e15_414_vLimits(aa.getType(), aa.getIRC());\n\n      if (index > -1) {\n        if (aa.getIterationEeContribAmount() * aa.getModes() > limits[index]) {\n          aa.adjustEeIterationContribAmount(limits[index] / aa.getModes());\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            aa.setIrsInfraction(true);\n            aa.touchErrorString(ErrorUtilities.createErrorStringForMultipleAccountIRSInfraction(aa, accountList));\n          }\n\n          limits[index] = 0.0;\n        } else {\n          limits[index] = limits[index] - aa.getIterationEeContribAmount() * aa.getModes();\n        }\n      }\n    }\n  };\n\n  BaseAccumulator.resolveContribsTo_415c1ALimits = function (accountList) {\n    var limits = [0, 0, 0, 0, IRSConstants.getLimit(IRSConstants._415c1A), IRSConstants.getLimit(IRSConstants._415c1A)];\n    var index = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = -1;\n      index = LimitUtilities.getIndexForGrouped_415c1A_Limit(aa.getType(), aa.getIRC());\n\n      if (index > -1) {\n        var annualEe = aa.getIterationEeContribAmount() * aa.getModes();\n        var annualEr = aa.getIterationErContribAmount() * aa.getModes();\n\n        if (annualEe + annualEr > limits[index]) {\n          if (annualEr > 0.0) {\n            BaseAccumulator.resolveEEaccordingToER(accountList, aa.getIndex(), limits[index] / aa.getModes()); // 140513 JSS  in\n            // 140513 JSS out                        var contribs = LimitUtilities.resolveEEandERcontribs( annualEe, annualEr, limits[index] ) ;\n            // 140513 JSS out                        aa.adjustEeIterationContribAmount( contribs[0] / aa.getModes() ) ;\n            // 140513 JSS out                        aa.adjustErIterationContribAmount( contribs[1] / aa.getModes() ) ;\n          } else {\n            aa.adjustEeIterationContribAmount(limits[index] / aa.getModes());\n          }\n\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            aa.setIrsInfraction(true);\n            aa.touchErrorString(ErrorUtilities.createErrorStringFor415IRSInfraction(limits[index], aa, accountList));\n          }\n\n          limits[index] = 0.0;\n        } else {\n          limits[index] = limits[index] - (aa.getIterationEeContribAmount() + aa.getIterationErContribAmount()) * aa.getModes();\n        }\n      }\n    }\n  };\n\n  BaseAccumulator.resolveContribsToNonIRSLimits = function (accountList) {\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n\n      if (aa.isMinMaxLimit()) {\n        var max = aa.getMinMaxLimit().getEvaldMax(aa.getFrequency(), aa.getIterationEeAnnualSalary()); // 140507 JSS out                var min = aa.getMinMaxLimit().getEvaldMin( aa.getFrequency(), aa.getIterationAnnualSalary() ) ;\n\n        if (max < aa.getIterationEeContribAmount()) {\n          aa.adjustEeIterationContribAmount(max);\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            aa.touchErrorString(ErrorUtilities.createErrorStringForSingleAccountNonIRSInfraction(aa));\n          }\n        } // 140507 JSS out                if( min > aa.getIterationEeContribAmount() ) {\n        // 140507 JSS out                    aa.adjustEeIterationContribAmount( min ) ;\n        // 140507 JSS out                }\n\n      }\n    }\n  };\n\n  BaseAccumulator.resolveContribsToIRSLimits = function (accountList) {\n    var limits = [IRSConstants.getLimit(IRSConstants._402g1), IRSConstants.getLimit(IRSConstants._457e15), IRSConstants.getLimit(IRSConstants._414v), IRSConstants.getLimit(IRSConstants._415c1A)];\n    var index = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = LimitUtilities.getIndexFor_402g1_457e15_414v_Limits(aa.getType(), aa.getIRC());\n\n      if (index > -1) {\n        if (aa.getIterationEeContribAmount() * aa.getModes() > limits[index]) {\n          aa.adjustEeIterationContribAmount(limits[index] / aa.getModes());\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            aa.setIrsInfraction(true);\n            aa.touchErrorString(ErrorUtilities.createErrorStringForSingleAccountIRSInfraction(aa));\n          }\n        }\n      }\n    }\n  };\n\n  BaseAccumulator.resolveContribsToSalaryAsLimit = function (accountList, annualSalary) {\n    var limits = [annualSalary];\n    var index = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = LimitUtilities.getIndexFor_402g1_457e15_414v_Limits(aa.getType(), aa.getIRC());\n\n      if (index > -1) {\n        index = 0; // common value\n\n        if (aa.getIterationEeContribAmount() * aa.getModes() > limits[index]) {\n          aa.adjustEeIterationContribAmount(limits[index] / aa.getModes());\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            aa.touchErrorString(ErrorUtilities.createErrorStringForExceedingSalary());\n          }\n\n          limits[index] = 0.0;\n        } else {\n          limits[index] = limits[index] - aa.getIterationEeContribAmount() * aa.getModes();\n        }\n      }\n    }\n  };\n\n  BaseAccumulator.resolveContribsToGlobalNonIRSLimit = function (mml, al, annualSalary) {\n    var annualMax = mml.getAnnualMax(annualSalary); //var annualMin = mml.getAnnualMin(annualSalary) ;\n\n    var index = -1;\n\n    for (var i = 0; i < al.length; i++) {\n      var aa = al[i];\n      index = LimitUtilities.getIndexFor_402g1_457e15_414v_Limits(aa.getType(), aa.getIRC()); // 140130 TODO: use another method to derive index?\n      // handle conditions of application\n\n      if (index > -1 && (mml.getPlanIndex() < 0 || mml.getPlanIndex() > -1 && mml.getPlanIndex() == aa.getPlanIndex())) {\n        if (aa.getIterationEeContribAmount() * aa.getModes() > annualMax) {\n          aa.adjustEeIterationContribAmount(annualMax / aa.getModes());\n          aa.touchMaxPeriod(aa.getIterationPeriod());\n          aa.touchErrorCode(aa.getIterationPeriod());\n\n          if (BaseAccumulator.REPORTABLE == aa.getIterationPeriod()) {\n            var limit = mml.getAnnualMax(annualSalary);\n            aa.touchErrorString(ErrorUtilities.createErrorStringForMultiple(limit / aa.getIterationEeAnnualSalary(), limit / aa.getModes()));\n          }\n\n          annualMax = 0.0;\n        } else {\n          annualMax = annualMax - aa.getIterationEeContribAmount() * aa.getModes();\n        }\n      }\n    }\n  };\n\n  BaseAccumulator.sumTotalAccum = function (list) {\n    var total = 0.0;\n\n    for (var i = 0; i < list.length; i++) {\n      var aa = list[i];\n      total += aa.getEeLumpAmount() + aa.getEeEarningsOnLumpAmount() + aa.getErLumpAmount() + aa.getErEarningsOnLumpAmount() + aa.getEeContribBucket() + aa.getEeEarningsOnContribs() + aa.getErContribBucket() + aa.getErEarningsOnContribs();\n    }\n\n    return total;\n  };\n\n  BaseAccumulator.resolveEEaccordingToER = function (accountList, index, target) {\n    // vars for iterations\n    var iterator = 0;\n    var high = target;\n    var low = 0.0;\n    var test = -1.0; // seeded to force iteration\n\n    var solve = 0.0;\n\n    var _holder = DoubleScratchPad.newInstance();\n\n    _holder.zero();\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n\n      if (aa.isEmployerMatch()) {\n        if (index == aa.getIndex()) {\n          high = aa.getIterationEeContribAmount(); // set sensible high and low values\n\n          low = aa.getIterationErContribAmount() * 0.5;\n\n          while (Math.abs(test) > 0.0049 && iterator < 15) {\n            iterator++;\n            if (test < 0.0) low = solve;else high = solve; //\n\n            solve = (high + low) / 2.0;\n            aa.adjustEeIterationContribAmount(solve);\n            aa.setIterationErContribAmount(_holder.get(aa.getEmployerMatchId())); //\n\n            test = solve + aa.getIterationErContribAmount() - target;\n          }\n        }\n\n        _holder.touch(aa.getEmployerMatchId(), aa.getIterationEeContribAmount());\n      }\n    }\n  }; // 170530 ///////////////////////////////////////////\n\n\n  BaseAccumulator.getAnnualEEContribs = function (accountList, typeList) {\n    var retValue = 0.;\n    var index = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = LimitUtilities.checkList(aa.getType(), typeList, true);\n\n      if (index > -1) {\n        retValue += aa.getPeriodicEeContrib();\n      }\n    }\n\n    return retValue;\n  }; // let's get this in!  ...\n\n\n  BaseAccumulator.resolveSalaryTo401a17Limits = function (accountList, annualSalaryRef, annualSalary401a17Ref) {\n    // apply annual salary ref\n    var eeOrEr = true;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      aa.setIterationEeAnnualSalary(annualSalaryRef);\n      aa.setIterationErAnnualSalary(annualSalaryRef);\n\n      if (annualSalaryRef > annualSalary401a17Ref) {\n        eeOrEr = true;\n\n        if (LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), eeOrEr)) {\n          aa.setIterationEeAnnualSalary(annualSalary401a17Ref);\n          aa.touchErrorCode(aa.getIterationPeriod()); //if( REPORTABLE == aa.getIterationPeriod() ) {  // presently, this is not reportable\n          //aa.setIRSInfraction( true ) ;\n\n          aa.touchErrorString(ErrorUtilities.createErrorStringFor401a17SalaryLimit(aa)); //}\n        }\n\n        eeOrEr = false;\n\n        if (LimitUtilities.apply401a17SalaryLimit(aa.getType(), aa.getIRC(), eeOrEr)) {\n          aa.setIterationErAnnualSalary(annualSalary401a17Ref);\n          aa.touchErrorCode(aa.getIterationPeriod()); //if( REPORTABLE == aa.getIterationPeriod() ) {  // presently, this is not reportable\n          //aa.setIRSInfraction( true ) ;\n\n          aa.touchErrorString(ErrorUtilities.createErrorStringFor401a17SalaryLimit(aa)); //}\n        }\n      }\n    }\n  };\n  /*\n      // use getPlanId() [?? and getPlanIndex()] to confirm whether multiple plans or not\n      BaseAccumulator.isMultiPlan = function( accountList ) {\n          var ret = false ;\n          var planIndex = -1 ;\n          var planId = \"\" ;\n          var count = 0 ;\n  \n          for( var i = 0 ; i < accountList.length ; i++ ) {\n              var aa = accountList[i] ;\n              if( count < 1 ) {\n                  planIndex = aa.getPlanIndex() ;\n                  planId = aa.getPlanId() ;\n              }\n  \n              //if( ( planIndex != aa.getPlanIndex() ) || !planId.equals( aa.getPlanId() ) ) {\n              if( !planId.equals( aa.getPlanId() ) ) {\n                  ret = true ;\n                  break ;\n              }\n              count++ ;\n          }\n          return( ret ) ;\n      } ;\n  \n      BaseAccumulator.getPlanIdList = function( accountList ) {\n          var ret = [] ;\n          var count = 0 ;\n  \n          for( var i = 0 ; i < accountList.length ; i++ ) {\n              var aa = accountList[i] ;\n              if( count < 1 ) {\n                  ret.push( aa.getPlanId() ) ;\n              }\n              if( !ret.contains( aa.getPlanId() ) ) {\n                  ret.push( aa.getPlanId() ) ;\n              }\n              count++ ;\n          }\n          return( ret ) ;\n      } ;\n  \n  */\n\n\n  BaseAccumulator.getModelledLoanPlanId = function (accountList) {\n    var ret = \"\";\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n\n      if (aa.isLoan() && aa.getType() == AccountTypes.TYPE_NEWLOAN) {\n        ret = aa.getPlanId();\n        break;\n      }\n    }\n\n    return ret;\n  };\n\n  BaseAccumulator.getModelledLoanPlanIndex = function (accountList) {\n    var ret = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n\n      if (aa.isLoan() && aa.getType() == AccountTypes.TYPE_NEWLOAN) {\n        ret = aa.getPlanIndex();\n        break;\n      }\n    }\n\n    return ret;\n  };\n\n  BaseAccumulator.getLumpAmountAccordingToType = function (accountList, typeList) {\n    var retValue = 0.0;\n    var index = -1;\n\n    for (var i = 0; i < accountList.length; i++) {\n      var aa = accountList[i];\n      index = LimitUtilities.checkList(aa.getType(), typeList, true);\n\n      if (index > -1) {\n        retValue += aa.getEeLumpAmount() + aa.getErLumpAmount();\n      }\n    }\n\n    return retValue;\n  };\n\n  BaseAccumulator.REPORTABLE = 0;\n  return BaseAccumulator;\n});","map":null,"metadata":{},"sourceType":"script"}